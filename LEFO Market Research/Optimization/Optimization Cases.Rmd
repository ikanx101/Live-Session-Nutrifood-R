---
title: "Training Optimization Nutrifood x FINANMOS ITB"
subtitle: "Sebuah Catatan Short Course"
author: "Ikanx Fadhli @nutrifood"
date: "9 April 2021"
output:
    rmdformats::readthedown:
    highlight: espresso
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 99)
```


# Kata Pengantar

*Alhamdulillah*, *training optimization* telah selesai dilakukan. Peserta merupakan *Nutrifooders* dari tim *market research* dan beberapa tim *member* dari departemen lain yang terkait.

Diharapkan *training* ini memberikan wawasan baru terkait penggunaan metode matematika untuk menyelesaikan masalah *optimization* yang terjadi di banyak area kerja Nutrifood.

Semoga bisa berguna.

Bekasi, 9 April 2021.

Pengepul materi *training*,

Ikang Fadhli


# Pendahuluan

Catatan ini berisi *R Markdown* penyelesaian dari beberapa kasus yang diberikan pada saat ***optimization training*** oleh **FINANMOS ITB** 2021.

## Catatan Penting Tentang *Optimization*

*Optimization* berarti proses pencarian suatu nilai yang **optimal**. Kondisi optimal bisa terjadi saat sesuatu bernilai **maksimum** atau **minimum**.

Hal tersebut yang harus kita pahami.

Permodelan matematika terkait *optimization* tidak lepas dari `4` hal berikut ini:

1.  *Decision Variable*, yakni nilai yang ingin dicari. Diharapkan dari nilai ini akan tercipta kondisi yang optimal.
2.  *Parameter*, yakni nilai yang besarannya *given*. Jika kita melihat pada kasus *real*, parameter adalah nilai yang tidak kita kontrol.
3.  *Constraints*, yakni *boundaries* (limitasi) yang ada pada *problem* yang dihadapi. Bisa jadi dalam suatu kasus, kita membuat permodelan matematika yang tidak memiliki *constraints*.
4.  *Objective function*, yakni kondisi optimal yang harus dipenuhi.

*Parameter* dan *decision variable* akan muncul pada *constraints* dan *objective function*.

Suatu *decision variable* disebut *feasible* jika:

> ***Decision variable yang didapatkan tidak melanggar constraints.***

Suatu *decision variable* disebut optimal jika:

> ***Decision variable yang didapatkan memenuhi objective function.***

## Contoh Kasus yang Dibahas

```{r out.height= "50%" ,echo=FALSE}
knitr::include_graphics("contoh.jpg")
```

Saya menggunakan **R** untuk membuat model *optimization* dan di-*solve* dengan *engine* yang tersedia di `library(ompr)`. Tipe variabel penentuan yang didukung oleh `ompr` antara lain:

1.  `binary`
2.  `continuos`
3.  `integer`

Agak berbeda dengan *libraries* yang akan digunakan saat *training* dengan **FINANMOS ITB** kelak namun tetap menghasilkan hasil yang sama. Karena persoalan yang pentingnya adalah bagaimana memodelkan masalah *real* ke permodelan matematikanya. Jika sudah termodelkan, akan mudah dimasukkan ke berbagai *libraries* yang ada di **R**.


# **Koperasi Susu Berkah I**

## Masalah

Manajemen **Koperasi Susu Berkah** (**KSB**) setiap harinya menerima `1000` liter susu dari para anggotanya untuk diproduksi menjadi *yogurt* atau keju *mozarella*.

-   Keuntungan dari setiap liter susu yang terjual adalah `Rp1.000`.
-   Keuntungan dari *yogurt* yang terjual dari bahan satu liter susu adalah `Rp1.200`
-   Sedangkan keuntungan keju *mozarella* dari bahan satu liter susu adalah `Rp900`.

Setelah menganalisa data penjualan, manajemen koperasi mendapatkan informasi sebagai berikut:

-   Paling banyak `500` liter susu.
-   *Yogurt* paling banyak bisa dibuat dari bahan `300` liter susu.
-   Keju *mozarella* paling banyak bisa dibuat dari bahan `400` liter susu.

Dari informasi di atas, manajemen **KSB** ingin menentukan berapa banyak susu yang harus dibuat *yogurt*, susu yang harus dibuat keju *mozarella*, dan susu yang dijual langsung, agar keuntungan yang didapat maksimal.

## Model Matematika

Dari kasus di atas, kita akan membuat model matematikanya.

### Variabel Penentuan

Misalkan saya notasikan `3` variabel berikut ini:

-   $x_1$ sebagai seberapa banyak (dalam liter) susu yang bisa dijual langsung,
-   $x_2$ sebagai seberapa banyak (dalam liter) susu yang bisa dibuat *yogurt*, dan
-   $x_3$ sebagai seberapa banyak (dalam liter) susu yang bisa dibuat keju *mozarella*.

Di mana:

$$x_1,x_2,x_3   \in \mathbb{Z}$$

### *Constraints*

Berikut adalah *constraints* yang ada pada kasus di atas:

-   $0 \leq x_1 \leq 500$
-   $0 \leq x_2 \leq 300$
-   $0 \leq x_3 \leq 400$
-   $x_1 + x_2 + x_3 = 1000$

### *Objective Function*

Tujuan utama permodelan matematika ini adalah **memaksimalkan** *profit* yang ingin dicapai **KSB**, yakni:

$$max(1000x_1 + 1200x_2 + 900x_3)$$

## *Solver R*

### Penulisan Model Matematika di **R**

Untuk menyelesaikan masalah ini, saya akan menggunakan *solver* di **R**. Berikut adalah model yang saya buat:

```{r,message=FALSE,warning=FALSE}
# dimulai dengan hati yang bersih
rm(list=ls())

# memanggil libraries
library(dplyr)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

#  set vector profit
profit = c(1000,1200,900)

# membuat model
model = 
  MIPModel() %>%
  # add variables
  # non negative integers
  add_variable(x[i],i = 1:3,
               type = "integer",
               lb = 0) %>%
  # set obj function
  set_objective(sum_expr(x[i]*profit[i],i = 1:3),
                "max") %>%
  # add constraints
  add_constraint(x[1] <= 500) %>% 
  add_constraint(x[2] <= 300) %>% 
  add_constraint(x[3] <= 400) %>% 
  add_constraint(sum_expr(x[i],i = 1:3) == 1000)
model
```

### *Solving*

Kemudian saya *solve* dengan **R**:

```{r,message=FALSE,warning=FALSE}
result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
```

### *Final Result*

Saya dapatkan konfigurasi terbaik seperti ini:

```{r,message=FALSE,warning=FALSE}
result %>% get_solution(x[i])
```

Dengan *profit* maksimum sebesar Rp`r round(result$objective_value/1000000,3)` juta.

```{r,include=FALSE}
rm(list=ls())
```

# **Koperasi Susu Berkah II**

Berikut adalah modifikasi dari permasalah di Koperasi Susu Berkah.

## Masalah

Dari Koperasi Susu Berkah tersebut, sebenarnya untuk penjualan susu cair ada resiko tidak terjualnya keseluruhan susu cair pada hari yang sama sebesar `10%`. Setiap susu yang tidak terjual ini akan memberikan kerugian sebesar `Rp500` per liternya.

> ***Berapa profit maksimal yang masih kita peroleh saat resiko tidak terjualnya susu cair terburuk?***

## Model Matematika

Dari kasus di atas, kita cukup memodifikasi model matematika yang *existing*.

### Variabel Penentuan

Saya akan definisikan variabel baru $x_4$, yakni berapa banyak susu cair yang tidak terjual.

### *Objective Function*

Sekarang, *objective function*-nya berubah menjadi:

$$min(1000x_1 + 1200x_2 + 900x_3 - 500x_4)$$ Kenapa dibuat *min*? Karena kita ingin menghitung profit terbaik saat resiko terburuk.

### *Constraint*

Sekarang saya tambahkan satu *constraint* terkait $x_4$.

$$0 \leq x_4 \leq 0.1x_1$$

dan

$$x_1 + x_2 + x_3 + x_4 = 1000$$

## *Solver* **R**

### Model Matematika di **R**

Berikut adalah penulisan model matematika di **R**:

```{r,message=FALSE,warning=FALSE}
# dimulai dengan hati yang bersih
rm(list=ls())

# memanggil libraries
library(dplyr)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

#  set vector profit
profit = c(1000,1200,900,-500)

# membuat model
model = 
  MIPModel() %>%
  # add variables
  # non negative integers
  add_variable(x[i],i = 1:4,
               type = "continuous",
               lb = 0) %>%
  # set obj function
  set_objective(sum_expr(x[i]*profit[i],i = 1:4),
                "min") %>%
  # add constraints
  add_constraint(sum_expr(x[i],i = 1:4) == 1000) %>% 
  add_constraint(x[1] <= 500) %>% 
  add_constraint(x[2] <= 300) %>% 
  add_constraint(x[3] <= 400) %>% 
  add_constraint(x[4] - .1*x[1] <= 0)
model
```

### *Solving*

```{r}
result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
```

### *Final Result*

Berikut adalah *final result*-nya:

```{r}
result %>% get_solution(x[i])
result$objective_value
```



```{r,include=FALSE}
rm(list=ls())
```

# **Tiga Mesin Filling**

## Masalah

Di sebuah perusahaan, departemen *filling* dan *packing* memiliki tiga jenis mesin yang selalu beroperasi setiap harinya. Setiap mesin memiliki kapasitas, biaya proses per unit produk, dan biaya *setup* masing-masing.

Berikut adalah datanya:

```{r,echo=FALSE}
data = data.frame(
  mesin =  c(1:3),
  biaya_setup = c(300,100,200),
  biaya_proses_unit = c(2,10,5),
  kapasitas = c(600,800,1200)
)
knitr::kable(data,align = "c",caption = "Data Mesin Filling dan Packing")
```

Mengingat di setiap mesin harus ada pekerja yang ditugaskan untuk menjalankannya, manajemen mengambil keputusan bahwa jika suatu mesin digunakan, maka mesin tersebut paling sedikit harus memproses `400` unit produk.

Di suatu hari, terdapat beban kerja sebanyak `2000` unit produk yang harus diproses *filling* dan *packing*-nya.

> ***Berapa konfigurasi produk per mesin yang paling optimal?***

## Model Matematika

Dari kasus di atas, kita akan membuat model matematikanya.

### Variabel Penentuan

Misalkan saya notasikan `3` variabel berikut ini:

-   $x_1$ sebagai seberapa banyak (dalam unit) produk yang dijalankan di mesin I,
-   $x_2$ sebagai seberapa banyak (dalam unit) produk yang dijalankan di mesin II, dan
-   $x_3$ sebagai seberapa banyak (dalam unit) produk yang dijalankan di mesin III.

Di mana:

$$x_1,x_2,x_3   \in \mathbb{Z}$$

### *Constraints*

Berikut adalah *constraints* yang ada pada kasus di atas:

-   $400 \leq x_1 \leq 600$
-   $400 \leq x_2 \leq 800$
-   $400 \leq x_3 \leq 1200$
-   $x_1 + x_2 + x_3 = 2000$

### *Objective Function*

Tujuan utama permodelan matematika ini adalah **meminimalkan** *cost* yang terjadi di semua mesin, yakni:

$$min((300+2x_1) + (100+10x_2) + (200+5x_3))$$

## *Solver R*

### Penulisan Model Matematika di **R**

Untuk menyelesaikan masalah ini, saya akan menggunakan *solver* di **R**. Berikut adalah model yang saya buat:

```{r,message=FALSE,warning=FALSE}
# dimulai dengan hati yang bersih
rm(list=ls())

# memanggil libraries
library(dplyr)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

#  set vector fixed cost
fixed_cost = c(300000,100000,200000)

# set vector cost per unit
cost_per_unit = c(2000,10000,5000)

# membuat model
model = 
  MIPModel() %>%
  # add variables
  # non negative integers
  add_variable(x[i],i = 1:3,
               type = "integer",
               lb = 400) %>%
  # set obj function
  set_objective((fixed_cost[1]+cost_per_unit[1]*x[1]) + (fixed_cost[2]+cost_per_unit[2]*x[2]) + (fixed_cost[3]+cost_per_unit[3]*x[3]),
                "min") %>%
  # add constraints
  add_constraint(x[1] <= 600) %>% 
  add_constraint(x[2] <= 800) %>% 
  add_constraint(x[3] <= 1200) %>% 
  add_constraint(sum_expr(x[i],i = 1:3) == 2000)
model
```

### *Solving*

Kemudian saya *solve* dengan **R**:

```{r,message=FALSE,warning=FALSE}
result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
```

### *Final Result*

Saya dapatkan konfigurasi terbaik seperti ini:

```{r,message=FALSE,warning=FALSE}
result %>% get_solution(x[i])
```

Dengan *cost* minimum sebesar Rp`r round(result$objective_value/1000000,3)` juta.



```{r,include=FALSE}
rm(list=ls())
```

# **Lampu Penerangan Jalan**

## Masalah

Perhatikan gambar di bawah ini:

```{r out.height="25%",echo=FALSE,fig.align='center'}
print("Courtesy of: FINANMOS ITB 2021")
knitr::include_graphics("download.png")
```

Suatu komplek perumahan dengan denah seperti di atas memiliki `11` jalan. Setiap pertemuan jalan, diberikan tanda nomor `1` hingga `8`. *Town management* hendak memasang lampu penerangan di **setiap pertemuan jalan tersebut**.

Tujuan utama mereka adalah memasang lampu sehingga **semua jalan** diterangi paling sedikit satu lampu.

> ***Di titik mana saja town management harus memasang lampu-lampu tersebut?***

## Model Matematika

Dari kasus di atas, kita akan membuat model matematikanya.

### Parameter

Misalkan saya notasikan $Jl$ sebagai himpunan jalan, yakni:

$$Jl = \{A,B,C,D,E,F,G,H,I,J,K\}$$

Misalkan saya notasikan $J$ sebagai himpunan titik-titik pertemuan jalan, yakni:

$$J = \{1,2,3,4,5,6,7,8\}$$

### Variabel Penentuan

Kemudian saya akan tuliskan $x_j$ sebagai *binary number* yang menyatakan apakah lampu dipasang atau tidak di titik $j \in J$.

$$x_j = \begin{cases} 1,& \text{ jika di titik } j \text{ dipasang lampu}\\ 0, & \text{ lainnya.}\end{cases}$$ Misalkan:

-   $x_1=0$, artinya lampu di titik `1` **tidak dipasang lampu**.
-   $x_2=1$, artinya lampu di titik `2` **dipasang lampu**.

### *Constraints*

Dengan variabel keputusan seperti di atas, maka sesuai keinginan kita menerangi **setiap jalan paling sedikit dengan satu lampu**, kita mempunyai kendala:

1.  $x_1 + x_2 \geq 1$ untuk **Jalan A**.
2.  $x_2 + x_3 \geq 1$ untuk **Jalan B**.
3.  $x_1 + x_6 \geq 1$ untuk **Jalan G**.
4.  $x_2 + x_6 \geq 1$ untuk **Jalan F**.
5.  $x_2 + x_4 \geq 1$ untuk **Jalan I**.
6.  $x_4 + x_7 \geq 1$ untuk **Jalan H**.
7.  $x_4 + x_5 \geq 1$ untuk **Jalan C**.
8.  $x_7 + x_8 \geq 1$ untuk **Jalan D**.
9.  $x_3 + x_5 \geq 1$ untuk **Jalan K**.
10. $x_6 + x_7 \geq 1$ untuk **Jalan E**.
11. $x_5 + x_8 \geq 1$ untuk **Jalan J**.

### *Objective Function*

Tujuan utama permodelan matematika ini adalah **meminimalkan** banyaknya titik yang dipasang lampu penerangan, yakni:

$$min(\sum x_j, j\in J)$$



## *Solver R*

### Penulisan Model Matematika di **R**

Untuk menyelesaikan masalah ini, saya akan menggunakan *solver* di **R**. Berikut adalah model yang saya buat:

```{r,message=FALSE,warning=FALSE}
# dimulai dengan hati yang bersih
rm(list=ls())

# memanggil libraries
library(dplyr)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

# membuat model
model = 
  MIPModel() %>%
  # add variables
  # binary
  add_variable(x[i],
               i = 1:8,
               type = "binary",
               lb = 0) %>%
  # set obj function
  set_objective(sum_expr(x[i],i = 1:8),
                "min") %>%
  # add constraints
  add_constraint(x[1] + x[2] >= 1) %>% 
  add_constraint(x[2] + x[3] >= 1) %>% 
  add_constraint(x[1] + x[6] >= 1) %>%
  add_constraint(x[2] + x[6] >= 1) %>%
  add_constraint(x[2] + x[4] >= 1) %>%
  add_constraint(x[4] + x[7] >= 1) %>%
  add_constraint(x[4] + x[5] >= 1) %>%
  add_constraint(x[7] + x[8] >= 1) %>%
  add_constraint(x[3] + x[5] >= 1) %>%
  add_constraint(x[6] + x[7] >= 1) %>%
  add_constraint(x[5] + x[8] >= 1)
model
```



### *Solving*

Kemudian saya *solve* dengan **R**:

```{r,message=FALSE,warning=FALSE}
result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
```

### *Final Result*

Saya dapatkan konfigurasi terbaik seperti ini:

```{r,message=FALSE,warning=FALSE}
result %>% get_solution(x[i]) %>% filter(value == 1)
```

Dengan banyak lampu minimum terpasang sebanyak `r round(result$objective_value)` buah.



```{r,include=FALSE}
rm(list=ls())
```

# **Perusahaan Cat**

## Masalah

Suatu perusahaan memproduksi `4` warna cat yaitu:

-   Putih,
-   Kuning,
-   Hitam, dan
-   Merah.

Keempat cat tersebut diproduksi di mesin-mesin yang sama, sehingga ada keperluan untuk mencuci mesin-mesin tersebut di antara produksi `2` cat yang berbeda warna.

Kita mempunyai masalah untuk menentukan urutan produksi cat harian yang *optimal*, yakni urutan produksi cat yang menghasilkan total waktu pencucian paling kecil.

> ***Urutan harian ini akan dipakai tiap hari, karena perusahaan setiap hari harus memproduksi keempat cat tersebut.***

Tabel berikut menampilkan waktu pencucian antara produksi cat di suatu baris jika akan dilanjutkan dengan cat di suatu kolom.

```{r,echo=FALSE,message=FALSE,warning=FALSE}
data = data.frame(putih = c(NA,20,50,45),
                  kuning = c(10,NA,44,40),
                  hitam = c(17,19,NA,20),
                  merah = c(15,18,25,NA))

row.names(data) = c("putih","kuning","hitam","merah")

options(knitr.kable.NA = '~')
knitr::kable(data,row.names = T,align = "c",caption = "Matriks Cleaning Mesin Cat (dalam menit)")
```

> ***Urutan produksi cat seperti apa yang meminimalkan waktu cleaning?***

## Metode Heuristik

Sebenarnya masalah di atas mirip sekali dengan **Travelling Salesperson Problem**, yakni suatu masalah *optimization* yang mencari rute terpendek dari beberapa tempat.

Jadi alih-alih menggunakan metode *Mixed Integer Linear Programming* (**MILP**) yang biasa saya pakai untuk menyelesaikan *optimization*, saya akan menggunakan cara **TSP** saja.



### *How to*

Langkah pertama adalah menyiapkan matriks cleaning terlebih dahulu, yakni dengan mengubah `data` yang berupa *dataframe* ke bentuk *matrix* di **R**.

```{r}
data[is.na(data)] = 0
level = rownames(data)
matriks = as.matrix(data)
matriks
```

Jika kita perhatikan dengan baik. Matriks *cleaning* di atas berbentuk asimetris. Artinya waktu *cleaning* dari cat `1` ke `2` **tidak sama** dengan waktu *cleaning* dari cat `2` ke `1`.

Oleh karena itu, saya akan membuat *problem* **Assymetric TSP** (**ATSP**) untuk kemudian di-*solve*.

```{r}
library(TSP)
problem = as.ATSP(matriks)
hasil = solve_TSP(problem)
hasil
```

Didapatkan waktu *cleaning* terkecil adalah sebesar `98` menit.

### *Final Result*

Saya dapatkan urutan terbaik seperti ini:

```{r}
paste(level[as.integer(hasil)],collapse = " - ")
```



## Metode Eksak

Sekarang kita akan menyelesaikan persoalan urutan cat ini dengan metode eksak dengan `ompr`.

### Model Matematika

Untuk melakukannya saya akan mendefinisikan beberapa hal sebagai berikut:

#### Parameter Misal saya tuliskan:

-   $W = \{1,2,3,4\}$ sebagai himpunan warna cat yang diproduksi. Angka 1 menunjukkan putih, 2 menunjukkan kuning, 3 menunjukkan hitam, dan 4 menunjukkan merah.
-   $c_{i,j}$ menunjukkan waktu *cleaning* antara produksi cat warna ke $i$ dan $j$, $i,j \in W$.

#### Variabel Keputusan Misal saya tuliskan:

$$x_{i,j} = \begin{cases} 1,& \text{ jika pabrik memproduksi cat ke } i \text{ dilanjutkan cat ke } j \\ 0, & \text{ lainnya.}\end{cases}$$

#### *Constraints*

Mari kita bangun beberapa *constraints* dari kasus ini.

*Constraint* pertama adalah satu warna hanya bisa diikuti oleh satu warna yang lain. Maksudnya dari warna ke $i$, hanya bisa diikuti *unique* oleh warna ke $j$. Saya tuliskan ekspresinya menjadi:

$$\sum_{j \in W,j \neq i} x_{i,j} = 1$$

*Constraint* kedua adalah satu warna hanya bisa berasal dari satu warna yang lain. Maksudnya dari warna $i$, hanya bisa berasal *unique* dari warna ke $j$. Saya tuliskan ekspresinya menjadi:

$$\sum_{i \in W,i \neq j} x_{i,j} = 1$$

Kedua *constraints* yang di atas ternyata belum cukup untuk menjelaskan kondisi *real*-nya. Kenapa? Kita harus pastikan:

> Semua $i \in W$ terlewati. Solusi yang ada **harus melibatkan semua warna**.

Lantas bagaimana caranya?

Saya akan gunakan induksi sebagai berikut:

Misalkan:

Saya mulai produksi dari titik $1$, maka ada kemungkinan saya akan berakhir ke titik $\{2,3,4\}$. Jika saya memilih untuk masuk ke titik $2$, maka ada kemungkinan saya akan berakhir ke titik $\{3,4\}$. Seandainya itu adalah langkah yang saya lakukan, maka saya tidak boleh melakukan langkah kembali dari $2$ ke $1$.

```{r out.width="30%",echo=FALSE}
nomnoml::nomnoml("
                 [1] -> [2]
                 [1] --> [3]
                 [1] --> [4]
                 
                 [2] -> [3]
                 [2] --> [4]
                 [2] <--> [1]
                 ")

```

Maka saya tuliskan:

$$x_{1,2} + x_{2,1} \leq x_{1,3} + x_{1,4} + x_{2,3} + x_{2,4}$$

Proses ini akan saya ulangi untuk semua alternatif lainnya:

-   Dari $1$ ke $3$ (termasuk kebalikannya),
-   Dari $1$ ke $4$ (termasuk kebalikannya),
-   Dari $2$ ke $3$ (termasuk kebalikannya),
-   Dari $2$ ke $4$ (termasuk kebalikannya),
-   Dari $3$ ke $4$ (termasuk kebalikannya).

Sehingga *constraint* terakhirnya:

$$x_{1,2} + x_{2,1} \leq x_{1,3} + x_{1,4} + x_{2,3} + x_{2,4}$$

$$x_{1,3} + x_{3,1} \leq x_{1,2} + x_{1,4} + x_{3,2} + x_{3,4}$$

$$x_{1,4} + x_{4,1} \leq x_{1,2} + x_{1,3} + x_{4,2} + x_{4,3}$$

$$x_{2,3} + x_{3,2} \leq x_{2,1} + x_{2,4} + x_{3,1} + x_{3,4}$$

$$x_{3,4} + x_{4,3} \leq x_{3,1} + x_{3,2} + x_{4,1} + x_{4,2}$$

#### *Objective Function*

Permasalahan ini adalah meminimalisir waktu *cleaning* dari urutan yang ada, yakni:

$$min(\sum_{i \in W} \sum_{j \in W,j \neq i} x_{i,j}*c_{i,j})$$

### *Solver* **R**

Cara mengerjakan dengan _solver_ __R__ diberikan kepada pembaca sebagai bahan latihan.

```{r,include=FALSE}
rm(list=ls())
```

# ***Nurse Schedulling***

Di bagian ini kita akan mempelajari masalah penjadwalan perawat (*nurse scheduling*) yang mempunyai aturan kerja yang tidak terlalu banyak. Aturan kerja yang dibahas di sini mungkin saja merupakan aturan di suatu rumah sakit saja, yang sedikit berbeda dengan aturan kerja perawat di rumah sakit lainnya. Tetapi tujuan dibuat aturan kerja ini di rumah sakit manapun adalah sama, yaitu aturan yang dibuat agar jam kerja perawat diatur sedemikian hingga sehingga para perawat berada pada kondisi yang baik ketika bekerja.

## Masalah

Lingkungan kerja para perawat yang kita bahas adalah sebagai berikut:

-   Para perawat bekerja pada suatu shift kerja

-   Terdapat `3` shift kerja yaitu:

    -   *day shift* (8.00 - 16.00),
    -   *evening shift* (16.00 - 24.00), dan
    -   *night shift* (24.00 - 8.00)

-   Pada setiap shift dibutuhkan `4` orang perawat.

Selain itu, terdapat beberapa aturan kerja perawat yang harus dipenuhi, yakni:

1.  Setiap perawat dalam satu hari dapat ditugaskan paling banyak dalam satu *shift*.
2.  Jika seorang perawat ditugaskan pada *shift* malam, maka dia tidak dapat ditugaskan di *shift* pagi di hari berikutnya.
3.  Jika seorang perawat ditugaskan dalam `3` hari berturut-turut, maka hari keempatnya harus diberi libur.
4.  Jika seorang perawat ditugaskan pada suatu *shift* di *weekend*, maka dia tidak dapat ditugaskan di *weekend* berikutnya.

> ***Bagaimana jadwal yang optimal? Berapa banyak perawat yang dibutuhkan?***

## Model Matematika

### Membangun Model Matematika

#### *Time Frame*

Untuk memudahkan membuat model matematika *nurse schedulling*, saya akan mendefinisikan terlebih dahulu *time frame* yang hendak digunakan. Apakah akan dibuat jadwal selama seminggu, sebulan, atau periode tertentu.

Untuk itu, saya akan melihat **aturan kerja ke-4**, yakni:

> Jika seorang perawat ditugaskan pada suatu *shift* di *weekend*, maka dia tidak dapat ditugaskan di *weekend* berikutnya.

Dari kasus di atas, setidaknya *time frame* penjadwalan **tersingkat** yang bisa buat adalah dalam waktu `2` minggu.

Dari *time frame* tersebut, kita juga bisa mengandaikan berapa banyak perawat yang dibutuhkan.

#### Berapa banyak perawat yang dibutuhkan?

Dari penjelasan kasus di atas, sebenarnya tidak ada batasan maksimal berapa perawat yang bisa ditugaskan di rumah sakit tersebut. Namun, dari **aturan kerja ke-4** kita bisa hitung secara kasar berapa minimal perawat yang harus ditugaskan.

> Bagaimana caranya?

Mari kita ingat beberapa hal berikut ini:

1.  *Weekend* terjadi pada hari Sabtu dan Minggu.
2.  Setiap hari ada `3` *shifts*.
3.  Setiap *shift* minimal ada `4` perawat.
4.  Perawat yang sudah ditugaskan di *weekend* I, tidak boleh ditugaskan di *weekend* II.

Oleh karena itu, pada *weekend* I paling sedikit kita bisa menugaskan $3*4=12$ orang perawat.

> Pada *weekend* I, kita bisa mempekerjakan `12` perawat pada Sabtu dan Minggu.

Ke-`12` orang perawat ini tidak boleh ditugaskan di *weekend* II. Sehingga dibutuhkan $3*4=12$ orang perawat lainnya di *weekend* II.

> ***Sehingga dibutuhkan minimal `24` orang perawat untuk `2` minggu ini.***

### Parameter

Dari penjelasan-penjelasan di atas, saya akan mendefinisikan beberapa hal, yakni:

-   $H = \{1,2,3,4,5,6,7,8,9,10,11,12,13,14\}$ adalah himpunan hari dalam *time frame* `2` minggu. Saya tuliskan `1` sebagai Senin. *Weekend* terjadi pada $H_w = \{6,7,13,14\}$.
-   $S = \{1,2,3\}$ adalah himpunan *shift* kerja harian perawat.
-   $N = \{1,2,3,4,...,24\}$ adalah himpunan banyaknya perawat yang dibutuhkan. Pada mulanya, saya akan *set* dulu sebanyak `24` orang perawat. Jika ternyata tidak *feasible*, maka akan saya tambah satu demi satu sehingga ditemukan solusi *feasible*.

### Variabel Penentuan

Saya definisikan:

$$x_{n,h,s} = \begin{cases} 1,& \text{ jika di perawat ke } n \text{ bekerja di hari } h \text{ pada shift ke }s\\ 0, & \text{ lainnya.}\end{cases}$$

### *Constraints*

Sekarang kita akan menuliskan *constraints* dalam bahasa matematika.

#### *Constraint* I

Setiap perawat dalam satu hari dapat ditugaskan paling banyak dalam satu *shift*.

$$x_{n,h,1} + x_{n,h,2} + x_{n,h,3} \leq 1 \text{, untuk } n \in N \text{ dan } h \in H$$

Ekspresi matematika di atas memastikan bahwa seorang perawat hanya bisa ditugaskan dalam **satu shift** per hari **atau** tidak ditugaskan sama sekali.

#### *Constraint* II

Jika seorang perawat ditugaskan pada *shift* malam, maka dia tidak dapat ditugaskan di *shift* pagi.

$$x_{n,h,3} + x_{n,h+1,1} \leq 1 \text{, untuk } n \in N \text{ dan } h \in \{1,2,..,13\}$$

Ekspresi matematika di atas memastikan bahwa seorang perawat yang bertugas *night shift* pada hari $h$ tidak boleh bertugas pada *shift* pagi esok harinya ($h+1$) **atau** perawat tersebut tidak ditugaskan sama sekali.

#### *Constraint* III

Jika seorang perawat ditugaskan dalam `3` hari berturut-turut, maka hari keempatnya harus diberi libur.

Jadi seorang perawat bisa saja bertugas di berbagai *shift* selama 3 hari berturut-turut tapi **tidak diperbolehkan** untuk bertugas di hari keempat.

$$x_{n,h,1} + x_{n,h+1,1} + x_{n,h+2,1} + x_{n,h+3,1} +$$

$$x_{n,h,2} + x_{n,h+1,2} + x_{n,h+2,2} + x_{n,h+3,2} +$$

$$x_{n,h,3} + x_{n,h+1,3} + x_{n,h+2,3} + x_{n,h+3,3} \leq 3 \text{, untuk } n \in N \text{ dan } h \in \{1,2,..,11\}$$

#### *Constraint* IV

Jika seorang perawat ditugaskan pada suatu *shift* di *weekend*, maka dia tidak dapat ditugaskan di *weekend* berikutnya.

Saya telah menuliskan *weekend* terjadi saat $H \in \{6,7,13,14\}$.

Bagi saya, *constraint* IV merupakan *constraint* yang tersulit untuk dituliskan model matematikanya. Oleh karena itu, saya akan gunakan induksi sebagai berikut:

##### Tanggal `6`

Jika seorang perawat bertugas di hari `6` (*shift* apapun), dia tidak boleh bertugas di hari `13` dan `14`. Tapi jika dia tidak bertugas di hari `6`, maka dia diperbolehkan bertugas di hari `13` **dan atau** `14`. Akibatnya:

-   Jika $x_{n,6,s} = 1$ maka $x_{n,13,s} + x_{n,14,s} = 0$
-   Jika $x_{n,6,s} = 0$ maka $x_{n,13,s} + x_{n,14,s} \leq 2$ karena perawat tersebut bisa bertugas di tanggal `13` **dan atau** `14`.

Maka model matematika pada *constraint* tanggal `6` adalah sebagai berikut:

$$ 2\sum_{s \in S} x_{n,6,s} + \sum_{s \in S}x_{n,13,s} + \sum_{s \in S}x_{n,14,s} \leq 2 
\text{, untuk } n \in N $$

##### Tanggal `7`

Dengann prinsip yang sama dengan tanggal `6`, saya bisa dapatkan model matematika pada *constraint* tanggal `7` adalah sebagai berikut:

$$ 2\sum_{s \in S} x_{n,7,s} + \sum_{s \in S}x_{n,13,s} + \sum_{s \in S}x_{n,14,s} \leq 2 
\text{, untuk } n \in N $$

#### *Constraint* V

Ada satu *constraint* terakhir yang kita tidak boleh lupakan. Apa itu?

Setiap *shift* harus dilayani minimal `4` orang perawat.

$$\sum_{n \in N} x_{n,h,s} \geq 4 \text{, untuk } h \in H,  \text{ dan } s \in S$$

### *Objective Function*

$$min \sum_{n \in N} \sum_{h \in H} \sum_{s \in S} x_{n,h,s} $$



## *Solver R*

### Penulisan Model Matematika di **R**

Berikut adalah penulisan model matematika di **R**:

```{r,message=FALSE,warning=FALSE}
# dimulai dengan hati yang bersih
rm(list=ls())

# memanggil libraries
library(dplyr)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

# membuat model
model = 
  MIPModel() %>%
  # add variables
  # non negative integers
  add_variable(x[n,h,s],
               n = 1:24,
               h = 1:14,
               s = 1:3,
               type = "binary",
               lb = 0) %>%
  # set obj function
  set_objective(sum_expr(x[n,h,s],
                         n = 1:24,
                         h = 1:14,
                         s = 1:3),
                "min") %>%
  # add constraints
  # constraint I
  add_constraint(x[n,h,1] + x[n,h,2] + x[n,h,3] <= 1, 
                 n = 1:24,
                 h = 1:14) %>% 
  # constraint II
  add_constraint(x[n,h,3] + x[n,h+1,1] <= 1,
                 n = 1:24,
                 h = 1:13) %>% 
  # constraint III
  add_constraint(x[n,h,1] + x[n,h+1,1] + x[n,h+2,1] + x[n,h+3,1] + 
                 x[n,h,2] + x[n,h+1,2] + x[n,h+2,2] + x[n,h+3,2] + 
                 x[n,h,3] + x[n,h+1,3] + x[n,h+2,3] + x[n,h+3,3] <= 3,
                 n = 1:24,
                 h = 1:11) %>% 
  # constraint IV tanggal 6
  add_constraint(2*(x[n,6,1] + x[n,6,2] + x[n,6,3]) + 
                 sum_expr(x[n,13,s],
                          s = 1:3) + 
                 sum_expr(x[n,14,s],
                          s = 1:3) <= 2,
                 n = 1:24) %>% 
  # constraint IV tanggal 7
  add_constraint(2*(x[n,7,1] + x[n,7,2] + x[n,7,3]) + 
                 sum_expr(x[n,13,s],
                          s = 1:3) + 
                 sum_expr(x[n,14,s],
                          s = 1:3) <= 2,
                 n = 1:24) %>% 
  # contraint V
  add_constraint(sum_expr(x[n,h,s],
                          n = 1:24) >= 4,
                 h = 1:14,
                 s = 1:3)
model
```

### *Solving*

Kemudian saya *solve* dengan **R**:

```{r,message=FALSE,warning=FALSE}
result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
```



## Solusi Optimal

### Jadwal Optimal

Berikut adalah jadwal optimal dalam kasus ini:

```{r,echo=FALSE,message=FALSE,warning=FALSE}
result %>% 
  get_solution(x[n,h,s]) %>%
  filter(value == 1) %>% 
  group_by(h,s) %>% 
  summarise(perawat = paste(n,collapse = ",")) %>% 
  ungroup() %>% 
  mutate(s = case_when(s == 1 ~ "Pagi",
                       s == 2 ~ "Siang",
                       s == 3 ~ "Malam"),
         s = factor(s, levels = c("Pagi","Siang","Malam"))
         ) %>% 
  reshape2::dcast(h ~ s,
                  value.var = "perawat") %>% 
  rename(tanggal = h) %>% 
  knitr::kable(align = "c",caption = "Jadwal Perawat: Angka Pada Tanggal Menunjukkan id Perawat")
```



### Rekap Jadwal Optimal

Berikut adalah rekapan jadwal optimal per perawat:

```{r,echo=FALSE,warning=FALSE,message=FALSE}
result %>% 
  get_solution(x[n,h,s]) %>%
  filter(value == 1) %>% 
  group_by(n,s) %>% 
  count() %>% 
  ungroup() %>% 
  mutate(s = case_when(s == 1 ~ "Pagi",
                       s == 2 ~ "Siang",
                       s == 3 ~ "Malam"),
         s = factor(s, levels = c("Pagi","Siang","Malam"))
         ) %>% 
  rename(id_perawat = n,
         shift = s,
         berapa_x_bertugas = nn) %>% 
  reshape2::dcast(id_perawat ~ shift,
                  value.var = "berapa_x_bertugas") %>% 
  knitr::kable(align = "c",caption = "Rekapan Berapa Kali Perawat Bertugas")
  
```

Setelah kita lihat bersama, ternyata ada beberapa perawat yang **hanya** mendapatkan porsi kecil dalam jadwal tersebut. Lantas muncul pertanyaan:

> ***Apakah kita bisa meratakan workload antar perawat?***

## Masalah Baru

Sekarang kita akan paksakan setiap *nurse* mendapatkan *workload* yang sama.

Pertama-tama, mari kita hitung. Berapa banyak shift yang ideal per perawat.

$$\text{banyak shift ideal} = \frac{hari*shift*min(\text{perawat per shift})}{\text{total perawat}} $$

Yakni:

$$\text{banyak shift ideal} = \frac{14*3*4}{24} = \frac{168}{7} = 7$$

Jadi diharapkan setiap perawat mendapatkan banyak *shift* yang sama, yakni sebanyak `7` *shifts*.

Maka model matematika dari *constraint* ini adalah:

$$\sum_{h \in H} \sum_{s \in S} x_{h,n,s} = 7, \text{untuk } n \in N$$

## *Solver R*

### Penulisan Model Matematika di **R**

Berikut adalah penulisan model matematika di **R**:

```{r,message=FALSE,warning=FALSE}
# membuat model
model = 
  model %>% 
  # contraint baru
  add_constraint(sum_expr(x[n,h,s],
                          h = 1:14,
                          s = 1:3) == 7,
                 n = 1:24)
model
```

### *Solving*

Kemudian saya *solve* dengan **R**:

```{r,message=FALSE,warning=FALSE}
result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
```

### Solusi Optimal

#### Jadwal Optimal

Berikut adalah jadwal optimal dalam kasus ini:

```{r,echo=FALSE,message=FALSE,warning=FALSE}
result %>% 
  get_solution(x[n,h,s]) %>%
  filter(value == 1) %>% 
  group_by(h,s) %>% 
  summarise(perawat = paste(n,collapse = ",")) %>% 
  ungroup() %>% 
  mutate(s = case_when(s == 1 ~ "Pagi",
                       s == 2 ~ "Siang",
                       s == 3 ~ "Malam"),
         s = factor(s, levels = c("Pagi","Siang","Malam"))
         ) %>% 
  reshape2::dcast(h ~ s,
                  value.var = "perawat") %>% 
  rename(tanggal = h) %>% 
  knitr::kable(align = "c",caption = "Jadwal Perawat: Angka Pada Tanggal Menunjukkan id Perawat")
```



#### Rekap Jadwal Optimal

Berikut adalah rekapan jadwal optimal per perawat:

```{r,echo=FALSE,warning=FALSE,message=FALSE}
result %>% 
  get_solution(x[n,h,s]) %>%
  filter(value == 1) %>% 
  group_by(n,s) %>% 
  count() %>% 
  ungroup() %>% 
  mutate(s = case_when(s == 1 ~ "Pagi",
                       s == 2 ~ "Siang",
                       s == 3 ~ "Malam"),
         s = factor(s, levels = c("Pagi","Siang","Malam"))
         ) %>% 
  rename(id_perawat = n,
         shift = s,
         berapa_x_bertugas = nn) %>% 
  reshape2::dcast(id_perawat ~ shift,
                  value.var = "berapa_x_bertugas") %>% 
  knitr::kable(align = "c",caption = "Rekapan Berapa Kali Perawat Bertugas")
  
```



# *Non Linear Modelling*

## Masalah

Ada kalanya kita bertemu dengan masalah *optimization* yang tidak linear. Justru biasanya masalah *real world* tidak berbentuk linear. Sayangnya *solver* di **R** yang ada sekarang masih terbatas di *linear problem* saja.

> ***Bagaimana menyelesaikannya?***

Salah satu solusinya adalah dengan mengkonversi masalah **tidak linear** menjadi **linear**.

## Contoh Masalah *Optimization*

**Minimumkan:**

$$x_1^2 + x_1 x_2 + x_2^2 + x_1 +x_2$$

Terhadap:

$$4 x_1 + 6 x_2 \geq 10 \text{, dimana: }x_1,x_2 \in \{0,1\}$$

### *Solver* di **R**

Untuk mengecek apakah `ompr` bisa menyelesaikan masalah *non linear* di atas, maka saya akan tuliskan model matematikanya dalam **R**:

```{r,message=FALSE,warning=FALSE}
# dimulai dengan hati yang bersih
rm(list=ls())

# memanggil libraries
library(dplyr)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

# membuat model
# model = 
#   MIPModel() %>%
#   add_variable(x[i],
#                i = 1:2, 
#                type = "binary",
#                lb = 0) %>%
#   set_objective(x[1]^2 + x[1] * x[2] + x[2]^2 + x[1] + x[2],
#                 "min") %>%
#   add_constraint(4*x[1] + 6*x[2] >= 10)

# model
```

`ompr` tidak mampu menyelesaikan masalah *non linear* seperti di atas.

### Konversi ke Masalah Linear

#### Definisi Variabel $y$

Untuk mengubahnya ke dalam masalah linear, saya akan membuat pemisalan sebagai berikut:

$$y = x_1x_2$$

Karena $x_1$ dan $x_2$ adalah *binary*, maka:

$$x_1^2 = x_1$$

$$x_2^2 = x_2$$

$$y \leq x_1$$

$$y \leq x_2$$

$$y \geq x_1 + x_2 - 1$$

#### Perubahan Model *Optimization*

Dari persamaan-persamaan di atas, kita telah mendapatkan perubahan linear dari masalah awalnya.

Yakni:

**Minimumkan**:

$$y + 2x_1 + 2x_2$$

Terhadap:

$$4x_1 + 6x_2 \geq 10$$

$$-x_1 + y \leq 0$$

$$-x_2 + y \leq 0$$

$$x_1 + x_2 - y \leq 1$$

$$x_1,x_2,y \in \{0,1\}$$

#### Penulisan Model di **R**

Sekarang kita akan menuliskan model di atas ke dalam **R** sebagai berikut:

```{r}
# dimulai dengan hati yang bersih
rm(list=ls())

# memanggil libraries
library(dplyr)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

# membuat model
model = 
  MIPModel() %>%
  add_variable(x[i],
               i = 1:2, 
               type = "binary",
               lb = 0) %>%
  add_variable(y,
               type = "binary",
               lb = 0) %>% 
  set_objective(y + 2*x[1] + 2*x[2],
                "min") %>%
  add_constraint(4*x[1] + 6*x[2] >= 10) %>% 
  add_constraint(-x[1] + y <= 0) %>% 
  add_constraint(-x[2] + y <= 0) %>% 
  add_constraint(x[1] + x[1] - y <= 1)

model
```

#### *Solving*

Kemudian saya *solve* dengan **R**:

```{r,message=FALSE,warning=FALSE}
result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
```

#### Solusi Optimal

Berikut adalah solusi optimal yang didapatkan:

```{r}
result %>% get_solution(x[i])
```

# Regresi Linear Sebagai Masalah _Optimization_

Suatu permasalahan regresi linear bisa dipandang sebagai masalah _optimization_. _Kok bisa?_

Mari kita lihat contoh kasus berikut ini:

## Masalah

Suatu laboratorium hendak melakukan penelitian tentang mikroba dalam beberapa makanan basi. Mereka mengambil sampel mikroba dalam selang waktu tertentu dan mencatat berapa banyak mikroba yang ada di beberapa makanan tersebut.

Berikut adalah datanya:

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.align='center'}
rm(list=ls())
library(ggplot2)

data = data.frame(t = 1:10,
                  y = sample(50:100,10)
                  )

data$y = round((31:40)*data$y/100,
               1)
data %>% 
  ggplot(aes(x = t,
             y = y)) +
  geom_point() +
  geom_label(aes(label = paste0("(",t,", ",y,")")),
             size = 3) +
  labs(x = "Waktu",
       y = "Rata-rata Banyak Mikroba (dalam juta)",
       title = "Data Hasil Penelitian",
       subtitle = "Suatu laboratorium melakukan observasi terhadap suatu makanan.\nMereka meneliti seberapa banyak mikroba yang muncul saat makanan dibiarkan dalam\nsuatu tempat terbuka.")
```

> ___Bisakah kita membuat model prediksi berapa banyak mikroba dari waktu tertentu?___

## Permodelan Matematika

Misalkan persamaan regresi linear yang akan saya cari adalah sebagai berikut:

$$y = at + b$$

Dengan $y$ adalah banyaknya mikroba dan $t$ adalah waktu.

Jika kita perhatikan kembali, suatu persamaan regresi linear disebut __terbaik__ saat _error_ yang dihasilkan sangat kecil. Misal saya tulis $\hat{y_i}$ sebagai hasil prediksi model regresi pada waktu $i$.

Maka $error$ bisa saya tuliskan sebagai $e_i = \hat{y_i} - y_i$.

Kalau kita ingat, ada satu parameter _goodness of fit_ bernama __RMSE__ (_Root Mean Square Error_). Kelak __RMSE__ ini akan saya jadikan _objective function_ dari masalah _optimization_.

### _Objective Function_

$$\text{min}(e_1^2) = \\ \text{min}(\hat{y_i} - y_i)^2 = \\ \text{min} (at_i + b - y_i)^2$$

### _Decision Variables_

Variabel keputusan yang dicari adalah:

$$a,b \in \text{R}$$

### _Constraint_

_Constraints_ pada masalah ini hanyalah pada _boundaries_ $t$ dan $y$ yang ada pada data berikut ini:

```{r,echo=FALSE}
data %>% knitr::kable(caption = "Data",align = "c")
```

## _Solver_ __R__

Cara mengerjakan dengan _solver_ __R__ diberikan kepada pembaca sebagai bahan latihan.

## Metode Lain: Menggunakan _Linear Modelling_

Untuk menyelesaikan masalah regresi linear di __R__, kita bisa menggunakan _function_ `lm()`. Salah satu tutorial lengkap terkait regresi linear di __R__ bisa dilihat di [sini](https://ikanx101.com/blog/belajar-regresi/).

### Menyelesaikan `lm()` di __R__

```{r,warning=FALSE,message=FALSE}
regresi_model = lm(y ~ t, data)
summary(regresi_model)
```

Dari hasil di atas, kita dapatkan:

$y =$ `r regresi_model$coefficients[1]` $+$ `r regresi_model$coefficients[2]` $t$

Jika kita hitung __RMSE__, didapatkan nilai:

```{r,message=FALSE,warning=FALSE}
caret::RMSE(regresi_model$fitted.values,data$y)
```
