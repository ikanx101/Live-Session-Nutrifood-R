<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Raden Johannes, Andry Alamsyah" />
  <meta name="date" content="2022-11-07" />
  <meta name="copyright" content="LEFO Market Riset Nutrifood" />
  <title>Sales Prediction Model Using Classification Decision Tree Approach For Small Medium Enterprise Based on Indonesian E-Commerce Data</title>
  <style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>
  <script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
  <style type="text/css">
body
{
margin: 0 0 0 0;
padding: 0 0 0 0;
width: 100%;
height: 100%;
color: black;
background-color: white;
font-family: "Gill Sans MT", "Gill Sans", GillSans, sans-serif;
font-size: 14pt;
}
div.toolbar {
position: fixed; z-index: 200;
top: auto; bottom: 0; left: 0; right: 0;
height: 1.2em; text-align: right;
padding-left: 1em;
padding-right: 1em; font-size: 60%;
color: DimGray;
background-color: rgb(240,240,240);
border-top: solid 1px rgb(180,180,180);
}
div.toolbar span.copyright {
color: DimGray;
margin-left: 0.5em;
}
div.initial_prompt {
position: absolute;
z-index: 1000;
bottom: 1.2em;
width: 100%;
background-color: rgb(200,200,200);
opacity: 0.35;
background-color: rgb(200,200,200, 0.35);
cursor: pointer;
}
div.initial_prompt p.help {
text-align: center;
}
div.initial_prompt p.close {
text-align: right;
font-style: italic;
}
div.slidy_toc {
position: absolute;
z-index: 300;
width: 60%;
max-width: 30em;
height: 30em;
overflow: auto;
top: auto;
right: auto;
left: 4em;
bottom: 4em;
padding: 1em;
background: rgb(240,240,240);
border-style: solid;
border-width: 2px;
font-size: 60%;
}
div.slidy_toc .toc_heading {
text-align: center;
width: 100%;
margin: 0;
margin-bottom: 1em;
border-bottom-style: solid;
border-bottom-color: rgb(180,180,180);
border-bottom-width: 1px;
}
div.slide {
z-index: 20;
margin: 0 0 0 0;
padding-top: 0;
padding-bottom: 0;
padding-left: 20px;
padding-right: 20px;
border-width: 0;
clear: both;
top: 0;
bottom: 0;
left: 0;
right: 0;
line-height: 120%;
background-color: transparent;
}
div.background {
display: none;
}
div.handout {
margin-left: 20px;
margin-right: 20px;
}
div.slide.titlepage {
text-align: center;
}
div.slide.titlepage h1 {
padding-top: 10%;
margin-right: 0;
}
div.slide h1 {
padding-left: 0;
padding-right: 20pt;
padding-top: 4pt;
padding-bottom: 4pt;
margin-top: 0;
margin-left: 0;
margin-right: 60pt;
margin-bottom: 0.5em;
display: block; font-size: 160%;
line-height: 1.2em;
background: transparent;
}
@media screen and (max-device-width: 1024px)
{
div.slide { font-size: 100%; }
}
@media screen and (max-device-width: 800px)
{
div.slide { font-size: 200%; }
div.slidy_toc {
top: 1em;
left: 1em;
right: auto;
width: 80%;
font-size: 180%;
}
}
div.toc-heading {
width: 100%;
border-bottom: solid 1px rgb(180,180,180);
margin-bottom: 1em;
text-align: center;
}
img {
image-rendering: optimize-quality;
}
pre {
font-size: 80%;
font-weight: bold;
line-height: 120%;
padding-top: 0.2em;
padding-bottom: 0.2em;
padding-left: 1em;
padding-right: 1em;
border-style: solid;
border-left-width: 1em;
border-top-width: thin;
border-right-width: thin;
border-bottom-width: thin;
border-color: #95ABD0;
color: #00428C;
background-color: #E4E5E7;
}
li pre { margin-left: 0; }
blockquote { font-style: italic }
img { background-color: transparent }
p.copyright { font-size: smaller }
.center { text-align: center }
.footnote { font-size: smaller; margin-left: 2em; }
a img { border-width: 0; border-style: none }
a:visited { color: navy }
a:link { color: navy }
a:hover { color: red; text-decoration: underline }
a:active { color: red; text-decoration: underline }
a {text-decoration: none}
.toolbar a:link {color: blue}
.toolbar a:visited {color: blue}
.toolbar a:active {color: red}
.toolbar a:hover {color: red}
ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
li { margin-left: 0.5em; margin-top: 0.5em; }
li li { font-size: 85%; font-style: italic }
li li li { font-size: 85%; font-style: normal }
div dt
{
margin-left: 0;
margin-top: 1em;
margin-bottom: 0.5em;
font-weight: bold;
}
div dd
{
margin-left: 2em;
margin-bottom: 0.5em;
}
p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table {
margin-left: 1em;
margin-right: 1em;
}
p.subhead { font-weight: bold; margin-top: 2em; }
.smaller { font-size: smaller }
.bigger { font-size: 130% }
td,th { padding: 0.2em }
ul {
margin: 0.5em 1.5em 0.5em 1.5em;
padding: 0;
}
ol {
margin: 0.5em 1.5em 0.5em 1.5em;
padding: 0;
}
ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
ul li { list-style: square;
margin: 0.1em 0em 0.6em 0;
padding: 0 0 0 0;
line-height: 140%;
}
ol li { margin: 0.1em 0em 0.6em 1.5em;
padding: 0 0 0 0px;
line-height: 140%;
list-style-type: decimal;
}
li ul li { font-size: 85%; font-style: italic;
list-style-type: disc;
background: transparent;
padding: 0 0 0 0;
}
li li ul li { font-size: 85%; font-style: normal;
list-style-type: circle;
background: transparent;
padding: 0 0 0 0;
}
li li li ul li {
list-style-type: disc;
background: transparent;
padding: 0 0 0 0;
}
li ol li {
list-style-type: decimal;
}
li li ol li {
list-style-type: decimal;
}

ol.outline li:hover { cursor: pointer }
ol.outline li.nofold:hover { cursor: default }
ul.outline li:hover { cursor: pointer }
ul.outline li.nofold:hover { cursor: default }
ol.outline { list-style:decimal; }
ol.outline ol { list-style-type:lower-alpha }
ol.outline li.nofold {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAIACAMzMzOvr/ywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7) no-repeat 0px 0.5em;
}
ol.outline li.unfolded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs=) no-repeat 0px 0.5em;
}
ol.outline li.folded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ol.outline li.unfolded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs=) no-repeat 0px 0.5em;
}
ol.outline li.folded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ul.outline li.nofold {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAIACAMzMzOvr/ywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7) no-repeat 0px 0.5em;
}
ul.outline li.unfolded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs=) no-repeat 0px 0.5em;
}
ul.outline li.folded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ul.outline li.unfolded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs=) no-repeat 0px 0.5em;
}
ul.outline li.folded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs=) no-repeat 0px 0.5em;
}

a.titleslide { font-weight: bold; font-style: italic }

img.hidden { display: none; visibility: hidden }
div.initial_prompt { display: none; visibility: hidden }
div.slide {
visibility: visible;
position: inherit;
}
div.handout {
border-top-style: solid;
border-top-width: thin;
border-top-color: black;
}
@media screen {
.hidden { display: none; visibility: visible }
div.slide.hidden { display: block; visibility: visible }
div.handout.hidden { display: block; visibility: visible }
div.background { display: none; visibility: hidden }
body.single_slide div.initial_prompt { display: block; visibility: visible }
body.single_slide div.background { display: block; visibility: visible }
body.single_slide div.background.hidden { display: none; visibility: hidden }
body.single_slide .invisible { visibility: hidden }
body.single_slide .hidden { display: none; visibility: hidden }
body.single_slide div.slide { position: absolute }
body.single_slide div.handout { display: none; visibility: hidden }
}
@media print {
.hidden { display: block; visibility: visible }
div.slide pre { font-size: 60%; padding-left: 0.5em; }
div.toolbar { display: none; visibility: hidden; }
div.slidy_toc { display: none; visibility: hidden; }
div.background { display: none; visibility: hidden; }
div.slide { page-break-before: always }

div.slide.first-slide { page-break-before: avoid }
}


.jslider table {
margin-left: 0em;
margin-right: 0em;
}

table.dataTable, .shiny-datatable-output div {
font-size: 14pt;
}

.dataTables_info, .dataTables_paginate {
font-size: 19px;
}

pre.sourceCode, code.sourceCode {
font-size: 80%;
}

label, button, input, select, textarea {
font-size: 14pt;
}

ul.nav, ul.nav li {
list-style-type: none;
}
</style>
  <script src="data:application/javascript;base64,Lyogc2xpZHkuanMKCiAgIENvcHlyaWdodCAoYykgMjAwNS0yMDEzIFczQyAoTUlULCBFUkNJTSwgS2VpbyksIEFsbCBSaWdodHMgUmVzZXJ2ZWQuCiAgIFczQyBsaWFiaWxpdHksIHRyYWRlbWFyaywgZG9jdW1lbnQgdXNlIGFuZCBzb2Z0d2FyZSBsaWNlbnNpbmcKICAgcnVsZXMgYXBwbHksIHNlZToKCiAgIGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvY29weXJpZ2h0LWRvY3VtZW50cwogICBodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsL2NvcHlyaWdodC1zb2Z0d2FyZQoKICAgRGVmaW5lcyBzaW5nbGUgbmFtZSAidzNjX3NsaWR5IiBpbiBnbG9iYWwgbmFtZXNwYWNlCiAgIEFkZHMgZXZlbnQgaGFuZGxlcnMgd2l0aG91dCB0cmFtcGxpbmcgb24gYW55IG90aGVycwoqLwoKLy8gdGhlIHNsaWR5IG9iamVjdCBpbXBsZW1lbnRhdGlvbgp2YXIgdzNjX3NsaWR5ID0gewogIC8vIGNsYXNzaWZ5IHdoaWNoIGtpbmQgb2YgYnJvd3NlciB3ZSdyZSBydW5uaW5nIHVuZGVyCiAgbnNfcG9zOiAodHlwZW9mIHdpbmRvdy5wYWdlWU9mZnNldCE9J3VuZGVmaW5lZCcpLAogIGtodG1sOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoIktIVE1MIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgb3BlcmE6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiT3BlcmEiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGFkOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoImlQYWQiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGhvbmU6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiaVBob25lIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgYW5kcm9pZDogKChuYXZpZ2F0b3IudXNlckFnZW50KS5pbmRleE9mKCJBbmRyb2lkIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgaWU6ICh0eXBlb2YgZG9jdW1lbnQuYWxsICE9ICJ1bmRlZmluZWQiICYmICF0aGlzLm9wZXJhKSwKICBpZTY6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDYiKSAhPSAtMSksCiAgaWU3OiAoIXRoaXMubnNfcG9zICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSA3IikgIT0gLTEpLAogIGllODogKCF0aGlzLm5zX3BvcyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUgOCIpICE9IC0xKSwKICBpZTk6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDkiKSAhPSAtMSksCgogIC8vIGRhdGEgZm9yIHN3aXBlIGFuZCBkb3VibGUgdGFwIGRldGVjdGlvbiBvbiB0b3VjaCBzY3JlZW5zCiAgbGFzdF90YXA6IDAsCiAgcHJldl90YXA6IDAsCiAgc3RhcnRfeDogMCwKICBzdGFydF95OiAwLAogIGRlbHRhX3g6IDAsCiAgZGVsdGFfeTogMCwKCiAgLy8gYXJlIHdlIHJ1bm5pbmcgYXMgWEhUTUw/IChkb2Vzbid0IHdvcmsgb24gT3BlcmEpCiAgaXNfeGh0bWw6IC94bWwvLnRlc3QoZG9jdW1lbnQuY29udGVudFR5cGUpLAoKICBzbGlkZV9udW1iZXI6IDAsIC8vIGludGVnZXIgc2xpZGUgY291bnQ6IDAsIDEsIDIsIC4uLgogIHNsaWRlX251bWJlcl9lbGVtZW50OiBudWxsLCAvLyBlbGVtZW50IGNvbnRhaW5pbmcgc2xpZGUgbnVtYmVyCiAgc2xpZGVzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIHNsaWRlIGRpdidzCiAgbm90ZXM6IFtdLCAvLyBzZXQgdG8gYXJyYXkgb2YgaGFuZG91dCBkaXYncwogIGJhY2tncm91bmRzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIGJhY2tncm91bmQgZGl2J3MKICBvYnNlcnZlcnM6IFtdLCAvLyBsaXN0IG9mIG9ic2VydmVyIGZ1bmN0aW9ucwogIHRvb2xiYXI6IG51bGwsIC8vIGVsZW1lbnQgY29udGFpbmluZyB0b29sYmFyCiAgdGl0bGU6IG51bGwsIC8vIGRvY3VtZW50IHRpdGxlCiAgbGFzdF9zaG93bjogbnVsbCwgLy8gbGFzdCBpbmNyZW1lbnRhbGx5IHNob3duIGl0ZW0KICBlb3M6IG51bGwsICAvLyBzcGFuIGVsZW1lbnQgZm9yIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKICB0b2M6IG51bGwsIC8vIHRhYmxlIG9mIGNvbnRlbnRzCiAgb3V0bGluZTogbnVsbCwgLy8gb3V0bGluZSBlbGVtZW50IHdpdGggdGhlIGZvY3VzCiAgc2VsZWN0ZWRfdGV4dF9sZW46IDAsIC8vIGxlbmd0aCBvZiBkcmFnIHNlbGVjdGlvbiBvbiBkb2N1bWVudAogIHZpZXdfYWxsOiAwLCAgLy8gMSB0byB2aWV3IGFsbCBzbGlkZXMgKyBoYW5kb3V0cwogIHdhbnRfdG9vbGJhcjogdHJ1ZSwgIC8vIHVzZXIgcHJlZmVyZW5jZSB0byBzaG93L2hpZGUgdG9vbGJhcgogIG1vdXNlX2NsaWNrX2VuYWJsZWQ6IHRydWUsIC8vIGVuYWJsZXMgbGVmdCBjbGljayBmb3IgbmV4dCBzbGlkZQogIHNjcm9sbF9oYWNrOiAwLCAvLyBJRSB3b3JrIGFyb3VuZCBmb3IgcG9zaXRpb246IGZpeGVkCiAgZGlzYWJsZV9zbGlkZV9jbGljazogZmFsc2UsICAvLyB1c2VkIGJ5IGNsaWNrZWQgYW5jaG9ycwoKICBsYW5nOiAiZW4iLCAvLyB1cGRhdGVkIHRvIGxhbmd1YWdlIHNwZWNpZmllZCBieSBodG1sIGZpbGUKCiAgaGVscF9hbmNob3I6IG51bGwsIC8vIHVzZWQgZm9yIGtleWJvYXJkIGZvY3VzIGhhY2sgaW4gc2hvd1Rvb2xiYXIoKQogIGhlbHBfcGFnZTogImh0dHA6Ly93d3cudzMub3JnL1RhbGtzL1Rvb2xzL1NsaWR5Mi9oZWxwL2hlbHAuaHRtbCIsCiAgaGVscF90ZXh0OiAiTmF2aWdhdGUgd2l0aCBtb3VzZSBjbGljaywgc3BhY2UgYmFyLCBDdXJzb3IgTGVmdC9SaWdodCwgIiArCiAgICAgICAgICAgICAib3IgUGcgVXAgYW5kIFBnIERuLiBVc2UgUyBhbmQgQiB0byBjaGFuZ2UgZm9udCBzaXplLiIsCgogIHNpemVfaW5kZXg6IDAsCiAgc2l6ZV9hZGp1c3RtZW50OiAwLAogIHNpemVzOiAgbmV3IEFycmF5KCIxMHB0IiwgIjEycHQiLCAiMTRwdCIsICIxNnB0IiwgIjE4cHQiLCAiMjBwdCIsCiAgICAgICAgICAgICAgICAgICAgIjIycHQiLCAiMjRwdCIsICIyNnB0IiwgIjI4cHQiLCAiMzBwdCIsICIzMnB0IiksCgogIC8vIG5lZWRlZCBmb3IgZWZmaWNpZW50IHJlc2l6aW5nCiAgbGFzdF93aWR0aDogMCwKICBsYXN0X2hlaWdodDogMCwKCgogIC8vIE5lZWRlZCBmb3IgY3Jvc3MgYnJvd3NlciBzdXBwb3J0IGZvciByZWxhdGl2ZSB3aWR0aC9oZWlnaHQgb24KICAvLyBvYmplY3QgZWxlbWVudHMuIFRoZSB3b3JrIGFyb3VuZCBpcyB0byBzYXZlIHdpZHRoL2hlaWdodCBhdHRyaWJ1dGVzCiAgLy8gYW5kIHRoZW4gdG8gcmVjb21wdXRlIGFic29sdXRlIHdpZHRoL2hlaWdodCBkaW1lbnNpb25zIG9uIHJlc2l6aW5nCiAgIG9iamVjdHM6IFtdLAoKICAvLyBhdHRhY2ggaW5pdGlhbGlhdGlvbiBldmVudCBoYW5kbGVycwogIHNldF91cDogZnVuY3Rpb24gKCkgewogICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHsgdzNjX3NsaWR5LmluaXQoKTsgfTsKICAgIGlmICh0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT0gInVuZGVmaW5lZCIpCiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCJsb2FkIiwgaW5pdCwgZmFsc2UpOwogICAgZWxzZQogICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoIm9ubG9hZCIsIGluaXQpOwogIH0sCgogIGhpZGVfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiAhdzNjX3NsaWR5LmluaXRpYWxpemVkKQogICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnZpc2liaWxpdHkgPSAiaGlkZGVuIjsKICAgIGVsc2UKICAgICAgc2V0VGltZW91dCh3M2Nfc2xpZHkuaGlkZV9zbGlkZXMsIDUwKTsKICB9LAoKICAvLyBoYWNrIHRvIHBlcnN1YWRlIElFIHRvIGNvbXB1dGUgY29ycmVjdCBkb2N1bWVudCBoZWlnaHQKICAvLyBhcyBuZWVkZWQgZm9yIHNpbXVsYXRpbmcgZml4ZWQgcG9zaXRpb25pbmcgb2YgdG9vbGJhcgogIGllX2hhY2s6IGZ1bmN0aW9uICgpIHsKICAgIHdpbmRvdy5yZXNpemVCeSgwLC0xKTsKICAgIHdpbmRvdy5yZXNpemVCeSgwLCAxKTsKICB9LAoKICBpbml0OiBmdW5jdGlvbiAoKSB7CiAgICAvL2FsZXJ0KCJzbGlkeSBzdGFydGluZyB0ZXN0IDEwIik7CiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnZpc2liaWxpdHkgPSAidmlzaWJsZSI7CiAgICB0aGlzLmluaXRfbG9jYWxpemF0aW9uKCk7CiAgICB0aGlzLmFkZF90b29sYmFyKCk7CiAgICB0aGlzLndyYXBfaW1wbGljaXRfc2xpZGVzKCk7CiAgICB0aGlzLmNvbGxlY3Rfc2xpZGVzKCk7CiAgICB0aGlzLmNvbGxlY3Rfbm90ZXMoKTsKICAgIHRoaXMuY29sbGVjdF9iYWNrZ3JvdW5kcygpOwogICAgdGhpcy5vYmplY3RzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgib2JqZWN0Iik7CiAgICB0aGlzLnBhdGNoX2FuY2hvcnMoKTsKICAgIHRoaXMuc2xpZGVfbnVtYmVyID0gdGhpcy5maW5kX3NsaWRlX251bWJlcihsb2NhdGlvbi5ocmVmKTsKICAgIHdpbmRvdy5vZmZzY3JlZW5idWZmZXJpbmcgPSB0cnVlOwogICAgdGhpcy5zaXplX2FkanVzdG1lbnQgPSB0aGlzLmZpbmRfc2l6ZV9hZGp1c3QoKTsKICAgIHRoaXMudGltZV9sZWZ0ID0gdGhpcy5maW5kX2R1cmF0aW9uKCk7CiAgICB0aGlzLmhpZGVfaW1hZ2VfdG9vbGJhcigpOyAgLy8gc3VwcHJlc3MgSUUgaW1hZ2UgdG9vbGJhciBwb3B1cAogICAgdGhpcy5pbml0X291dGxpbmVyKCk7ICAvLyBhY3RpdmF0ZSBmb2xkL3VuZm9sZCBzdXBwb3J0CiAgICB0aGlzLnRpdGxlID0gZG9jdW1lbnQudGl0bGU7CiAgICB0aGlzLmtleWJvYXJkbGVzcyA9ICh0aGlzLmlwYWR8fHRoaXMuaXBob25lfHx0aGlzLmFuZHJvaWQpOwoKICAgIGlmICh0aGlzLmtleWJvYXJkbGVzcykKICAgIHsKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgIHRoaXMud2FudF90b29sYmFyID0gMDsKICAgIH0KCiAgICAvLyB3b3JrIGFyb3VuZCBmb3Igb3BlcmEgYnVnCiAgICB0aGlzLmlzX3hodG1sID0gKGRvY3VtZW50LmJvZHkudGFnTmFtZSA9PSAiQk9EWSIgPyBmYWxzZSA6IHRydWUpOwoKICAgIGlmICh0aGlzLnNsaWRlcy5sZW5ndGggPiAwKQogICAgewogICAgICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1t0aGlzLnNsaWRlX251bWJlcl07CiAgIAogICAgICBpZiAodGhpcy5zbGlkZV9udW1iZXIgPiAwKQogICAgICB7CiAgICAgICAgdGhpcy5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICAgICAgICB0aGlzLmxhc3Rfc2hvd24gPSB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obnVsbCk7CiAgICAgICAgdGhpcy5zZXRfZW9zX3N0YXR1cyh0cnVlKTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB0aGlzLmxhc3Rfc2hvd24gPSBudWxsOwogICAgICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJoaWRkZW4iKTsKICAgICAgICB0aGlzLnNldF9lb3Nfc3RhdHVzKCF0aGlzLm5leHRfaW5jcmVtZW50YWxfaXRlbSh0aGlzLmxhc3Rfc2hvd24pKTsKICAgICAgfQoKICAgICAgdGhpcy5zZXRfbG9jYXRpb24oKTsKICAgICAgdGhpcy5hZGRfY2xhc3ModGhpcy5zbGlkZXNbMF0sICJmaXJzdC1zbGlkZSIpOwogICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZShzbGlkZSk7CiAgICB9CgogICAgdGhpcy50b2MgPSB0aGlzLnRhYmxlX29mX2NvbnRlbnRzKCk7CgogICAgdGhpcy5hZGRfaW5pdGlhbF9wcm9tcHQoKTsKCiAgICAvLyBiaW5kIGV2ZW50IGhhbmRsZXJzIHdpdGhvdXQgaW50ZXJmZXJpbmcgd2l0aCBjdXN0b20gcGFnZSBzY3JpcHRzCiAgICAvLyBUYXAgZXZlbnRzIGJlaGF2ZSB0b28gd2VpcmRseSB0byBzdXBwb3J0IGNsaWNrcyByZWxpYWJseSBvbgogICAgLy8gaVBob25lIGFuZCBpUGFkLCBzbyBleGNsdWRlIHRoZXNlIGZyb20gY2xpY2sgaGFuZGxlcgoKICAgIGlmICghdGhpcy5rZXlib2FyZGxlc3MpCiAgICB7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LmJvZHksICJjbGljayIsIHRoaXMubW91c2VfYnV0dG9uX2NsaWNrKTsKICAgICAgdGhpcy5hZGRfbGlzdGVuZXIoZG9jdW1lbnQuYm9keSwgIm1vdXNlZG93biIsIHRoaXMubW91c2VfYnV0dG9uX2Rvd24pOwogICAgfQoKICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LCAia2V5ZG93biIsIHRoaXMua2V5X2Rvd24pOwogICAgdGhpcy5hZGRfbGlzdGVuZXIoZG9jdW1lbnQsICJrZXlwcmVzcyIsIHRoaXMua2V5X3ByZXNzKTsKICAgIHRoaXMuYWRkX2xpc3RlbmVyKHdpbmRvdywgInJlc2l6ZSIsIHRoaXMucmVzaXplZCk7CiAgICB0aGlzLmFkZF9saXN0ZW5lcih3aW5kb3csICJzY3JvbGwiLCB0aGlzLnNjcm9sbGVkKTsKICAgIHRoaXMuYWRkX2xpc3RlbmVyKHdpbmRvdywgInVubG9hZCIsIHRoaXMudW5sb2FkZWQpOwoKICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LCAiZ2VzdHVyZWNoYW5nZSIsIGZ1bmN0aW9uICgpCiAgICB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0pOwoKICAgIHRoaXMuYXR0YWNoX3RvdWNoX2hhbmRlcnModGhpcy5zbGlkZXMpOwoKICAgIC8vIHRoaXMgc2VlbXMgdG8gYmUgYSBkZWJ1Z2dpbmcgaGFjawogICAgLy9pZiAoIWRvY3VtZW50LmJvZHkub25jbGljaykKICAgIC8vICBkb2N1bWVudC5ib2R5Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7IH07CgogICAgdGhpcy5zaW5nbGVfc2xpZGVfdmlldygpOwoKICAgIC8vdGhpcy5zZXRfbG9jYXRpb24oKTsKCiAgICB0aGlzLnJlc2l6ZWQoKTsKCiAgICBpZiAodGhpcy5pZTcpCiAgICAgIHNldFRpbWVvdXQodzNjX3NsaWR5LmllX2hhY2ssIDEwMCk7CgogICAgdGhpcy5zaG93X3Rvb2xiYXIoKTsKCiAgICAvLyBmb3IgYmFjayBidXR0b24gZGV0ZWN0aW9uCiAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHczY19zbGlkeS5jaGVja19sb2NhdGlvbigpOyB9LCAyMDApOwogICAgdzNjX3NsaWR5LmluaXRpYWxpemVkID0gdHJ1ZTsKICB9LAoKICAvLyBjcmVhdGUgZGl2IGVsZW1lbnQgd2l0aCBsaW5rcyB0byBlYWNoIHNsaWRlCiAgdGFibGVfb2ZfY29udGVudHM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciB0b2MgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKTsKICAgIHRoaXMuYWRkX2NsYXNzKHRvYywgInNsaWR5X3RvYyBoaWRkZW4iKTsKICAgIC8vdG9jLnNldEF0dHJpYnV0ZSgidGFiaW5kZXgiLCAiMCIpOwoKICAgIHZhciBoZWFkaW5nID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICB0aGlzLmFkZF9jbGFzcyhoZWFkaW5nLCAidG9jLWhlYWRpbmciKTsKICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgiVGFibGUgb2YgQ29udGVudHMiKTsKCiAgICB0b2MuYXBwZW5kQ2hpbGQoaGVhZGluZyk7CiAgICB2YXIgcHJldmlvdXMgPSBudWxsOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIHZhciB0aXRsZSA9IHRoaXMuaGFzX2NsYXNzKHRoaXMuc2xpZGVzW2ldLCAidGl0bGUiKTsKICAgICAgdmFyIG51bSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKChpICsgMSkgKyAiLiAiKTsKCiAgICAgIHRvYy5hcHBlbmRDaGlsZChudW0pOwoKICAgICAgdmFyIGEgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJhIik7CiAgICAgIGEuc2V0QXR0cmlidXRlKCJocmVmIiwgIiMoIiArIChpKzEpICsgIikiKTsKCiAgICAgIGlmICh0aXRsZSkKICAgICAgICB0aGlzLmFkZF9jbGFzcyhhLCAidGl0bGVzbGlkZSIpOwoKICAgICAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnNsaWRlX25hbWUoaSkpOwogICAgICBhLmFwcGVuZENoaWxkKG5hbWUpOwogICAgICBhLm9uY2xpY2sgPSB3M2Nfc2xpZHkudG9jX2NsaWNrOwogICAgICBhLm9ua2V5ZG93biA9IHczY19zbGlkeS50b2Nfa2V5X2Rvd247CiAgICAgIGEucHJldmlvdXMgPSBwcmV2aW91czsKCiAgICAgIGlmIChwcmV2aW91cykKICAgICAgICBwcmV2aW91cy5uZXh0ID0gYTsKCiAgICAgIHRvYy5hcHBlbmRDaGlsZChhKTsKCiAgICAgIGlmIChpID09IDApCiAgICAgICAgdG9jLmZpcnN0ID0gYTsKCiAgICAgIGlmIChpIDwgdGhpcy5zbGlkZXMubGVuZ3RoIC0gMSkKICAgICAgewogICAgICAgIHZhciBiciA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImJyIik7CiAgICAgICAgdG9jLmFwcGVuZENoaWxkKGJyKTsKICAgICAgfQoKICAgICAgcHJldmlvdXMgPSBhOwogICAgfQoKICAgIHRvYy5mb2N1cyA9IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuZmlyc3QpCiAgICAgICAgdGhpcy5maXJzdC5mb2N1cygpOwogICAgfQoKICAgIHRvYy5vbm1vdXNldXAgPSB3M2Nfc2xpZHkubW91c2VfYnV0dG9uX3VwOwoKICAgIHRvYy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHsKICAgICAgZXx8KGU9d2luZG93LmV2ZW50KTsKCiAgICAgIGlmICh3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPD0gMCkKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CgogICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgIAogICAgICBpZiAoZS5jYW5jZWwgIT0gdW5kZWZpbmVkKQogICAgICAgIGUuY2FuY2VsID0gdHJ1ZTsKICAgICAgCiAgICAgIGlmIChlLnJldHVyblZhbHVlICE9IHVuZGVmaW5lZCkKICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICAgIAogICAgICByZXR1cm4gZmFsc2U7CiAgICB9OwoKICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHRvYywgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTsKICAgIHJldHVybiB0b2M7CiAgfSwKCiAgaXNfc2hvd25fdG9jOiBmdW5jdGlvbiAoKSB7CiAgICByZXR1cm4gIXczY19zbGlkeS5oYXNfY2xhc3ModzNjX3NsaWR5LnRvYywgImhpZGRlbiIpOwogIH0sCgogIHNob3dfdGFibGVfb2ZfY29udGVudHM6IGZ1bmN0aW9uICgpIHsKICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3ModzNjX3NsaWR5LnRvYywgImhpZGRlbiIpOwogICAgdmFyIHRvYyA9IHczY19zbGlkeS50b2M7CiAgICB0b2MuZm9jdXMoKTsKCiAgICBpZiAodzNjX3NsaWR5LmllNyAmJiB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID09IDApCiAgICAgIHNldFRpbWVvdXQodzNjX3NsaWR5LmllX2hhY2ssIDEwMCk7CiAgfSwKCiAgaGlkZV90YWJsZV9vZl9jb250ZW50czogZnVuY3Rpb24gKGZvY3VzKSB7CiAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKTsKCiAgICBpZiAoZm9jdXMgJiYgIXczY19zbGlkeS5vcGVyYSAmJgogICAgICAgICF3M2Nfc2xpZHkuaGFzX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKSkKICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogIH0sCgogIHRvZ2dsZV90YWJsZV9vZl9jb250ZW50czogZnVuY3Rpb24gKCkgewogICAgaWYgKHczY19zbGlkeS5pc19zaG93bl90b2MoKSkKICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CiAgICBlbHNlCiAgICAgIHczY19zbGlkeS5zaG93X3RhYmxlX29mX2NvbnRlbnRzKCk7CiAgfSwKCiAgLy8gY2FsbGVkIG9uIGNsaWNraW5nIHRvYyBlbnRyeQogIHRvY19jbGljazogZnVuY3Rpb24gKGUpIHsKICAgIGlmICghZSkKICAgICAgZSA9IHdpbmRvdy5ldmVudDsKCiAgICB2YXIgdGFyZ2V0ID0gdzNjX3NsaWR5LmdldF90YXJnZXQoZSk7CgogICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMSkKICAgIHsKICAgICAgdmFyIHVyaSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoImhyZWYiKTsKCiAgICAgIGlmICh1cmkpCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJnb2luZyB0byAiICsgdXJpKTsKICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LmZpbmRfc2xpZGVfbnVtYmVyKHVyaSk7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgIC8vdGFyZ2V0LmZvY3VzKCk7CgogICAgICAgIHRyeQogICAgICAgIHsKICAgICAgICAgIGlmICghdzNjX3NsaWR5Lm9wZXJhKQogICAgICAgICAgICB3M2Nfc2xpZHkuc2V0X2ZvY3VzKCk7CiAgICAgICAgfQogICAgICAgIGNhdGNoIChlKQogICAgICAgIHsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICB3M2Nfc2xpZHkuaGlkZV90YWJsZV9vZl9jb250ZW50cyh0cnVlKTsKICAgIGlmICh3M2Nfc2xpZHkuaWU3KSB3M2Nfc2xpZHkuaWVfaGFjaygpOwogICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChlKTsKICB9LAoKICAvLyBjYWxsZWQgb25rZXlkb3duIGZvciB0b2MgZW50cnkKICB0b2Nfa2V5X2Rvd246IGZ1bmN0aW9uIChldmVudCkgewogICAgdmFyIGtleTsKCiAgICBpZiAoIWV2ZW50KQogICAgICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh3aW5kb3cuZXZlbnQpCiAgICAgIGtleSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlOwogICAgZWxzZSBpZiAoZXZlbnQud2hpY2gpCiAgICAgIGtleSA9IGV2ZW50LndoaWNoOwogICAgZWxzZQogICAgICByZXR1cm4gdHJ1ZTsgLy8gWWlrZXMhIHVua25vd24gYnJvd3NlcgoKICAgIC8vIGlnbm9yZSBldmVudCBpZiBrZXkgdmFsdWUgaXMgemVybwogICAgLy8gYXMgZm9yIGFsdCBvbiBPcGVyYSBhbmQgS29ucXVlcm9yCiAgICBpZiAoIWtleSkKICAgICAgcmV0dXJuIHRydWU7CgogICAgLy8gY2hlY2sgZm9yIGNvbmN1cnJlbnQgY29udHJvbC9jb21tYW5kL2FsdCBrZXkKICAgIC8vIGJ1dCBhcmUgdGhlc2Ugb25seSBwcmVzZW50IG9uIG1vdXNlIGV2ZW50cz8KCiAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmIChrZXkgPT0gMTMpCiAgICB7CiAgICAgIHZhciB1cmkgPSB0aGlzLmdldEF0dHJpYnV0ZSgiaHJlZiIpOwoKICAgICAgaWYgKHVyaSkKICAgICAgewogICAgICAgIC8vYWxlcnQoImdvaW5nIHRvICIgKyB1cmkpOwogICAgICAgdmFyIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5maW5kX3NsaWRlX251bWJlcih1cmkpOwogICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IG51bGw7CiAgICAgICAgdzNjX3NsaWR5LnNldF9sb2NhdGlvbigpOwogICAgICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoImhpZGRlbiIpOwogICAgICAgIHczY19zbGlkeS5zZXRfZW9zX3N0YXR1cyghdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbSh3M2Nfc2xpZHkubGFzdF9zaG93bikpOwogICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgICAvL3RhcmdldC5mb2N1cygpOwoKICAgICAgICB0cnkKICAgICAgICB7CiAgICAgICAgICBpZiAoIXczY19zbGlkeS5vcGVyYSkKICAgICAgICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogICAgICAgIH0KICAgICAgICBjYXRjaCAoZSkKICAgICAgICB7CiAgICAgICAgfQogICAgICB9CgogICAgICB3M2Nfc2xpZHkuaGlkZV90YWJsZV9vZl9jb250ZW50cyh0cnVlKTsKCiAgICAgIGlmIChzZWxmLmllNykKICAgICAgIHczY19zbGlkeS5pZV9oYWNrKCk7CgogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CgogICAgaWYgKGtleSA9PSA0MCAmJiB0aGlzLm5leHQpCiAgICB7CiAgICAgIHRoaXMubmV4dC5mb2N1cygpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CgogICAgaWYgKGtleSA9PSAzOCAmJiB0aGlzLnByZXZpb3VzKQogICAgewogICAgICB0aGlzLnByZXZpb3VzLmZvY3VzKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZSkKICB7CiAgICAvLyBhIGRvdWJsZSB0b3VjaCBvZnRlbiBzdGFydHMgd2l0aCBhCiAgICAvLyBzaW5nbGUgdG91Y2ggZHVlIHRvIGZpbmdlcnMgdG91Y2hpbmcKICAgIC8vIGRvd24gYXQgc2xpZ2h0bHkgZGlmZmVyZW50IHRpbWVzCiAgICAvLyB0aHVzIGF2b2lkIGNhbGxpbmcgcHJldmVudERlZmF1bHQgaGVyZQogICAgdGhpcy5wcmV2X3RhcCA9IHRoaXMubGFzdF90YXA7CiAgICB0aGlzLmxhc3RfdGFwID0gKG5ldyBEYXRlKS5nZXRUaW1lKCk7CgogICAgdmFyIHRhcF9kZWxheSA9IHRoaXMubGFzdF90YXAgLSB0aGlzLnByZXZfdGFwOwoKICAgIGlmICh0YXBfZGVsYXkgPD0gMjAwKQogICAgewogICAgICAvLyBkb3VibGUgdGFwCiAgICB9CgogICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdOwoKICAgIHRoaXMucGFnZVggPSB0b3VjaC5wYWdlWDsKICAgIHRoaXMucGFnZVkgPSB0b3VjaC5wYWdlWTsKICAgIHRoaXMuc2NyZWVuWCA9IHRvdWNoLnNjcmVlblg7CiAgICB0aGlzLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZOwogICAgdGhpcy5jbGllbnRYID0gdG91Y2guY2xpZW50WDsKICAgIHRoaXMuY2xpZW50WSA9IHRvdWNoLmNsaWVudFk7CgogICAgdGhpcy5kZWx0YV94ID0gdGhpcy5kZWx0YV95ID0gMDsKICB9LAoKICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChlKQogIHsKICAgIC8vIG92ZXJyaWRlIG5hdGl2ZSBnZXN0dXJlcyBmb3Igc2luZ2xlIHRvdWNoCiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpCiAgICAgIHJldHVybjsKCiAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07CiAgICB0aGlzLmRlbHRhX3ggPSB0b3VjaC5wYWdlWCAtIHRoaXMucGFnZVg7CiAgICB0aGlzLmRlbHRhX3kgPSB0b3VjaC5wYWdlWSAtIHRoaXMucGFnZVk7CiAgfSwKCiAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChlKQogIHsKICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgZm9yIG11bHRpLXRvdWNoCiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpCiAgICAgIHJldHVybjsKCiAgICB2YXIgZGVsYXkgPSAobmV3IERhdGUpLmdldFRpbWUoKSAtIHRoaXMubGFzdF90YXA7CiAgICB2YXIgZHggPSB0aGlzLmRlbHRhX3g7CiAgICB2YXIgZHkgPSB0aGlzLmRlbHRhX3k7CiAgICB2YXIgYWJzX2R4ID0gTWF0aC5hYnMoZHgpOwogICAgdmFyIGFic19keSA9IE1hdGguYWJzKGR5KTsKCiAgICBpZiAoZGVsYXkgPCA1MDAgJiYgKGFic19keCA+IDEwMCB8fCBhYnNfZHkgPiAxMDApKQogICAgewogICAgICBpZiAoYWJzX2R4ID4gMC41ICogYWJzX2R5KQogICAgICB7CiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwoKICAgICAgICBpZiAoZHggPCAwKQogICAgICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUodHJ1ZSk7CiAgICAgICAgZWxzZQogICAgICAgICAgdzNjX3NsaWR5LnByZXZpb3VzX3NsaWRlKHRydWUpOwogICAgICB9CiAgICAgIGVsc2UgaWYgKGFic19keSA+IDIgKiBhYnNfZHgpCiAgICAgIHsKICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgdzNjX3NsaWR5LnRvZ2dsZV90YWJsZV9vZl9jb250ZW50cygpOwogICAgICB9CiAgICB9CiAgfSwKCiAgLy8gIyMjIE9CU09MRVRFICMjIwogIGJlZm9yZV9wcmludDogZnVuY3Rpb24gKCkgewogICAgdGhpcy5zaG93X2FsbF9zbGlkZXMoKTsKICAgIHRoaXMuaGlkZV90b29sYmFyKCk7CiAgICBhbGVydCgiYmVmb3JlIHByaW50Iik7CiAgfSwKCiAgLy8gIyMjIE9CU09MRVRFICMjIwogIGFmdGVyX3ByaW50OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAoIXRoaXMudmlld19hbGwpCiAgICB7CiAgICAgIHRoaXMuc2luZ2xlX3NsaWRlX3ZpZXcoKTsKICAgICAgdGhpcy5zaG93X3Rvb2xiYXIoKTsKICAgIH0KICAgIGFsZXJ0KCJhZnRlciBwcmludCIpOwogIH0sCgogIC8vICMjIyBPQlNPTEVURSAjIyMKICBwcmludF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuYmVmb3JlX3ByaW50KCk7CiAgICB3aW5kb3cucHJpbnQoKTsKICAgIHRoaXMuYWZ0ZXJfcHJpbnQoKTsKICB9LAoKICAvLyAjIyMgT0JTT0xFVEUgPz8gIyMjCiAgdG9nZ2xlX3ZpZXc6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLnZpZXdfYWxsKQogICAgewogICAgICB0aGlzLnNpbmdsZV9zbGlkZV92aWV3KCk7CiAgICAgIHRoaXMuc2hvd190b29sYmFyKCk7CiAgICAgIHRoaXMudmlld19hbGwgPSAwOwogICAgfQogICAgZWxzZQogICAgewogICAgICB0aGlzLnNob3dfYWxsX3NsaWRlcygpOwogICAgICB0aGlzLmhpZGVfdG9vbGJhcigpOwogICAgICB0aGlzLnZpZXdfYWxsID0gMTsKICAgIH0KICB9LAoKICAvLyBwcmVwYXJlIGZvciBwcmludGluZyAgIyMjIE9CU09MRVRFICMjIwogIHNob3dfYWxsX3NsaWRlczogZnVuY3Rpb24gKCkgewogICAgdGhpcy5yZW1vdmVfY2xhc3MoZG9jdW1lbnQuYm9keSwgInNpbmdsZV9zbGlkZSIpOwogICAgdGhpcy5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICB9LAoKICAvLyByZXN0b3JlIGFmdGVyIHByaW50aW5nICAjIyMgT0JTT0xFVEUgIyMjCiAgc2luZ2xlX3NsaWRlX3ZpZXc6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuYWRkX2NsYXNzKGRvY3VtZW50LmJvZHksICJzaW5nbGVfc2xpZGUiKTsKICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICB0aGlzLmxhc3Rfc2hvd24gPSB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obnVsbCk7CiAgfSwKCiAgLy8gc3VwcHJlc3MgSUUncyBpbWFnZSB0b29sYmFyIHBvcCB1cAogIGhpZGVfaW1hZ2VfdG9vbGJhcjogZnVuY3Rpb24gKCkgewogICAgaWYgKCF0aGlzLm5zX3BvcykKICAgIHsKICAgICAgdmFyIGltYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJJTUciKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKQogICAgICAgIGltYWdlc1tpXS5zZXRBdHRyaWJ1dGUoImdhbGxlcnlpbWciLCAibm8iKTsKICAgIH0KICB9LAoKICB1bmxvYWRlZDogZnVuY3Rpb24gKGUpIHsKICAgIC8vYWxlcnQoInVubG9hZGVkIik7CiAgfSwKCiAgLy8gU2FmYXJpIGFuZCBLb25xdWVyb3IgZG9uJ3QgeWV0IHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSgpCiAgLy8gYW5kIHRoZXkgYWx3YXlzIHJlbG9hZCBwYWdlIHdoZW4gbG9jYXRpb24uaHJlZiBpcyB1cGRhdGVkCiAgaXNfS0hUTUw6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7CiAgICByZXR1cm4gKGFnZW50LmluZGV4T2YoIktIVE1MIikgPj0gMCA/IHRydWUgOiBmYWxzZSk7CiAgfSwKCiAgLy8gZmluZCBzbGlkZSBuYW1lIGZyb20gZmlyc3QgaDEgZWxlbWVudAogIC8vIGRlZmF1bHQgdG8gZG9jdW1lbnQgdGl0bGUgKyBzbGlkZSBudW1iZXIKICBzbGlkZV9uYW1lOiBmdW5jdGlvbiAoaW5kZXgpIHsKICAgIHZhciBuYW1lID0gbnVsbDsKICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzW2luZGV4XTsKCiAgICB2YXIgaGVhZGluZyA9IHRoaXMuZmluZF9oZWFkaW5nKHNsaWRlKTsKCiAgICBpZiAoaGVhZGluZykKICAgICAgbmFtZSA9IHRoaXMuZXh0cmFjdF90ZXh0KGhlYWRpbmcpOwoKICAgIGlmICghbmFtZSkKICAgICAgbmFtZSA9IHRoaXMudGl0bGUgKyAiKCIgKyAoaW5kZXggKyAxKSArICIpIjsKCiAgICBuYW1lLnJlcGxhY2UoL1wmL2csICImYW1wOyIpOwogICAgbmFtZS5yZXBsYWNlKC9cPC9nLCAiJmx0OyIpOwogICAgbmFtZS5yZXBsYWNlKC9cPi9nLCAiJmd0OyIpOwoKICAgIHJldHVybiBuYW1lOwogIH0sCgogIC8vIGZpbmQgZmlyc3QgaDEgZWxlbWVudCBpbiBET00gdHJlZQogIGZpbmRfaGVhZGluZzogZnVuY3Rpb24gKG5vZGUpIHsKICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBudWxsOwoKICAgIGlmIChub2RlLm5vZGVOYW1lID09ICJIMSIgfHwgbm9kZS5ub2RlTmFtZSA9PSAiaDEiKQogICAgICByZXR1cm4gbm9kZTsKCiAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7CgogICAgd2hpbGUgKGNoaWxkKQogICAgewogICAgICBub2RlID0gdGhpcy5maW5kX2hlYWRpbmcoY2hpbGQpOwoKICAgICAgaWYgKG5vZGUpCiAgICAgICAgcmV0dXJuIG5vZGU7CgogICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nOwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIC8vIHJlY3Vyc2l2ZWx5IGV4dHJhY3QgdGV4dCBmcm9tIERPTSB0cmVlCiAgZXh0cmFjdF90ZXh0OiBmdW5jdGlvbiAobm9kZSkgewogICAgaWYgKCFub2RlKQogICAgICByZXR1cm4gIiI7CgogICAgLy8gdGV4dCBub2RlcwogICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykKICAgICAgcmV0dXJuIG5vZGUubm9kZVZhbHVlOwoKICAgIC8vIGVsZW1lbnRzCiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKQogICAgewogICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkOwogICAgICB2YXIgdGV4dCA9ICIiOwoKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB0ZXh0ID0gdGV4dCArIHRoaXMuZXh0cmFjdF90ZXh0KG5vZGUpOwogICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogICAgICB9CgogICAgICByZXR1cm4gdGV4dDsKICAgIH0KCiAgICByZXR1cm4gIiI7CiAgfSwKCiAgLy8gZmluZCBjb3B5cmlnaHQgdGV4dCBmcm9tIG1ldGEgZWxlbWVudAogIGZpbmRfY29weXJpZ2h0OiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgbmFtZSwgY29udGVudDsKICAgIHZhciBtZXRhID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIm1ldGEiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIG5hbWUgPSBtZXRhW2ldLmdldEF0dHJpYnV0ZSgibmFtZSIpOwogICAgICBjb250ZW50ID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoImNvbnRlbnQiKTsKCiAgICAgIGlmIChuYW1lID09ICJjb3B5cmlnaHQiKQogICAgICAgIHJldHVybiBjb250ZW50OwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIGZpbmRfc2l6ZV9hZGp1c3Q6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBuYW1lLCBjb250ZW50LCBvZmZzZXQ7CiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJtZXRhIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgKytpKQogICAgewogICAgICBuYW1lID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgY29udGVudCA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7CgogICAgICBpZiAobmFtZSA9PSAiZm9udC1zaXplLWFkanVzdG1lbnQiKQogICAgICAgIHJldHVybiAxICogY29udGVudDsKICAgIH0KCiAgICByZXR1cm4gMTsKICB9LAoKICAvLyA8bWV0YSBuYW1lPSJkdXJhdGlvbiIgY29udGVudD0iMjAiIC8+ICBmb3IgMjAgbWludXRlcwogIGZpbmRfZHVyYXRpb246IGZ1bmN0aW9uICgpIHsKICAgIHZhciBuYW1lLCBjb250ZW50LCBvZmZzZXQ7CiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJtZXRhIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgKytpKQogICAgewogICAgICBuYW1lID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgY29udGVudCA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7CgogICAgICBpZiAobmFtZSA9PSAiZHVyYXRpb24iKQogICAgICAgIHJldHVybiA2MDAwMCAqIGNvbnRlbnQ7CiAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfSwKCiAgcmVwbGFjZV9ieV9ub25fYnJlYWtpbmdfc3BhY2U6IGZ1bmN0aW9uIChzdHIpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKQogICAgICBzdHJbaV0gPSAxNjA7CiAgfSwKCiAgLy8gIyMjIENIRUNLIE1FICMjIyBpcyB1c2Ugb2YgImxpIiBva2F5IGZvciB0ZXh0L2h0bWw/CiAgLy8gZm9yIFhIVE1MIGRvIHdlIGFsc28gbmVlZCB0byBzcGVjaWZ5IG5hbWVzcGFjZT8KICBpbml0X291dGxpbmVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgaXRlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgibGkiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKQogICAgewogICAgICB2YXIgdGFyZ2V0ID0gaXRlbXNbaV07CgogICAgICBpZiAoIXRoaXMuaGFzX2NsYXNzKHRhcmdldC5wYXJlbnROb2RlLCAib3V0bGluZSIpKQogICAgICAgIGNvbnRpbnVlOwoKICAgICAgdGFyZ2V0Lm9uY2xpY2sgPSB0aGlzLm91dGxpbmVfY2xpY2s7Ci8qICMjIyBtb3JlIHdvcmsgbmVlZGVkIGZvciBJRTYKICAgICAgaWYgKCF0aGlzLm5zX3BvcykKICAgICAgewogICAgICAgIHRhcmdldC5vbm1vdXNlb3ZlciA9IHRoaXMuaG92ZXJfb3V0bGluZTsKICAgICAgICB0YXJnZXQub25tb3VzZW91dCA9IHRoaXMudW5ob3Zlcl9vdXRsaW5lOwogICAgICB9CiovCiAgICAgIGlmICh0aGlzLmZvbGRhYmxlKHRhcmdldCkpCiAgICAgIHsKICAgICAgICB0YXJnZXQuZm9sZGFibGUgPSB0cnVlOwogICAgICAgIHRhcmdldC5vbmZvY3VzID0gZnVuY3Rpb24gKCkge3czY19zbGlkeS5vdXRsaW5lID0gdGhpczt9OwogICAgICAgIHRhcmdldC5vbmJsdXIgPSBmdW5jdGlvbiAoKSB7dzNjX3NsaWR5Lm91dGxpbmUgPSBudWxsO307CgogICAgICAgIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgidGFiaW5kZXgiKSkKICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoInRhYmluZGV4IiwgIjAiKTsKCiAgICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKHRhcmdldCwgImV4cGFuZCIpKQogICAgICAgICAgdGhpcy51bmZvbGQodGFyZ2V0KTsKICAgICAgICBlbHNlCiAgICAgICAgICB0aGlzLmZvbGQodGFyZ2V0KTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB0aGlzLmFkZF9jbGFzcyh0YXJnZXQsICJub2ZvbGQiKTsKICAgICAgICB0YXJnZXQudmlzaWJsZSA9IHRydWU7CiAgICAgICAgdGFyZ2V0LmZvbGRhYmxlID0gZmFsc2U7CiAgICAgIH0KICAgIH0KICB9LAoKICBmb2xkYWJsZTogZnVuY3Rpb24gKGl0ZW0pIHsKICAgIGlmICghaXRlbSB8fCBpdGVtLm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBmYWxzZTsKCiAgICB2YXIgbm9kZSA9IGl0ZW0uZmlyc3RDaGlsZDsKCiAgICB3aGlsZSAobm9kZSkKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmlzX2Jsb2NrKG5vZGUpKQogICAgICAgIHJldHVybiB0cnVlOwoKICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIC8vICMjIyBDSEVDSyBNRSAjIyMgc3dpdGNoIHRvIGFkZC9yZW1vdmUgImhpZGRlbiIgY2xhc3MKICBmb2xkOiBmdW5jdGlvbiAoaXRlbSkgewogICAgaWYgKGl0ZW0pCiAgICB7CiAgICAgIHRoaXMucmVtb3ZlX2NsYXNzKGl0ZW0sICJ1bmZvbGRlZCIpOwogICAgICB0aGlzLmFkZF9jbGFzcyhpdGVtLCAiZm9sZGVkIik7CiAgICB9CgogICAgdmFyIG5vZGUgPSBpdGVtID8gaXRlbS5maXJzdENoaWxkIDogbnVsbDsKCiAgICB3aGlsZSAobm9kZSkKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmlzX2Jsb2NrKG5vZGUpKSAvLyBlbGVtZW50CiAgICAgIHsKICAgICAgICAgdzNjX3NsaWR5LmFkZF9jbGFzcyhub2RlLCAiaGlkZGVuIik7CiAgICAgIH0KCiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogICAgfQoKICAgIGl0ZW0udmlzaWJsZSA9IGZhbHNlOwogIH0sCgogIC8vICMjIyBDSEVDSyBNRSAjIyMgc3dpdGNoIHRvIGFkZC9yZW1vdmUgImhpZGRlbiIgY2xhc3MKICB1bmZvbGQ6IGZ1bmN0aW9uIChpdGVtKSB7CiAgICBpZiAoaXRlbSkKICAgIHsKICAgICAgdGhpcy5hZGRfY2xhc3MoaXRlbSwgInVuZm9sZGVkIik7CiAgICAgIHRoaXMucmVtb3ZlX2NsYXNzKGl0ZW0sICJmb2xkZWQiKTsKICAgIH0KCiAgICB2YXIgbm9kZSA9IGl0ZW0gPyBpdGVtLmZpcnN0Q2hpbGQgOiBudWxsOwoKICAgIHdoaWxlIChub2RlKQogICAgewogICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIHRoaXMuaXNfYmxvY2sobm9kZSkpIC8vIGVsZW1lbnQKICAgICAgewogICAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3Mobm9kZSwgImhpZGRlbiIpOwogICAgICB9CgogICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZzsKICAgIH0KCiAgICBpdGVtLnZpc2libGUgPSB0cnVlOwogIH0sCgogIG91dGxpbmVfY2xpY2s6IGZ1bmN0aW9uIChlKSB7CiAgICBpZiAoIWUpCiAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgdmFyIHJpZ2h0Y2xpY2sgPSBmYWxzZTsKICAgIHZhciB0YXJnZXQgPSB3M2Nfc2xpZHkuZ2V0X3RhcmdldChlKTsKCiAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC52aXNpYmxlID09IHVuZGVmaW5lZCkKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgaWYgKCF0YXJnZXQpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmIChlLndoaWNoKQogICAgICByaWdodGNsaWNrID0gKGUud2hpY2ggPT0gMyk7CiAgICBlbHNlIGlmIChlLmJ1dHRvbikKICAgICAgcmlnaHRjbGljayA9IChlLmJ1dHRvbiA9PSAyKTsKCiAgICBpZiAoIXJpZ2h0Y2xpY2sgJiYgdGFyZ2V0LnZpc2libGUgIT0gdW5kZWZpbmVkKQogICAgewogICAgICBpZiAodGFyZ2V0LmZvbGRhYmxlKQogICAgICB7CiAgICAgICAgaWYgKHRhcmdldC52aXNpYmxlKQogICAgICAgICAgdzNjX3NsaWR5LmZvbGQodGFyZ2V0KTsKICAgICAgICBlbHNlCiAgICAgICAgICB3M2Nfc2xpZHkudW5mb2xkKHRhcmdldCk7CiAgICAgIH0KCiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfSwKCiAgYWRkX2luaXRpYWxfcHJvbXB0OiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgcHJvbXB0ID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICBwcm9tcHQuc2V0QXR0cmlidXRlKCJjbGFzcyIsICJpbml0aWFsX3Byb21wdCIpOwoKICAgIHZhciBwMSA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoInAiKTsKICAgIHByb21wdC5hcHBlbmRDaGlsZChwMSk7CiAgICBwMS5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgImhlbHAiKTsKCiAgICBpZiAodGhpcy5rZXlib2FyZGxlc3MpCiAgICAgIHAxLmlubmVySFRNTCA9ICJzd2lwZSBsZWZ0IHRvIG1vdmUgdG8gbmV4dCBzbGlkZSI7CiAgICBlbHNlCiAgICAgIHAxLmlubmVySFRNTCA9ICJTcGFjZSwgUmlnaHQgQXJyb3cgb3Igc3dpcGUgbGVmdCB0byBtb3ZlIHRvICIgKwogICAgICAgICAgICAgICAgICAgICAibmV4dCBzbGlkZSwgY2xpY2sgaGVscCBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzIjsKCiAgICB0aGlzLmFkZF9saXN0ZW5lcihwcm9tcHQsICJjbGljayIsIGZ1bmN0aW9uIChlKSB7CiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocHJvbXB0KTsKICAgICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICAKICAgICAgaWYgKGUuY2FuY2VsICE9IHVuZGVmaW5lZCkKICAgICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIAogICAgICBpZiAoZS5yZXR1cm5WYWx1ZSAhPSB1bmRlZmluZWQpCiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOwogICAgICAKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSk7CgogICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcm9tcHQpOwogICAgdGhpcy5pbml0aWFsX3Byb21wdCA9IHByb21wdDsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwcm9tcHQpO30sIDUwMDApOwogIH0sCgogIGFkZF90b29sYmFyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgY291bnRlciwgcGFnZTsKCiAgICAgdGhpcy50b29sYmFyID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICAgdGhpcy50b29sYmFyLnNldEF0dHJpYnV0ZSgiY2xhc3MiLCAidG9vbGJhciIpOwoKICAgICAvLyBhIHJlYXNvbmFibHkgYmVoYXZlZCBicm93c2VyCiAgICAgaWYgKHRoaXMubnNfcG9zIHx8ICF0aGlzLmllNikKICAgICB7CiAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKTsKICAgICAgIHJpZ2h0LnNldEF0dHJpYnV0ZSgic3R5bGUiLCAiZmxvYXQ6IHJpZ2h0OyB0ZXh0LWFsaWduOiByaWdodCIpOwoKICAgICAgIGNvdW50ZXIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIikKICAgICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgic2xpZGUiKSArICIgbi9tIjsKICAgICAgIHJpZ2h0LmFwcGVuZENoaWxkKGNvdW50ZXIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKHJpZ2h0KTsKCiAgICAgICB2YXIgbGVmdCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImRpdiIpOwogICAgICAgbGVmdC5zZXRBdHRyaWJ1dGUoInN0eWxlIiwgInRleHQtYWxpZ246IGxlZnQiKTsKCiAgICAgICAvLyBnbG9iYWwgZW5kIG9mIHNsaWRlIGluZGljYXRvcgogICAgICAgdGhpcy5lb3MgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICB0aGlzLmVvcy5pbm5lckhUTUwgPSAiKiAiOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZCh0aGlzLmVvcyk7CgogICAgICAgdmFyIGhlbHAgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJhIik7CiAgICAgICBoZWxwLnNldEF0dHJpYnV0ZSgiaHJlZiIsIHRoaXMuaGVscF9wYWdlKTsKICAgICAgIGhlbHAuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIHRoaXMubG9jYWxpemUodGhpcy5oZWxwX3RleHQpKTsKICAgICAgIGhlbHAuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgiaGVscD8iKTsKICAgICAgIGxlZnQuYXBwZW5kQ2hpbGQoaGVscCk7CiAgICAgICBoZWxwLnN0eWxlLmRpc3BsYXk9Im5vbmUiOyAKICAgICAgIHRoaXMuaGVscF9hbmNob3IgPSBoZWxwOyAgLy8gc2F2ZSBmb3IgZm9jdXMgaGFjawoKICAgICAgIHZhciBnYXAxID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIiAiKTsKICAgICAgIGxlZnQuYXBwZW5kQ2hpbGQoZ2FwMSk7CgogICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiYSIpOwogICAgICAgY29udGVudHMuc2V0QXR0cmlidXRlKCJocmVmIiwgImphdmFzY3JpcHQ6dzNjX3NsaWR5LnRvZ2dsZV90YWJsZV9vZl9jb250ZW50cygpIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSgidGFibGUgb2YgY29udGVudHMiKSk7CiAgICAgICBjb250ZW50cy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJDb250ZW50cyIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChnYXAyKTsKCiAgICAgICB2YXIgY29weXJpZ2h0ID0gdGhpcy5maW5kX2NvcHlyaWdodCgpOwoKICAgICAgIGlmIChjb3B5cmlnaHQpCiAgICAgICB7CiAgICAgICAgIHZhciBzcGFuID0gdGhpcy5jcmVhdGVfZWxlbWVudCgic3BhbiIpOwogICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICJjb3B5cmlnaHQiOwogICAgICAgICBzcGFuLmlubmVySFRNTCA9IGNvcHlyaWdodDsKICAgICAgICAgbGVmdC5hcHBlbmRDaGlsZChzcGFuKTsKICAgICAgIH0KCiAgICAgICB0aGlzLnRvb2xiYXIuc2V0QXR0cmlidXRlKCJ0YWJpbmRleCIsICIwIik7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQobGVmdCk7CiAgICAgfQogICAgIGVsc2UgLy8gSUU2IHNvIG5lZWQgdG8gd29yayBhcm91bmQgaXRzIHBvb3IgQ1NTIHN1cHBvcnQKICAgICB7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUucG9zaXRpb24gPSAodGhpcy5pZTcgPyAiZml4ZWQiIDogImFic29sdXRlIik7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUuekluZGV4ID0gIjIwMCI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUud2lkdGggPSAiOTkuOSUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmhlaWdodCA9ICIxLjJlbSI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUudG9wID0gImF1dG8iOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmJvdHRvbSA9ICIwIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5sZWZ0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnRleHRBbGlnbiA9ICJsZWZ0IjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5mb250U2l6ZSA9ICI2MCUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmNvbG9yID0gInJlZCI7CiAgICAgICB0aGlzLnRvb2xiYXIuYm9yZGVyV2lkdGggPSAwOwogICAgICAgdGhpcy50b29sYmFyLmNsYXNzTmFtZSA9ICJ0b29sYmFyIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIC8vIHdvdWxkIGxpa2UgdG8gaGF2ZSBoZWxwIHRleHQgbGVmdCBhbGlnbmVkCiAgICAgICAvLyBhbmQgcGFnZSBjb3VudGVyIHJpZ2h0IGFsaWduZWQsIGZsb2F0aW5nCiAgICAgICAvLyBkaXYncyBkb24ndCB3b3JrLCBzbyBpbnN0ZWFkIHVzZSBuZXN0ZWQKICAgICAgIC8vIGFic29sdXRlbHkgcG9zaXRpb25lZCBkaXYncy4KCiAgICAgICB2YXIgc3AgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICBzcC5pbm5lckhUTUwgPSAiJm5ic3A7Jm5ic3A7KiZuYnNwOyI7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQoc3ApOwogICAgICAgdGhpcy5lb3MgPSBzcDsgIC8vIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKCiAgICAgICB2YXIgaGVscCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGhlbHAuc2V0QXR0cmlidXRlKCJocmVmIiwgdGhpcy5oZWxwX3BhZ2UpOwogICAgICAgaGVscC5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSh0aGlzLmhlbHBfdGV4dCkpOwogICAgICAgaGVscC5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJoZWxwPyIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGhlbHApOwogICAgICAgdGhpcy5oZWxwX2FuY2hvciA9IGhlbHA7ICAvLyBzYXZlIGZvciBmb2N1cyBoYWNrCgogICAgICAgdmFyIGdhcDEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDEpOwoKICAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGNvbnRlbnRzLnNldEF0dHJpYnV0ZSgiaHJlZiIsICJqYXZhc2NyaXB0OnRvZ2dsZVRhYmxlT2ZDb250ZW50cygpIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSgidGFibGUgb2YgY29udGVudHMiLmxvY2FsaXplKSk7CiAgICAgICBjb250ZW50cy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJjb250ZW50cz8iKTsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDIpOwoKICAgICAgIHZhciBjb3B5cmlnaHQgPSB0aGlzLmZpbmRfY29weXJpZ2h0KCk7CgogICAgICAgaWYgKGNvcHlyaWdodCkKICAgICAgIHsKICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gY29weXJpZ2h0OwogICAgICAgICBzcGFuLnN0eWxlLmNvbG9yID0gImJsYWNrIjsKICAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5MZWZ0ID0gIjAuNWVtIjsKICAgICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKHNwYW4pOwogICAgICAgfQoKICAgICAgIGNvdW50ZXIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKQogICAgICAgY291bnRlci5zdHlsZS5wb3NpdGlvbiA9ICJhYnNvbHV0ZSI7CiAgICAgICBjb3VudGVyLnN0eWxlLndpZHRoID0gImF1dG8iOyAvLyIyMCUiOwogICAgICAgY291bnRlci5zdHlsZS5oZWlnaHQgPSAiMS4yZW0iOwogICAgICAgY291bnRlci5zdHlsZS50b3AgPSAiYXV0byI7CiAgICAgICBjb3VudGVyLnN0eWxlLmJvdHRvbSA9IDA7CiAgICAgICBjb3VudGVyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgY291bnRlci5zdHlsZS50ZXh0QWxpZ24gPSAicmlnaHQiOwogICAgICAgY291bnRlci5zdHlsZS5jb2xvciA9ICJyZWQiOwogICAgICAgY291bnRlci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgic2xpZGUiKSArICIgbi9tIjsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb3VudGVyKTsKICAgICB9CgogICAgIC8vIGVuc3VyZSB0aGF0IGNsaWNrIGlzbid0IHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBwYWdlCiAgICAgdGhpcy50b29sYmFyLm9uY2xpY2sgPQogICAgICAgICBmdW5jdGlvbiAoZSkgewogICAgICAgICAgIGlmICghZSkKICAgICAgICAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDsKCiAgICAgICAgICAgaWYgKCF0YXJnZXQgJiYgZS5zcmNFbGVtZW50KQogICAgICAgICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBTYWZhcmkgYnVnCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykKICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAiYSIpCiAgICAgICAgICAgICB3M2Nfc2xpZHkubW91c2VfYnV0dG9uX2NsaWNrKGUpOwogICAgICAgICB9OwoKICAgICB0aGlzLnNsaWRlX251bWJlcl9lbGVtZW50ID0gY291bnRlcjsKICAgICB0aGlzLnNldF9lb3Nfc3RhdHVzKGZhbHNlKTsKICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9vbGJhcik7CiAgfSwKCiAgLy8gd3lzaXd5ZyBlZGl0b3JzIG1ha2UgaXQgaGFyZCB0byB1c2UgZGl2IGVsZW1lbnRzCiAgLy8gZS5nLiBhbWF5YSBsb3NlcyB0aGUgZGl2IHdoZW4geW91IGNvcHkgYW5kIHBhc3RlCiAgLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBkaXYgZWxlbWVudHMgYXJvdW5kIGltcGxpY2l0CiAgLy8gc2xpZGVzIHdoaWNoIHN0YXJ0IHdpdGggYW4gaDEgZWxlbWVudCBhbmQgY29udGludWUKICAvLyB1cCB0byB0aGUgbmV4dCBoZWFkaW5nIG9yIGRpdiBlbGVtZW50CiAgd3JhcF9pbXBsaWNpdF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBpLCBoZWFkaW5nLCBub2RlLCBuZXh0LCBkaXY7CiAgICB2YXIgaGVhZGluZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaDEiKTsKCiAgICBpZiAoIWhlYWRpbmdzKQogICAgICByZXR1cm47CgogICAgZm9yIChpID0gMDsgaSA8IGhlYWRpbmdzLmxlbmd0aDsgKytpKQogICAgewogICAgICBoZWFkaW5nID0gaGVhZGluZ3NbaV07CgogICAgICBpZiAoaGVhZGluZy5wYXJlbnROb2RlICE9IGRvY3VtZW50LmJvZHkpCiAgICAgICAgY29udGludWU7CgogICAgICBub2RlID0gaGVhZGluZy5uZXh0U2libGluZzsKCiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJzbGlkZSIpOwogICAgICBkb2N1bWVudC5ib2R5LnJlcGxhY2VDaGlsZChkaXYsIGhlYWRpbmcpOwogICAgICBkaXYuYXBwZW5kQ2hpbGQoaGVhZGluZyk7CgogICAgICB3aGlsZSAobm9kZSkKICAgICAgewogICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIC8vIGFuIGVsZW1lbnQKICAgICAgICB7CiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkgxIiB8fCBub2RlLm5vZGVOYW1lID09ICJoMSIpCiAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkRJViIgfHwgbm9kZS5ub2RlTmFtZSA9PSAiZGl2IikKICAgICAgICAgICB7CiAgICAgICAgICAgICBpZiAodGhpcy5oYXNfY2xhc3Mobm9kZSwgInNsaWRlIikpCiAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhub2RlLCAiaGFuZG91dCIpKQogICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZzsKICAgICAgICBub2RlID0gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub2RlKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZSk7CiAgICAgICAgbm9kZSA9IG5leHQ7CiAgICAgIH0gCiAgICB9CiAgfSwKCiAgYXR0YWNoX3RvdWNoX2hhbmRlcnM6IGZ1bmN0aW9uKHNsaWRlcykKICB7CiAgICB2YXIgaSwgc2xpZGU7CgogICAgZm9yIChpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgc2xpZGUgPSBzbGlkZXNbaV07CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2hzdGFydCIsIHRoaXMudG91Y2hzdGFydCk7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2htb3ZlIiwgdGhpcy50b3VjaG1vdmUpOwogICAgICB0aGlzLmFkZF9saXN0ZW5lcihzbGlkZSwgInRvdWNoZW5kIiwgdGhpcy50b3VjaGVuZCk7CiAgICB9CiAgfSwKCi8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIHNsaWRlcwogIGNvbGxlY3Rfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc2xpZGVzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgInNsaWRlIikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgc2xpZGUgdG8gY29sbGVjdGlvbgogICAgICAgIHNsaWRlc1tzbGlkZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gaGlkZSBlYWNoIHNsaWRlIGFzIGl0IGlzIGZvdW5kCiAgICAgICAgdGhpcy5hZGRfY2xhc3MoZGl2LCAiaGlkZGVuIik7CgogICAgICAgIC8vIGFkZCBkdW1teSA8YnIvPiBhdCBlbmQgZm9yIHNjcm9sbGluZyBoYWNrCiAgICAgICAgdmFyIG5vZGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnIiKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZTEpOwogICAgICAgIHZhciBub2RlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJyIik7CiAgICAgICAgZGl2LmFwcGVuZENoaWxkKG5vZGUyKTsKICAgICAgfQogICAgICBlbHNlIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJiYWNrZ3JvdW5kIikpCiAgICAgIHsgIC8vIHdvcmsgYXJvdW5kIGZvciBGaXJlZm94IFNWRyByZWxvYWQgYnVnCiAgICAgICAgLy8gd2hpY2ggb3RoZXJ3aXNlIHJlcGxhY2VzIDFzdCBTVkcgZ3JhcGhpYyB3aXRoIDJuZAogICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKICAgICAgfQogICAgfQoKICAgIHRoaXMuc2xpZGVzID0gc2xpZGVzOwogIH0sCgogIC8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIDxkaXYgY2xhc3M9ImhhbmRvdXQiPgogIGNvbGxlY3Rfbm90ZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBub3RlcyA9IG5ldyBBcnJheSgpOwogICAgdmFyIGRpdnMgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpdnMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGRpdiA9IGRpdnMuaXRlbShpKTsKCiAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJoYW5kb3V0IikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgbm90ZSB0byBjb2xsZWN0aW9uCiAgICAgICAgbm90ZXNbbm90ZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gYW5kIGhpZGUgaXQKICAgICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJoaWRkZW4iKTsKICAgICAgfQogICAgfQoKICAgIHRoaXMubm90ZXMgPSBub3RlczsKICB9LAoKICAvLyByZXR1cm4gbmV3IGFycmF5IG9mIGFsbCA8ZGl2IGNsYXNzPSJiYWNrZ3JvdW5kIj4KICAvLyBpbmNsdWRpbmcgbmFtZWQgYmFja2dyb3VuZHMgZS5nLiBjbGFzcz0iYmFja2dyb3VuZCB0aXRsZXBhZ2UiCiAgY29sbGVjdF9iYWNrZ3JvdW5kczogZnVuY3Rpb24gKCkgewogICAgdmFyIGJhY2tncm91bmRzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgImJhY2tncm91bmQiKSkKICAgICAgewogICAgICAgIC8vIGFkZCBiYWNrZ3JvdW5kIHRvIGNvbGxlY3Rpb24KICAgICAgICBiYWNrZ3JvdW5kc1tiYWNrZ3JvdW5kcy5sZW5ndGhdID0gZGl2OwoKICAgICAgICAvLyBhbmQgaGlkZSBpdAogICAgICAgIHRoaXMuYWRkX2NsYXNzKGRpdiwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CgogICAgdGhpcy5iYWNrZ3JvdW5kcyA9IGJhY2tncm91bmRzOwogIH0sCgogIC8vIHNldCBjbGljayBoYW5kbGVycyBvbiBhbGwgYW5jaG9ycwogIHBhdGNoX2FuY2hvcnM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzZWxmID0gdzNjX3NsaWR5OwogICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICAgICAgLy8gY29tcGFyZSB0aGlzLmhyZWYgd2l0aCBsb2NhdGlvbi5ocmVmCiAgICAgIC8vIGZvciBsaW5rIHRvIGFub3RoZXIgc2xpZGUgaW4gdGhpcyBkb2MKCiAgICAgIGlmIChzZWxmLnBhZ2VfYWRkcmVzcyh0aGlzLmhyZWYpID09IHNlbGYucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpKQogICAgICB7CiAgICAgICAgLy8geWVzLCBzbyBmaW5kIG5ldyBzbGlkZSBudW1iZXIKICAgICAgICB2YXIgbmV3c2xpZGVudW0gPSBzZWxmLmZpbmRfc2xpZGVfbnVtYmVyKHRoaXMuaHJlZik7CgogICAgICAgIGlmIChuZXdzbGlkZW51bSAhPSBzZWxmLnNsaWRlX251bWJlcikKICAgICAgICB7CiAgICAgICAgICB2YXIgc2xpZGUgPSBzZWxmLnNsaWRlc1tzZWxmLnNsaWRlX251bWJlcl07CiAgICAgICAgICBzZWxmLmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICAgc2VsZi5zbGlkZV9udW1iZXIgPSBuZXdzbGlkZW51bTsKICAgICAgICAgIHNsaWRlID0gc2VsZi5zbGlkZXNbc2VsZi5zbGlkZV9udW1iZXJdOwogICAgICAgICAgc2VsZi5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgICAgIHNlbGYuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGVsc2UKICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihldmVudCk7CgovLyAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09IG51bGwpCi8vICAgICAgICBsb2NhdGlvbi5ocmVmID0gdGhpcy5ocmVmOwoKICAgICAgdGhpcy5ibHVyKCk7CiAgICAgIHNlbGYuZGlzYWJsZV9zbGlkZV9jbGljayA9IHRydWU7CiAgICB9OwoKICAgIHZhciBhbmNob3JzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jaG9ycy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKQogICAgICAgIGFuY2hvcnNbaV0uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCBoYW5kbGVyLCBmYWxzZSk7CiAgICAgIGVsc2UKICAgICAgICBhbmNob3JzW2ldLmF0dGFjaEV2ZW50KCJvbmNsaWNrIiwgaGFuZGxlcik7CiAgICB9CiAgfSwKCiAgLy8gIyMjIENIRUNLIE1FICMjIyBzZWUgd2hpY2ggZnVuY3Rpb25zIGFyZSBpbnZva2VkIHZpYSBzZXRUaW1lb3V0CiAgLy8gZWl0aGVyIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgZm9yIHVzZSBvZiB3M2Nfc2xpZHkgdnMgdGhpcwogIHNob3dfc2xpZGVfbnVtYmVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSB3M2Nfc2xpZHkuZ2V0X3RpbWVyKCk7CiAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyX2VsZW1lbnQuaW5uZXJIVE1MID0gdGltZXIgKyB3M2Nfc2xpZHkubG9jYWxpemUoInNsaWRlIikgKyAiICIgKwogICAgICAgICAgICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICsgMSkgKyAiLyIgKyB3M2Nfc2xpZHkuc2xpZGVzLmxlbmd0aDsKICB9LAoKICAvLyBldmVyeSAyMDBtUyBjaGVjayBpZiB0aGUgbG9jYXRpb24gaGFzIGJlZW4gY2hhbmdlZCBhcyBhCiAgLy8gcmVzdWx0IG9mIHRoZSB1c2VyIGFjdGl2YXRpbmcgdGhlIEJhY2sgYnV0dG9uL21lbnUgaXRlbQogIC8vIGRvZXNuJ3Qgd29yayBmb3IgT3BlcmEgPCA5LjUKICBjaGVja19sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoOwoKICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID4gMCAmJiAoaGFzaCA9PSAiIiB8fCBoYXNoID09ICIjIikpCiAgICAgIHczY19zbGlkeS5nb3RvX3NsaWRlKDApOwogICAgZWxzZSBpZiAoaGFzaC5sZW5ndGggPiAyICYmIGhhc2ggIT0gIiMoIisodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSsiKSIpCiAgICB7CiAgICAgIHZhciBudW0gPSBwYXJzZUludChsb2NhdGlvbi5oYXNoLnN1YnN0cigyKSk7CgogICAgICBpZiAoIWlzTmFOKG51bSkpCiAgICAgICAgdzNjX3NsaWR5LmdvdG9fc2xpZGUobnVtLTEpOwogICAgfQoKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ICYmIHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgewogICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ID4gMCkKICAgICAgICB3M2Nfc2xpZHkudGltZV9sZWZ0IC09IDIwMDsKICAgIH0gCiAgfSwKCiAgZ2V0X3RpbWVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSAiIjsKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0KQogICAgewogICAgICB2YXIgbWlucywgc2VjczsKICAgICAgc2VjcyA9IE1hdGguZmxvb3IodzNjX3NsaWR5LnRpbWVfbGVmdC8xMDAwKTsKICAgICAgbWlucyA9IE1hdGguZmxvb3Ioc2VjcyAvIDYwKTsKICAgICAgc2VjcyA9IHNlY3MgJSA2MDsKICAgICAgdGltZXIgPSAobWlucyA/IG1pbnMrIm0iIDogIiIpICsgc2VjcyArICJzICI7CiAgICB9CgogICAgcmV0dXJuIHRpbWVyOwogIH0sCgogIC8vIHRoaXMgZG9lc24ndCBwdXNoIGxvY2F0aW9uIG9udG8gaGlzdG9yeSBzdGFjayBmb3IgSUUKICAvLyBmb3Igd2hpY2ggYSBoaWRkZW4gaWZyYW1lIGhhY2sgaXMgbmVlZGVkOiBsb2FkIHBhZ2UgaW50bwogIC8vIHRoZSBpZnJhbWUgd2l0aCBzY3JpcHQgdGhhdCBzZXQncyBwYXJlbnQncyBsb2NhdGlvbi5oYXNoCiAgLy8gYnV0IHRoYXQgd29uJ3Qgd29yayBmb3Igc3RhbmRhbG9uZSB1c2UgdW5sZXNzIHdlIGNhbgogIC8vIGNyZWF0ZSB0aGUgcGFnZSBkeW5hbWljYWxseSB2aWEgYSBqYXZhc2NyaXB0OiBVUkwKICAvLyAjIyMgdXNlIGhpc3RvcnkucHVzaFN0YXRlIGlmIGF2YWlsYWJsZQogIHNldF9sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgIHZhciB1cmkgPSB3M2Nfc2xpZHkucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpOwogICAgIHZhciBoYXNoID0gIiMoIiArICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyKzEpICsgIikiOwoKICAgICBpZiAodzNjX3NsaWR5LnNsaWRlX251bWJlciA+PSAwKQogICAgICAgdXJpID0gdXJpICsgaGFzaDsKCiAgICAgaWYgKHR5cGVvZihoaXN0b3J5LnB1c2hTdGF0ZSkgIT0gInVuZGVmaW5lZCIgJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICJmaWxlOiIpCiAgICAgewogICAgICAgZG9jdW1lbnQudGl0bGUgPSB3M2Nfc2xpZHkudGl0bGUgKyAiICgiICsgKHczY19zbGlkeS5zbGlkZV9udW1iZXIrMSkgKyAiKSI7CiAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSgwLCBkb2N1bWVudC50aXRsZSwgaGFzaCk7CiAgICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKICAgICAgIHczY19zbGlkeS5ub3RpZnlfb2JzZXJ2ZXJzKCk7CiAgICAgICByZXR1cm47CiAgICAgfQoKICAgICBpZiAodzNjX3NsaWR5LmllICYmICh3M2Nfc2xpZHkuaWU2IHx8IHczY19zbGlkeS5pZTcpKQogICAgICAgdzNjX3NsaWR5LnB1c2hfaGFzaChoYXNoKTsKCiAgICAgaWYgKHVyaSAhPSBsb2NhdGlvbi5ocmVmKSAvLyAmJiAha2h0bWwKICAgICAgICBsb2NhdGlvbi5ocmVmID0gdXJpOwoKICAgICBpZiAodGhpcy5raHRtbCkKICAgICAgICBoYXNoID0gIigiICsgKHczY19zbGlkeS5zbGlkZV9udW1iZXIrMSkgKyAiKSI7CgogICAgIGlmICghdGhpcy5pZSAmJiBsb2NhdGlvbi5oYXNoICE9IGhhc2ggJiYgbG9jYXRpb24uaGFzaCAhPSAiIikKICAgICAgIGxvY2F0aW9uLmhhc2ggPSBoYXNoOwoKICAgICBkb2N1bWVudC50aXRsZSA9IHczY19zbGlkeS50aXRsZSArICIgKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKICAgICB3M2Nfc2xpZHkubm90aWZ5X29ic2VydmVycygpOwogIH0sCgogIG5vdGlmeV9vYnNlcnZlcnM6IGZ1bmN0aW9uICgpCiAgewogICAgdmFyIHNsaWRlID0gdGhpcy5zbGlkZXNbdGhpcy5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyArK2kpCiAgICAgIHRoaXMub2JzZXJ2ZXJzW2ldKHRoaXMuc2xpZGVfbnVtYmVyKzEsIHRoaXMuZmluZF9oZWFkaW5nKHNsaWRlKS5pbm5lclRleHQsIGxvY2F0aW9uLmhyZWYpOwogIH0sCgogIGFkZF9vYnNlcnZlcjogZnVuY3Rpb24gKG9ic2VydmVyKQogIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGlmIChvYnNlcnZlciA9PSB0aGlzLm9ic2VydmVyc1tpXSkKICAgICAgICByZXR1cm47CiAgICB9CgogICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7CiAgfSwKCiAgcmVtb3ZlX29ic2VydmVyOiBmdW5jdGlvbiAobykKICB7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgKytpKQogICAgewogICAgICBpZiAob2JzZXJ2ZXIgPT0gdGhpcy5vYnNlcnZlcnNbaV0pCiAgICAgIHsKICAgICAgICB0aGlzLm9ic2VydmVycy5zcGxpY2UoaSwxKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogIH0sCgogIHBhZ2VfYWRkcmVzczogZnVuY3Rpb24gKHVyaSkgewogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIGlmIChpIDwgMCkKICAgICAgaSA9IHVyaS5pbmRleE9mKCIlMjMiKTsKCiAgICAvLyBjaGVjayBpZiBhbmNob3IgaXMgZW50aXJlIHBhZ2UKCiAgICBpZiAoaSA8IDApCiAgICAgIHJldHVybiB1cmk7ICAvLyB5ZXMKCiAgICByZXR1cm4gdXJpLnN1YnN0cigwLCBpKTsKICB9LAoKICAvLyBvbmx5IHVzZWQgZm9yIElFNiBhbmQgSUU3CiAgb25fZnJhbWVfbG9hZGVkOiBmdW5jdGlvbiAoaGFzaCkgewogICAgbG9jYXRpb24uaGFzaCA9IGhhc2g7CiAgICB2YXIgdXJpID0gdzNjX3NsaWR5LnBhZ2VfYWRkcmVzcyhsb2NhdGlvbi5ocmVmKTsKICAgIGxvY2F0aW9uLmhyZWYgPSB1cmkgKyBoYXNoOwogIH0sCgogIC8vIGhpc3RvcnkgaGFjayB3aXRoIHRoYW5rcyB0byBCZXJ0cmFuZCBMZSBSb3kKICBwdXNoX2hhc2g6IGZ1bmN0aW9uIChoYXNoKSB7CiAgICBpZiAoaGFzaCA9PSAiIikgaGFzaCA9ICIjKDEpIjsKICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoOwoKICAgIHZhciBkb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiaGlzdG9yeUZyYW1lIikuY29udGVudFdpbmRvdy5kb2N1bWVudDsKICAgIGRvYy5vcGVuKCJqYXZhc2NyaXB0Oic8aHRtbD48L2h0bWw+JyIpOwogICAgZG9jLndyaXRlKCI8aHRtbD48aGVhZD48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj53aW5kb3cucGFyZW50LnczY19zbGlkeS5vbl9mcmFtZV9sb2FkZWQoJyIrCiAgICAgIChoYXNoKSArICInKTs8L3NjcmlwdD48L2hlYWQ+PGJvZHk+aGVsbG8gbXVtPC9ib2R5PjwvaHRtbD4iKTsKICAgICAgZG9jLmNsb3NlKCk7CiAgfSwKCiAgLy8gZmluZCBjdXJyZW50IHNsaWRlIGJhc2VkIHVwb24gbG9jYXRpb24KICAvLyBmaXJzdCBmaW5kIHRhcmdldCBhbmNob3IgYW5kIHRoZW4gbG9vawogIC8vIGZvciBhc3NvY2lhdGVkIGRpdiBlbGVtZW50IGVuY2xvc2luZyBpdAogIC8vIGZpbmFsbHkgbWFwIHRoYXQgdG8gc2xpZGUgbnVtYmVyCiAgZmluZF9zbGlkZV9udW1iZXI6IGZ1bmN0aW9uICh1cmkpIHsKICAgIC8vIGZpcnN0IGdldCBhbmNob3IgZnJvbSBwYWdlIGxvY2F0aW9uCgogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIC8vIGNoZWNrIGlmIGFuY2hvciBpcyBlbnRpcmUgcGFnZQogICAgaWYgKGkgPCAwKQogICAgICByZXR1cm4gMDsgIC8vIHllcwoKICAgIHZhciBhbmNob3IgPSB1bmVzY2FwZSh1cmkuc3Vic3RyKGkrMSkpOwoKICAgIC8vIG5vdyB1c2UgYW5jaG9yIGFzIFhNTCBJRCB0byBmaW5kIHRhcmdldAogICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFuY2hvcik7CgogICAgaWYgKCF0YXJnZXQpCiAgICB7CiAgICAgIC8vIGRvZXMgYW5jaG9yIGxvb2sgbGlrZSAiKDIpIiBmb3Igc2xpZGUgMiA/PwogICAgICAvLyB3aGVyZSBmaXJzdCBzbGlkZSBpcyAoMSkKICAgICAgdmFyIHJlID0gL1woKFxkKStcKS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgIHZhciBudW0gPSBwYXJzZUludChhbmNob3Iuc3Vic3RyaW5nKDEsIGFuY2hvci5sZW5ndGgtMSkpOwoKICAgICAgICBpZiAobnVtID4gdGhpcy5zbGlkZXMubGVuZ3RoKQogICAgICAgICAgbnVtID0gMTsKCiAgICAgICAgaWYgKC0tbnVtIDwgMCkKICAgICAgICAgIG51bSA9IDA7CgogICAgICAgIHJldHVybiBudW07CiAgICAgIH0KCiAgICAgIC8vIGFjY2VwdCBbMl0gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5CiAgICAgIHJlID0gL1xbKFxkKStcXS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgICB2YXIgbnVtID0gcGFyc2VJbnQoYW5jaG9yLnN1YnN0cmluZygxLCBhbmNob3IubGVuZ3RoLTEpKTsKCiAgICAgICAgIGlmIChudW0gPiB0aGlzLnNsaWRlcy5sZW5ndGgpCiAgICAgICAgICAgIG51bSA9IDE7CgogICAgICAgICBpZiAoLS1udW0gPCAwKQogICAgICAgICAgICBudW0gPSAwOwoKICAgICAgICAgcmV0dXJuIG51bTsKICAgICAgfQoKICAgICAgLy8gb2ggZGVhciB1bmtub3duIGFuY2hvcgogICAgICByZXR1cm4gMDsKICAgIH0KCiAgICAvLyBzZWFyY2ggZm9yIGVuY2xvc2luZyBzbGlkZQoKICAgIHdoaWxlICh0cnVlKQogICAgewogICAgICAvLyBicm93c2VyIGNvZXJjZXMgaHRtbCBlbGVtZW50cyB0byB1cHBlcmNhc2UhCiAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAiZGl2IiAmJgogICAgICAgICAgICB0aGlzLmhhc19jbGFzcyh0YXJnZXQsICJzbGlkZSIpKQogICAgICB7CiAgICAgICAgLy8gZm91bmQgdGhlIHNsaWRlIGVsZW1lbnQKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgLy8gb3RoZXJ3aXNlIHRyeSBwYXJlbnQgZWxlbWVudCBpZiBhbnkKCiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgaWYgKCF0YXJnZXQpCiAgICAgIHsKICAgICAgICByZXR1cm4gMDsgICAvLyBubyBsdWNrIQogICAgICB9CiAgICB9OwoKICAgIGZvciAoaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGlmIChzbGlkZXNbaV0gPT0gdGFyZ2V0KQogICAgICAgIHJldHVybiBpOyAgLy8gc3VjY2VzcwogICAgfQoKICAgIC8vIG9oIGRlYXIgc3RpbGwgbm8gbHVjawogICAgcmV0dXJuIDA7CiAgfSwKCiAgcHJldmlvdXNfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZTsKCiAgICAgIGlmICgoaW5jcmVtZW50YWwgfHwgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9PSAwKSAmJiB3M2Nfc2xpZHkubGFzdF9zaG93biAhPSBudWxsKQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkuaGlkZV9wcmV2aW91c19pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoZmFsc2UpOwogICAgICB9CiAgICAgIGVsc2UgaWYgKHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgICB7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKCiAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgLSAxOwogICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICBpZiAoIXczY19zbGlkeS5uc19wb3MpCiAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgfQogIH0sCgogIG5leHRfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZSwgbGFzdCA9IHczY19zbGlkeS5sYXN0X3Nob3duOwoKICAgICAgaWYgKGluY3JlbWVudGFsIHx8IHczY19zbGlkeS5zbGlkZV9udW1iZXIgPT0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5yZXZlYWxfbmV4dF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKCiAgICAgIGlmICgoIWluY3JlbWVudGFsIHx8IHczY19zbGlkeS5sYXN0X3Nob3duID09IG51bGwpICYmCiAgICAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgKyAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlIGlmICghdzNjX3NsaWR5Lmxhc3Rfc2hvd24pCiAgICAgIHsKICAgICAgICAgaWYgKGxhc3QgJiYgaW5jcmVtZW50YWwpCiAgICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBsYXN0OwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgIH0KICB9LAoKICAvLyB0byBmaXJzdCBzbGlkZSB3aXRoIG5vdGhpbmcgcmV2ZWFsZWQKICAvLyBpLmUuIHN0YXRlIGF0IHN0YXJ0IG9mIHByZXNlbnRhdGlvbgogIGZpcnN0X3NsaWRlOiBmdW5jdGlvbiAoKSB7CiAgICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICAgewogICAgICAgdmFyIHNsaWRlOwoKICAgICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICE9IDApCiAgICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IDA7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBudWxsOwogICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJoaWRkZW4iKTsKICAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgfQoKICAgICAgIHczY19zbGlkeS5zZXRfZW9zX3N0YXR1cygKICAgICAgICAgIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKICAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgICB9CiAgfSwKCiAgLy8gZ290byBsYXN0IHNsaWRlIHdpdGggZXZlcnl0aGluZyByZXZlYWxlZAogIC8vIGkuZS4gc3RhdGUgYXQgZW5kIG9mIHByZXNlbnRhdGlvbgogIGxhc3Rfc2xpZGU6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdzNjX3NsaWR5LnZpZXdfYWxsKQogICAgewogICAgICB2YXIgc2xpZGU7CgogICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IG51bGw7IC8vcmV2ZWFsTmV4dEl0ZW0obGFzdFNob3duKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkubGFzdF9zaG93biA9PSBudWxsICYmCiAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKCiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgidmlzaWJsZSIpOwogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5wcmV2aW91c19pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgIH0KICB9LAoKCiAgLy8gIyMjIGNoZWNrIHRoaXMgYW5kIGNvbnNpZGVyIGFkZC9yZW1vdmUgY2xhc3MKICBzZXRfZW9zX3N0YXR1czogZnVuY3Rpb24gKHN0YXRlKSB7CiAgICBpZiAodGhpcy5lb3MpCiAgICAgIHRoaXMuZW9zLnN0eWxlLmNvbG9yID0gKHN0YXRlID8gInJnYigyNDAsMjQwLDI0MCkiIDogInJlZCIpOwogIH0sCgogIC8vIGZpcnN0IHNsaWRlIGlzIDAKICBnb3RvX3NsaWRlOiBmdW5jdGlvbiAobnVtKSB7CiAgICAvL2FsZXJ0KCJnb2luZyB0byBzbGlkZSAiICsgKG51bSsxKSk7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IG51bTsKICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoImhpZGRlbiIpOwogICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICBkb2N1bWVudC50aXRsZSA9IHczY19zbGlkeS50aXRsZSArICIgKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlX251bWJlcigpOwogIH0sCgoKICBzaG93X3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuc3luY19iYWNrZ3JvdW5kKHNsaWRlKTsKICAgIHRoaXMucmVtb3ZlX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CgogICAgLy8gd29yayBhcm91bmQgSUU5IG9iamVjdCByZW5kZXJpbmcgYnVnCiAgICBzZXRUaW1lb3V0KCJ3aW5kb3cuc2Nyb2xsVG8oMCwwKTsiLCAxKTsKICB9LAoKICBoaWRlX3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuYWRkX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CiAgfSwKCiAgc2V0X2ZvY3VzOiBmdW5jdGlvbiAoZWxlbWVudCkKICB7CiAgICBpZiAoZWxlbWVudCkKICAgICAgZWxlbWVudC5mb2N1cygpOwogICAgZWxzZQogICAgewogICAgICB3M2Nfc2xpZHkuaGVscF9hbmNob3IuZm9jdXMoKTsKCiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgdzNjX3NsaWR5LmhlbHBfYW5jaG9yLmJsdXIoKTsKICAgICAgfSwgMSk7CiAgICB9CiAgfSwKCiAgLy8gc2hvdyBqdXN0IHRoZSBiYWNrZ3JvdW5kcyBwZXJ0aW5lbnQgdG8gdGhpcyBzbGlkZQogIC8vIHdoZW4gc2xpZGUgYmFja2dyb3VuZC1jb2xvciBpcyB0cmFuc3BhcmVudAogIC8vIHRoaXMgc2hvdWxkIG5vdyB3b3JrIHdpdGggcmdiYSBjb2xvciB2YWx1ZXMKICBzeW5jX2JhY2tncm91bmQ6IGZ1bmN0aW9uIChzbGlkZSkgewogICAgdmFyIGJhY2tncm91bmQ7CiAgICB2YXIgYmdDb2xvcjsKCiAgICBpZiAoc2xpZGUuY3VycmVudFN0eWxlKQogICAgICBiZ0NvbG9yID0gc2xpZGUuY3VycmVudFN0eWxlWyJiYWNrZ3JvdW5kQ29sb3IiXTsKICAgIGVsc2UgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3KQogICAgewogICAgICB2YXIgc3R5bGVzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSxudWxsKTsKCiAgICAgIGlmIChzdHlsZXMpCiAgICAgICAgYmdDb2xvciA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWNvbG9yIik7CiAgICAgIGVsc2UgLy8gYnJva2VuIGltcGxlbWVudGF0aW9uIHByb2JhYmx5IGR1ZSBTYWZhcmkgb3IgS29ucXVlcm9yCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJkZWZlY3RpdmUgaW1wbGVtZW50YXRpb24gb2YgZ2V0Q29tcHV0ZWRTdHlsZSgpIik7CiAgICAgICAgYmdDb2xvciA9ICJ0cmFuc3BhcmVudCI7CiAgICAgIH0KICAgIH0KICAgIGVsc2UKICAgICAgYmdDb2xvciA9PSAidHJhbnNwYXJlbnQiOwoKICAgIGlmIChiZ0NvbG9yID09ICJ0cmFuc3BhcmVudCIgfHwKICAgICAgICBiZ0NvbG9yLmluZGV4T2YoInJnYmEiKSA+PSAwIHx8CiAgICAgICAgYmdDb2xvci5pbmRleE9mKCJvcGFjaXR5IikgPj0gMCkKICAgIHsKICAgICAgdmFyIHNsaWRlQ2xhc3MgPSB0aGlzLmdldF9jbGFzc19saXN0KHNsaWRlKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgICAgewogICAgICAgIGJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmRzW2ldOwoKICAgICAgICB2YXIgYmdDbGFzcyA9IHRoaXMuZ2V0X2NsYXNzX2xpc3QoYmFja2dyb3VuZCk7CgogICAgICAgIGlmICh0aGlzLm1hdGNoaW5nX2JhY2tncm91bmQoc2xpZGVDbGFzcywgYmdDbGFzcykpCiAgICAgICAgICB0aGlzLnJlbW92ZV9jbGFzcyhiYWNrZ3JvdW5kLCAiaGlkZGVuIik7CiAgICAgICAgZWxzZQogICAgICAgICAgdGhpcy5hZGRfY2xhc3MoYmFja2dyb3VuZCwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CiAgICBlbHNlIC8vIGZvcmNpYmx5IGhpZGUgYWxsIGJhY2tncm91bmRzCiAgICAgIHRoaXMuaGlkZV9iYWNrZ3JvdW5kcygpOwogIH0sCgogIGhpZGVfYmFja2dyb3VuZHM6IGZ1bmN0aW9uICgpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZHNbaV07CiAgICAgIHRoaXMuYWRkX2NsYXNzKGJhY2tncm91bmQsICJoaWRkZW4iKTsKICAgIH0KICB9LAoKICAvLyBjb21wYXJlIGNsYXNzZXMgZm9yIHNsaWRlIGFuZCBiYWNrZ3JvdW5kCiAgbWF0Y2hpbmdfYmFja2dyb3VuZDogZnVuY3Rpb24gKHNsaWRlQ2xhc3MsIGJnQ2xhc3MpIHsKICAgIHZhciBpLCBjb3VudCwgcGF0dGVybiwgcmVzdWx0OwoKICAgIC8vIGRlZmluZSBwYXR0ZXJuIGFzIHJlZ3VsYXIgZXhwcmVzc2lvbgogICAgcGF0dGVybiA9IC9cdysvZzsKCiAgICAvLyBjaGVjayBiYWNrZ3JvdW5kIGNsYXNzIG5hbWVzCiAgICByZXN1bHQgPSBiZ0NsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIGZvciAoaSA9IGNvdW50ID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgaWYgKHJlc3VsdFtpXSA9PSAiaGlkZGVuIikKICAgICAgICBjb250aW51ZTsKCiAgICAgIGlmIChyZXN1bHRbaV0gPT0gImJhY2tncm91bmQiKQoJY29udGludWU7CgogICAgICArK2NvdW50OwogICAgfQoKICAgIGlmIChjb3VudCA9PSAwKSAgLy8gZGVmYXVsdCBtYXRjaAogICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBjaGVjayBmb3IgbWF0Y2hlcyBhbmQgcGxhY2UgcmVzdWx0IGluIGFycmF5CiAgICByZXN1bHQgPSBzbGlkZUNsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIC8vIG5vdyBjaGVjayBpZiBkZXNpcmVkIG5hbWUgaXMgcHJlc2VudCBmb3IgYmFja2dyb3VuZAogICAgZm9yIChpID0gY291bnQgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKQogICAgewogICAgICBpZiAocmVzdWx0W2ldID09ICJoaWRkZW4iKQogICAgICAgIGNvbnRpbnVlOwoKICAgICAgaWYgKHRoaXMuaGFzX3Rva2VuKGJnQ2xhc3MsIHJlc3VsdFtpXSkpCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIHJlc2l6ZWQ6IGZ1bmN0aW9uICgpIHsKICAgICB2YXIgd2lkdGggPSAwOwoKICAgICBpZiAoIHR5cGVvZiggd2luZG93LmlubmVyV2lkdGggKSA9PSAnbnVtYmVyJyApCiAgICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoOyAgLy8gTm9uIElFIGJyb3dzZXIKICAgICBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKQogICAgICAgd2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7ICAvLyBJRTYKICAgICBlbHNlIGlmIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpCiAgICAgICB3aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7IC8vIElFNAoKICAgICB2YXIgaGVpZ2h0ID0gMDsKCiAgICAgaWYgKCB0eXBlb2YoIHdpbmRvdy5pbm5lckhlaWdodCApID09ICdudW1iZXInICkKICAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDsgIC8vIE5vbiBJRSBicm93c2VyCiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpCiAgICAgICBoZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OyAgLy8gSUU2CiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkKICAgICAgIGhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBJRTQKCiAgICAgaWYgKGhlaWdodCAmJiAod2lkdGgvaGVpZ2h0ID4gMS4wNSoxMDI0Lzc2OCkpCiAgICAgewogICAgICAgd2lkdGggPSBoZWlnaHQgKiAxMDI0LjAvNzY4OwogICAgIH0KCiAgICAgLy8gSUUgZmlyZXMgb25yZXNpemUgZXZlbiB3aGVuIG9ubHkgZm9udCBzaXplIGlzIGNoYW5nZWQhCiAgICAgLy8gc28gd2UgZG8gYSBjaGVjayB0byBhdm9pZCBibG9ja2luZyA8IGFuZCA+IGFjdGlvbnMKICAgICBpZiAod2lkdGggIT0gdzNjX3NsaWR5Lmxhc3Rfd2lkdGggfHwgaGVpZ2h0ICE9IHczY19zbGlkeS5sYXN0X2hlaWdodCkKICAgICB7CiAgICAgICBpZiAod2lkdGggPj0gMTEwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSA1OyAgICAvLyA0CiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSAxMDAwKQogICAgICAgICB3M2Nfc2xpZHkuc2l6ZV9pbmRleCA9IDQ7ICAgIC8vIDMKICAgICAgIGVsc2UgaWYgKHdpZHRoID49IDgwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSAzOyAgICAvLyAyCiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSA2MDApCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMjsgICAgLy8gMQogICAgICAgZWxzZSBpZiAod2lkdGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMDsKCiAgICAgICAvLyBhZGQgaW4gZm9udCBzaXplIGFkanVzdG1lbnQgZnJvbSBtZXRhIGVsZW1lbnQgZS5nLgogICAgICAgLy8gPG1ldGEgbmFtZT0iZm9udC1zaXplLWFkanVzdG1lbnQiIGNvbnRlbnQ9Ii0yIiAvPgogICAgICAgLy8gdXNlZnVsIHdoZW4gc2xpZGVzIGhhdmUgdG9vIG11Y2ggY29udGVudCA7LSkKCiAgICAgICBpZiAoMCA8PSB3M2Nfc2xpZHkuc2l6ZV9pbmRleCArIHczY19zbGlkeS5zaXplX2FkanVzdG1lbnQgJiYKICAgICAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ICsgdzNjX3NsaWR5LnNpemVfYWRqdXN0bWVudCA8IHczY19zbGlkeS5zaXplcy5sZW5ndGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gdzNjX3NsaWR5LnNpemVfaW5kZXggKyB3M2Nfc2xpZHkuc2l6ZV9hZGp1c3RtZW50OwoKICAgICAgIC8vIGVuYWJsZXMgY3Jvc3MgYnJvd3NlciB1c2Ugb2YgcmVsYXRpdmUgd2lkdGgvaGVpZ2h0CiAgICAgICAvLyBvbiBvYmplY3QgZWxlbWVudHMgZm9yIHVzZSB3aXRoIFNWRyBhbmQgRmxhc2ggbWVkaWEKICAgICAgIHczY19zbGlkeS5hZGp1c3Rfb2JqZWN0X2RpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7CgogICAgICAgaWYgKGRvY3VtZW50LmJvZHkuc3R5bGUuZm9udFNpemUgIT0gdzNjX3NsaWR5LnNpemVzW3czY19zbGlkeS5zaXplX2luZGV4XSkKICAgICAgIHsKICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICAgICB9CgogICAgICAgdzNjX3NsaWR5Lmxhc3Rfd2lkdGggPSB3aWR0aDsKICAgICAgIHczY19zbGlkeS5sYXN0X2hlaWdodCA9IGhlaWdodDsKCiAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gd29yayBhcm91bmQgTW96aWxsYSBidWcKICAgICAgIGlmICh3M2Nfc2xpZHkubnNfcG9zKQogICAgICAgewogICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgIH0KCiAgICAgICAvLyBmb3JjZSBjb3JyZWN0IHBvc2l0aW9uaW5nIG9mIHRvb2xiYXIKICAgICAgIHczY19zbGlkeS5yZWZyZXNoX3Rvb2xiYXIoMjAwKTsKICAgICB9CiAgfSwKCiAgc2Nyb2xsZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkudG9vbGJhciAmJiAhdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhhY2tfb2Zmc2V0ID0gdzNjX3NsaWR5LnNjcm9sbF94X29mZnNldCgpOwogICAgICAvLyBoaWRlIHRvb2xiYXIKICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUuZGlzcGxheSA9ICJub25lIjsKCiAgICAgIC8vIG1ha2UgaXQgcmVhcHBlYXIgbGF0ZXIKICAgICAgaWYgKHczY19zbGlkeS5zY3JvbGxoYWNrID09IDAgJiYgIXczY19zbGlkeS52aWV3X2FsbCkKICAgICAgewogICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge3czY19zbGlkeS5zaG93X3Rvb2xiYXIoKTsgfSwgMTAwMCk7CiAgICAgICAgdzNjX3NsaWR5LnNjcm9sbGhhY2sgPSAxOwogICAgICB9CiAgICB9CiAgfSwKCiAgaGlkZV90b29sYmFyOiBmdW5jdGlvbiAoKSB7CiAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b29sYmFyLCAiaGlkZGVuIik7CiAgICB3aW5kb3cuZm9jdXMoKTsKICB9LAoKICAvLyB1c2VkIHRvIGVuc3VyZSBJRSByZWZyZXNoZXMgdG9vbGJhciBpbiBjb3JyZWN0IHBvc2l0aW9uCiAgcmVmcmVzaF90b29sYmFyOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHsKICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhpZGVfdG9vbGJhcigpOwogICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHt3M2Nfc2xpZHkuc2hvd190b29sYmFyKCk7fSwgaW50ZXJ2YWwpOwogICAgfQogIH0sCgogIC8vIHJlc3RvcmVzIHRvb2xiYXIgYWZ0ZXIgc2hvcnQgZGVsYXkKICBzaG93X3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkud2FudF90b29sYmFyKQogICAgewogICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgewogICAgICAgIC8vIGFkanVzdCBwb3NpdGlvbiB0byBhbGxvdyBmb3Igc2Nyb2xsaW5nCiAgICAgICAgdmFyIHhvZmZzZXQgPSB3M2Nfc2xpZHkuc2Nyb2xsX3hfb2Zmc2V0KCk7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUubGVmdCA9IHhvZmZzZXQ7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUucmlnaHQgPSB4b2Zmc2V0OwoKICAgICAgICAvLyBkZXRlcm1pbmUgdmVydGljYWwgc2Nyb2xsIG9mZnNldAogICAgICAgIC8vdmFyIHlvZmZzZXQgPSBzY3JvbGxZT2Zmc2V0KCk7CgogICAgICAgIC8vIGJvdHRvbSBpcyBkb2MgaGVpZ2h0IC0gd2luZG93IGhlaWdodCAtIHNjcm9sbCBvZmZzZXQKICAgICAgICAvL3ZhciBib3R0b20gPSBkb2N1bWVudEhlaWdodCgpIC0gbGFzdEhlaWdodCAtIHlvZmZzZXQKCiAgICAgICAgLy9pZiAoeW9mZnNldCA+IDAgfHwgZG9jdW1lbnRIZWlnaHQoKSA+IGxhc3RIZWlnaHQpCiAgICAgICAgLy8gICBib3R0b20gKz0gMTY7ICAvLyBhbGxvdyBmb3IgaGVpZ2h0IG9mIHNjcm9sbGJhcgoKICAgICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5ib3R0b20gPSAwOyAvL2JvdHRvbTsKICAgICAgfQoKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpOwogICAgfQoKICAgIHczY19zbGlkeS5zY3JvbGxoYWNrID0gMDsKCgogICAgLy8gc2V0IHRoZSBrZXlib2FyZCBmb2N1cyB0byB0aGUgaGVscCBsaW5rIG9uIHRoZQogICAgLy8gdG9vbGJhciB0byBlbnN1cmUgdGhhdCBkb2N1bWVudCBoYXMgdGhlIGZvY3VzCiAgICAvLyBJRSBkb2Vzbid0IGFsd2F5cyB3b3JrIHdpdGggd2luZG93LmZvY3VzKCkKICAgIC8vIGFuZCB0aGlzIGhhY2sgaGFzIGJlbmVmaXQgb2YgRW50ZXIgZm9yIGhlbHAKCiAgICB0cnkKICAgIHsKICAgICAgaWYgKCF3M2Nfc2xpZHkub3BlcmEpCiAgICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogICAgfQogICAgY2F0Y2ggKGUpCiAgICB7CiAgICB9CiAgfSwKCi8vIGludm9rZWQgdmlhIEYga2V5CiAgdG9nZ2xlX3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdzNjX3NsaWR5LnZpZXdfYWxsKQogICAgewogICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpKQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgICAgdzNjX3NsaWR5LndhbnRfdG9vbGJhciA9IDE7CiAgICAgIH0KICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5LmFkZF9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgICAgdzNjX3NsaWR5LndhbnRfdG9vbGJhciA9IDA7CiAgICAgIH0KICAgIH0KICB9LAoKICBzY3JvbGxfeF9vZmZzZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3aW5kb3cucGFnZVhPZmZzZXQpCiAgICAgIHJldHVybiBzZWxmLnBhZ2VYT2Zmc2V0OwoKICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgCiAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0OwoKICAgIGlmIChkb2N1bWVudC5ib2R5KQogICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0OwoKICAgIHJldHVybiAwOwogIH0sCgogIHNjcm9sbF95X29mZnNldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCkKICAgICAgcmV0dXJuIHNlbGYucGFnZVlPZmZzZXQ7CgogICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAKICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApCiAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wOwoKICAgIGlmIChkb2N1bWVudC5ib2R5KQogICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7CgogICAgcmV0dXJuIDA7CiAgfSwKCiAgLy8gbG9va2luZyBmb3IgYSB3YXkgdG8gZGV0ZXJtaW5lIGhlaWdodCBvZiBzbGlkZSBjb250ZW50CiAgLy8gdGhlIHNsaWRlIGl0c2VsZiBpcyBzZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgd2luZG93CiAgb3B0aW1pemVfZm9udF9zaXplOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIC8vdmFyIGRoID0gZG9jdW1lbnRIZWlnaHQoKTsgLy9nZXREb2NIZWlnaHQoZG9jdW1lbnQpOwogICAgdmFyIGRoID0gc2xpZGUuc2Nyb2xsSGVpZ2h0OwogICAgdmFyIHdoID0gZ2V0V2luZG93SGVpZ2h0KCk7CiAgICB2YXIgdSA9IDEwMCAqIGRoIC8gd2g7CgogICAgYWxlcnQoIndpbmRvdyB1dGlsaXphdGlvbiA9ICIgKyB1ICsgIiUgKGRvYyAiCiAgICAgICsgZGggKyAiIHdpbiAiICsgd2ggKyAiKSIpOwogIH0sCgogIC8vIGZyb20gZG9jdW1lbnQgb2JqZWN0CiAgZ2V0X2RvY19oZWlnaHQ6IGZ1bmN0aW9uIChkb2MpIHsKICAgIGlmICghZG9jKQogICAgICBkb2MgPSBkb2N1bWVudDsKCiAgICBpZiAoZG9jICYmIGRvYy5ib2R5ICYmIGRvYy5ib2R5Lm9mZnNldEhlaWdodCkKICAgICAgcmV0dXJuIGRvYy5ib2R5Lm9mZnNldEhlaWdodDsgIC8vIG5zL2dlY2tvIHN5bnRheAoKICAgIGlmIChkb2MgJiYgZG9jLmJvZHkgJiYgZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0KQogICAgICByZXR1cm4gZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0OwoKICAgIGFsZXJ0KCJjb3VsZG4ndCBkZXRlcm1pbmUgZG9jdW1lbnQgaGVpZ2h0Iik7CiAgfSwKCiAgZ2V0X3dpbmRvd19oZWlnaHQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICggdHlwZW9mKCB3aW5kb3cuaW5uZXJIZWlnaHQgKSA9PSAnbnVtYmVyJyApCiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7ICAvLyBOb24gSUUgYnJvd3NlcgoKICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7ICAvLyBJRTYKCiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBJRTQKICB9LAoKICBkb2N1bWVudF9oZWlnaHQ6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzaCwgb2g7CgogICAgc2ggPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodDsKICAgIG9oID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7CgogICAgaWYgKHNoICYmIG9oKQogICAgewogICAgICByZXR1cm4gKHNoID4gb2ggPyBzaCA6IG9oKTsKICAgIH0KCiAgICAvLyBubyBpZGVhIQogICAgcmV0dXJuIDA7CiAgfSwKCiAgc21hbGxlcjogZnVuY3Rpb24gKCkgewogICAgaWYgKHczY19zbGlkeS5zaXplX2luZGV4ID4gMCkKICAgIHsKICAgICAgLS13M2Nfc2xpZHkuc2l6ZV9pbmRleDsKICAgIH0KCiAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwogICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7dzNjX3NsaWR5LnNob3dfdG9vbGJhcigpOyB9LCA1MCk7CiAgfSwKCiAgYmlnZ2VyOiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodzNjX3NsaWR5LnNpemVfaW5kZXggPCB3M2Nfc2xpZHkuc2l6ZXMubGVuZ3RoIC0gMSkKICAgIHsKICAgICAgKyt3M2Nfc2xpZHkuc2l6ZV9pbmRleDsKICAgIH0KCiAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwogICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7dzNjX3NsaWR5LnNob3dfdG9vbGJhcigpOyB9LCA1MCk7CiAgfSwKCiAgLy8gZW5hYmxlcyBjcm9zcyBicm93c2VyIHVzZSBvZiByZWxhdGl2ZSB3aWR0aC9oZWlnaHQKICAvLyBvbiBvYmplY3QgZWxlbWVudHMgZm9yIHVzZSB3aXRoIFNWRyBhbmQgRmxhc2ggbWVkaWEKICAvLyB3aXRoIHRoYW5rcyB0byBJdmFuIEhlcm1hbiBmb3IgdGhlIHN1Z2dlc3Rpb24KICBhZGp1c3Rfb2JqZWN0X2RpbWVuc2lvbnM6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7CiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHczY19zbGlkeS5vYmplY3RzLmxlbmd0aDsgaSsrICkKICAgIHsKICAgICAgdmFyIG9iaiA9IHRoaXMub2JqZWN0c1tpXTsKICAgICAgdmFyIG1pbWVUeXBlID0gb2JqLmdldEF0dHJpYnV0ZSgidHlwZSIpOwoKICAgICAgaWYgKG1pbWVUeXBlID09ICJpbWFnZS9zdmcreG1sIiB8fCBtaW1lVHlwZSA9PSAiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2giKQogICAgICB7CiAgICAgICAgaWYgKCAhb2JqLmluaXRpYWxXaWR0aCApIAogICAgICAgICAgb2JqLmluaXRpYWxXaWR0aCA9IG9iai5nZXRBdHRyaWJ1dGUoIndpZHRoIik7CgogICAgICAgIGlmICggIW9iai5pbml0aWFsSGVpZ2h0ICkgCiAgICAgICAgICBvYmouaW5pdGlhbEhlaWdodCA9IG9iai5nZXRBdHRyaWJ1dGUoImhlaWdodCIpOwoKICAgICAgICBpZiAoIG9iai5pbml0aWFsV2lkdGggJiYgb2JqLmluaXRpYWxXaWR0aC5jaGFyQXQob2JqLmluaXRpYWxXaWR0aC5sZW5ndGgtMSkgPT0gIiUiICkKICAgICAgICB7CiAgICAgICAgICB2YXIgdyA9IHBhcnNlSW50KG9iai5pbml0aWFsV2lkdGguc2xpY2UoMCwgb2JqLmluaXRpYWxXaWR0aC5sZW5ndGgtMSkpOwogICAgICAgICAgdmFyIG5ld1cgPSB3aWR0aCAqICh3LzEwMC4wKTsKICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoIndpZHRoIixuZXdXKTsKICAgICAgICB9CgogICAgICAgIGlmICggb2JqLmluaXRpYWxIZWlnaHQgJiYKICAgICAgICAgICAgIG9iai5pbml0aWFsSGVpZ2h0LmNoYXJBdChvYmouaW5pdGlhbEhlaWdodC5sZW5ndGgtMSkgPT0gIiUiICkKICAgICAgICB7CiAgICAgICAgICB2YXIgaCA9IHBhcnNlSW50KG9iai5pbml0aWFsSGVpZ2h0LnNsaWNlKDAsIG9iai5pbml0aWFsSGVpZ2h0Lmxlbmd0aC0xKSk7CiAgICAgICAgICB2YXIgbmV3SCA9IGhlaWdodCAqIChoLzEwMC4wKTsKICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIG5ld0gpOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0sCgogIC8vIG5lZWRlZCBmb3IgT3BlcmEgdG8gaW5oaWJpdCBkZWZhdWx0IGJlaGF2aW9yCiAgLy8gc2luY2UgT3BlcmEgZGVsaXZlcnMga2V5UHJlc3MgZXZlbiBpZiBrZXlEb3duCiAgLy8gd2FzIGNhbmNlbGxlZAogIGtleV9wcmVzczogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBpZiAoIWV2ZW50KQogICAgICBldmVudCA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoIXczY19zbGlkeS5rZXlfd2FudGVkKQogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgLy8gIFNlZSBlLmcuIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzL2tleXMuaHRtbCBmb3Iga2V5Y29kZXMKICBrZXlfZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICB2YXIga2V5LCB0YXJnZXQsIHRhZzsKCiAgICB3M2Nfc2xpZHkua2V5X3dhbnRlZCA9IHRydWU7CgogICAgaWYgKCFldmVudCkKICAgICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh3aW5kb3cuZXZlbnQpCiAgICB7CiAgICAgIGtleSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlOwogICAgICB0YXJnZXQgPSB3aW5kb3cuZXZlbnQuc3JjRWxlbWVudDsKICAgIH0KICAgIGVsc2UgaWYgKGV2ZW50LndoaWNoKQogICAgewogICAgICBrZXkgPSBldmVudC53aGljaDsKICAgICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OwogICAgfQogICAgZWxzZQogICAgICByZXR1cm4gdHJ1ZTsgLy8gWWlrZXMhIHVua25vd24gYnJvd3NlcgoKICAgIC8vIGlnbm9yZSBldmVudCBpZiBrZXkgdmFsdWUgaXMgemVybwogICAgLy8gYXMgZm9yIGFsdCBvbiBPcGVyYSBhbmQgS29ucXVlcm9yCiAgICBpZiAoIWtleSkKICAgICAgIHJldHVybiB0cnVlOwoKICAgIC8vIGF2b2lkIGludGVyZmVyaW5nIHdpdGgga2V5c3Ryb2tlCiAgICAvLyBiZWhhdmlvciBmb3Igbm9uLXNsaWR5IGNocm9tZSBlbGVtZW50cwogICAgaWYgKCF3M2Nfc2xpZHkuc2xpZHlfY2hyb21lKHRhcmdldCkgJiYKICAgICAgICB3M2Nfc2xpZHkuc3BlY2lhbF9lbGVtZW50KHRhcmdldCkpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIC8vIGNoZWNrIGZvciBjb25jdXJyZW50IGNvbnRyb2wvY29tbWFuZC9hbHQga2V5CiAgICAvLyBidXQgYXJlIHRoZXNlIG9ubHkgcHJlc2VudCBvbiBtb3VzZSBldmVudHM/CgogICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpCiAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBkaXNtaXNzIHRhYmxlIG9mIGNvbnRlbnRzIGlmIHZpc2libGUKICAgIGlmICh3M2Nfc2xpZHkuaXNfc2hvd25fdG9jKCkgJiYga2V5ICE9IDkgJiYga2V5ICE9IDE2ICYmIGtleSAhPSAzOCAmJiBrZXkgIT0gNDApCiAgICB7CiAgICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKHRydWUpOwoKICAgICAgaWYgKGtleSA9PSAyNyB8fCBrZXkgPT0gODQgfHwga2V5ID09IDY3KQogICAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KCiAgICBpZiAoa2V5ID09IDM0KSAvLyBQYWdlIERvd24KICAgIHsKICAgICAgaWYgKHczY19zbGlkeS52aWV3X2FsbCkKICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKGZhbHNlKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDMzKSAvLyBQYWdlIFVwCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkudmlld19hbGwpCiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICB3M2Nfc2xpZHkucHJldmlvdXNfc2xpZGUoZmFsc2UpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzIpIC8vIHNwYWNlIGJhcgogICAgewogICAgICB3M2Nfc2xpZHkubmV4dF9zbGlkZSh0cnVlKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDM3KSAvLyBMZWZ0IGFycm93CiAgICB7CiAgICAgIHczY19zbGlkeS5wcmV2aW91c19zbGlkZSghZXZlbnQuc2hpZnRLZXkpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzYpIC8vIEhvbWUKICAgIHsKICAgICAgdzNjX3NsaWR5LmZpcnN0X3NsaWRlKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzNSkgLy8gRW5kCiAgICB7CiAgICAgIHczY19zbGlkeS5sYXN0X3NsaWRlKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzOSkgLy8gUmlnaHQgYXJyb3cKICAgIHsKICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUoIWV2ZW50LnNoaWZ0S2V5KTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDEzKSAvLyBFbnRlcgogICAgewogICAgICBpZiAodzNjX3NsaWR5Lm91dGxpbmUpCiAgICAgIHsKICAgICAgICBpZiAodzNjX3NsaWR5Lm91dGxpbmUudmlzaWJsZSkKICAgICAgICAgIHczY19zbGlkeS5mb2xkKHczY19zbGlkeS5vdXRsaW5lKTsKICAgICAgICBlbHNlCiAgICAgICAgICB3M2Nfc2xpZHkudW5mb2xkKHczY19zbGlkeS5vdXRsaW5lKTsKICAgICAgICAgIAogICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgICB9CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTg4KSAgLy8gPCBmb3Igc21hbGxlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuc21hbGxlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTkwKSAgLy8gPiBmb3IgbGFyZ2VyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5iaWdnZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDE4OSB8fCBrZXkgPT0gMTA5KSAgLy8gLSBmb3Igc21hbGxlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuc21hbGxlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTg3IHx8IGtleSA9PSAxOTEgfHwga2V5ID09IDEwNykgIC8vID0gKyAgZm9yIGxhcmdlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuYmlnZ2VyKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA4MykgIC8vIFMgZm9yIHNtYWxsZXIgZm9udHMKICAgIHsKICAgICAgdzNjX3NsaWR5LnNtYWxsZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDY2KSAgLy8gQiBmb3IgbGFyZ2VyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5iaWdnZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDkwKSAgLy8gWiBmb3IgbGFzdCBzbGlkZQogICAgewogICAgICB3M2Nfc2xpZHkubGFzdF9zbGlkZSgpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gNzApICAvLyBGIGZvciB0b2dnbGUgdG9vbGJhcgogICAgewogICAgICB3M2Nfc2xpZHkudG9nZ2xlX3Rvb2xiYXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDY1KSAgLy8gQSBmb3IgdG9nZ2xlIHZpZXcgc2luZ2xlL2FsbCBzbGlkZXMKICAgIHsKICAgICAgdzNjX3NsaWR5LnRvZ2dsZV92aWV3KCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA3NSkgIC8vIHRvZ2dsZSBhY3Rpb24gb2YgbGVmdCBjbGljayBmb3IgbmV4dCBwYWdlCiAgICB7CiAgICAgIHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkID0gIXczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkOwogICAgICB2YXIgYWxlcnRfbXNnID0gKHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkID8KICAgICAgICAgICAgICAgICJlbmFibGVkIiA6ICJkaXNhYmxlZCIpICsgICIgbW91c2UgY2xpY2sgYWR2YW5jZSI7CgogICAgICBhbGVydCh3M2Nfc2xpZHkubG9jYWxpemUoYWxlcnRfbXNnKSk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA4NCB8fCBrZXkgPT0gNjcpICAvLyBUIG9yIEMgZm9yIHRhYmxlIG9mIGNvbnRlbnRzCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkudG9jKQogICAgICAgIHczY19zbGlkeS50b2dnbGVfdGFibGVfb2ZfY29udGVudHMoKTsKCiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA3MikgLy8gSCBmb3IgaGVscAogICAgewogICAgICB3aW5kb3cubG9jYXRpb24gPSB3M2Nfc2xpZHkuaGVscF9wYWdlOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICAvL2Vsc2UgYWxlcnQoImtleSBjb2RlIGlzICIrIGtleSk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgLy8gc2FmZSBmb3IgYm90aCB0ZXh0L2h0bWwgYW5kIGFwcGxpY2F0aW9uL3hodG1sK3htbAogIGNyZWF0ZV9lbGVtZW50OiBmdW5jdGlvbiAobmFtZSkgewogICAgaWYgKHRoaXMueGh0bWwgJiYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgIT0gJ3VuZGVmaW5lZCcpKQogICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwgbmFtZSkKCiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTsKICB9LAoKICBnZXRfZWxlbWVudF9zdHlsZTogZnVuY3Rpb24gKGVsZW0sIElFU3R5bGVQcm9wLCBDU1NTdHlsZVByb3ApIHsKICAgIGlmIChlbGVtLmN1cnJlbnRTdHlsZSkKICAgIHsKICAgICAgcmV0dXJuIGVsZW0uY3VycmVudFN0eWxlW0lFU3R5bGVQcm9wXTsKICAgIH0KICAgIGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKQogICAgewogICAgICB2YXIgY29tcFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgIiIpOwogICAgICByZXR1cm4gY29tcFN0eWxlLmdldFByb3BlcnR5VmFsdWUoQ1NTU3R5bGVQcm9wKTsKICAgIH0KICAgIHJldHVybiAiIjsKICB9LAoKICAvLyB0aGUgc3RyaW5nIHN0ciBpcyBhIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdG9rZW5zCiAgLy8gdGVzdCBpZiBzdHIgY29udGFpbnMgYSBwYXJ0aWN1bGFyIHRva2VuLCBlLmcuICJzbGlkZSIKICBoYXNfdG9rZW46IGZ1bmN0aW9uIChzdHIsIHRva2VuKSB7CiAgICBpZiAoc3RyKQogICAgewogICAgICAvLyBkZWZpbmUgcGF0dGVybiBhcyByZWd1bGFyIGV4cHJlc3Npb24KICAgICAgdmFyIHBhdHRlcm4gPSAvXHcrL2c7CgogICAgICAvLyBjaGVjayBmb3IgbWF0Y2hlcwogICAgICAvLyBwbGFjZSByZXN1bHQgaW4gYXJyYXkKICAgICAgdmFyIHJlc3VsdCA9IHN0ci5tYXRjaChwYXR0ZXJuKTsKCiAgICAgIC8vIG5vdyBjaGVjayBpZiBkZXNpcmVkIHRva2VuIGlzIHByZXNlbnQKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspCiAgICAgIHsKICAgICAgICBpZiAocmVzdWx0W2ldID09IHRva2VuKQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfSwKCiAgZ2V0X2NsYXNzX2xpc3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7CiAgICBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lICE9ICd1bmRlZmluZWQnKQogICAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWU7CgogICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjbGFzcyIpOwogIH0sCgogIGhhc19jbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsKICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBmYWxzZTsKCiAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgiKF58ICkiICsgbmFtZSArICJcVyoiKTsKCiAgICBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lICE9ICd1bmRlZmluZWQnKQogICAgICByZXR1cm4gcmVnZXhwLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpOwoKICAgIHJldHVybiByZWdleHAudGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgiY2xhc3MiKSk7CiAgfSwKCiAgcmVtb3ZlX2NsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgewogICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoIihefCApIiArIG5hbWUgKyAiXFcqIik7CiAgICB2YXIgY2xzdmFsID0gIiI7CgogICAgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSAhPSAndW5kZWZpbmVkJykKICAgIHsKICAgICAgY2xzdmFsID0gZWxlbWVudC5jbGFzc05hbWU7CgogICAgICBpZiAoY2xzdmFsKQogICAgICB7CiAgICAgICAgY2xzdmFsID0gY2xzdmFsLnJlcGxhY2UocmVnZXhwLCAiIik7CiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbHN2YWw7CiAgICAgIH0KICAgIH0KICAgIGVsc2UKICAgIHsKICAgICAgY2xzdmFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoImNsYXNzIik7CgogICAgICBpZiAoY2xzdmFsKQogICAgICB7CiAgICAgICAgY2xzdmFsID0gY2xzdmFsLnJlcGxhY2UocmVnZXhwLCAiIik7CiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgY2xzdmFsKTsKICAgICAgfQogICAgfQogIH0sCgogIGFkZF9jbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsKICAgIGlmICghdGhpcy5oYXNfY2xhc3MoZWxlbWVudCwgbmFtZSkpCiAgICB7CiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgIT0gJ3VuZGVmaW5lZCcpCiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gIiAiICsgbmFtZTsKICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdmFyIGNsc3ZhbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjbGFzcyIpOwogICAgICAgIGNsc3ZhbCA9IGNsc3ZhbCA/IGNsc3ZhbCArICIgIiArIG5hbWUgOiBuYW1lOwogICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCJjbGFzcyIsIGNsc3ZhbCk7CiAgICAgIH0KICAgIH0KICB9LAoKICAvLyBIVE1MIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBjbGFzcz0iaW5jcmVtZW50YWwiCiAgLy8gbm90ZSB0aGF0IHlvdSBjYW4gYWxzbyBwdXQgdGhlIGNsYXNzIG9uIGNvbnRhaW5lcnMgbGlrZQogIC8vIHVwLCBvbCwgZGwsIGFuZCBkaXYgdG8gbWFrZSB0aGVpciBjb250ZW50cyBhcHBlYXIKICAvLyBpbmNyZW1lbnRhbGx5LiBVcHBlciBjYXNlIGlzIHVzZWQgc2luY2UgdGhpcyBpcyB3aGF0CiAgLy8gYnJvd3NlcnMgcmVwb3J0IGZvciBIVE1MIG5vZGUgbmFtZXMgKHRleHQvaHRtbCkuCiAgaW5jcmVtZW50YWxfZWxlbWVudHM6IG51bGwsCiAgb2theV9mb3JfaW5jcmVtZW50YWw6IGZ1bmN0aW9uIChuYW1lKSB7CiAgICBpZiAoIXRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHMpCiAgICB7CiAgICAgIHZhciBpbmNsaXN0ID0gbmV3IEFycmF5KCk7CiAgICAgIGluY2xpc3RbInAiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInByZSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsibGkiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImJsb2NrcXVvdGUiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImR0Il0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJkZCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDIiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImgzIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJoNCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDUiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImg2Il0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJzcGFuIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJhZGRyZXNzIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJ0YWJsZSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsidHIiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInRoIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJ0ZCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaW1nIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJvYmplY3QiXSA9IHRydWU7CiAgICAgIHRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHMgPSBpbmNsaXN0OwogICAgfQogICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHNbbmFtZS50b0xvd2VyQ2FzZSgpXTsKICB9LAoKICBuZXh0X2luY3JlbWVudGFsX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICB2YXIgYnIgPSB0aGlzLmlzX3hodG1sID8gImJyIiA6ICJCUiI7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSB3M2Nfc2xpZHkubmV4dF9ub2RlKHNsaWRlLCBub2RlKTsKCiAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS5wYXJlbnROb2RlID09IG51bGwpCiAgICAgICAgYnJlYWs7CgogICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSAgLy8gRUxFTUVOVAogICAgICB7CiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gYnIpCiAgICAgICAgICBjb250aW51ZTsKCiAgICAgICAgaWYgKHczY19zbGlkeS5oYXNfY2xhc3Mobm9kZSwgImluY3JlbWVudGFsIikKICAgICAgICAgICAgICYmIHczY19zbGlkeS5va2F5X2Zvcl9pbmNyZW1lbnRhbChub2RlLm5vZGVOYW1lKSkKICAgICAgICAgIHJldHVybiBub2RlOwoKICAgICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLnBhcmVudE5vZGUsICJpbmNyZW1lbnRhbCIpCiAgICAgICAgICAgICAmJiAhdzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLCAibm9uLWluY3JlbWVudGFsIikpCiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBub2RlOwogIH0sCgogIHByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICB2YXIgYnIgPSB0aGlzLmlzX3hodG1sID8gImJyIiA6ICJCUiI7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSB3M2Nfc2xpZHkucHJldmlvdXNfbm9kZShzbGlkZSwgbm9kZSk7CgogICAgICBpZiAobm9kZSA9PSBudWxsIHx8IG5vZGUucGFyZW50Tm9kZSA9PSBudWxsKQogICAgICAgIGJyZWFrOwoKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkKICAgICAgewogICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IGJyKQogICAgICAgICAgY29udGludWU7CgogICAgICAgIGlmICh3M2Nfc2xpZHkuaGFzX2NsYXNzKG5vZGUsICJpbmNyZW1lbnRhbCIpCiAgICAgICAgICAgICAmJiB3M2Nfc2xpZHkub2theV9mb3JfaW5jcmVtZW50YWwobm9kZS5ub2RlTmFtZSkpCiAgICAgICAgICByZXR1cm4gbm9kZTsKCiAgICAgICAgaWYgKHczY19zbGlkeS5oYXNfY2xhc3Mobm9kZS5wYXJlbnROb2RlLCAiaW5jcmVtZW50YWwiKQogICAgICAgICAgICAgJiYgIXczY19zbGlkeS5oYXNfY2xhc3Mobm9kZSwgIm5vbi1pbmNyZW1lbnRhbCIpKQogICAgICAgICAgcmV0dXJuIG5vZGU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gbm9kZTsKICB9LAoKICAvLyBzZXQgdmlzaWJpbGl0eSBmb3IgYWxsIGVsZW1lbnRzIG9uIGN1cnJlbnQgc2xpZGUgd2l0aAogIC8vIGEgcGFyZW50IGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgY2xhc3M9ImluY3JlbWVudGFsIgogIHNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICB2YXIgbm9kZSA9IHRoaXMubmV4dF9pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwoKICAgIGlmICh2YWx1ZSA9PSAiaGlkZGVuIikKICAgIHsKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKG5vZGUsICJpbnZpc2libGUiKTsKICAgICAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKICAgICAgfQogICAgfQogICAgZWxzZSAvLyB2YWx1ZSA9PSAidmlzaWJsZSIKICAgIHsKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkucmVtb3ZlX2NsYXNzKG5vZGUsICJpbnZpc2libGUiKTsKICAgICAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKICAgICAgfQogICAgfQogIH0sCgogIC8vIHJldmVhbCB0aGUgbmV4dCBoaWRkZW4gaXRlbSBvbiB0aGUgc2xpZGUKICAvLyBub2RlIGlzIG51bGwgb3IgdGhlIG5vZGUgdGhhdCB3YXMgbGFzdCByZXZlYWxlZAogIHJldmVhbF9uZXh0X2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKCiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEpICAvLyBhbiBlbGVtZW50CiAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwoKICAgIHJldHVybiBub2RlOwogIH0sCgogIC8vIGV4YWN0IGludmVyc2Ugb2YgcmV2ZWFsTmV4dEl0ZW0obm9kZSkKICBoaWRlX3ByZXZpb3VzX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEpICAvLyBhbiBlbGVtZW50CiAgICAgIHczY19zbGlkeS5hZGRfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwoKICAgIHJldHVybiB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obm9kZSk7CiAgfSwKCiAgLy8gbGVmdCB0byByaWdodCB0cmF2ZXJzYWwgb2Ygcm9vdCdzIGNvbnRlbnQKICBuZXh0X25vZGU6IGZ1bmN0aW9uIChyb290LCBub2RlKSB7CiAgICBpZiAobm9kZSA9PSBudWxsKQogICAgICByZXR1cm4gcm9vdC5maXJzdENoaWxkOwoKICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpCiAgICAgIHJldHVybiBub2RlLmZpcnN0Q2hpbGQ7CgogICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpCiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7CgogICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PSByb290KQogICAgICAgIGJyZWFrOwoKICAgICAgaWYgKG5vZGUgJiYgbm9kZS5uZXh0U2libGluZykKICAgICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZzsKICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9LAoKICAvLyByaWdodCB0byBsZWZ0IHRyYXZlcnNhbCBvZiByb290J3MgY29udGVudAogIHByZXZpb3VzX25vZGU6IGZ1bmN0aW9uIChyb290LCBub2RlKSB7CiAgICBpZiAobm9kZSA9PSBudWxsKQogICAgewogICAgICBub2RlID0gcm9vdC5sYXN0Q2hpbGQ7CgogICAgICBpZiAobm9kZSkKICAgICAgewogICAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkKICAgICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDsKICAgICAgfQoKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CgogICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nKQogICAgewogICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7CgogICAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpCiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkOwoKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CgogICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPSByb290KQogICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlOwoKICAgIHJldHVybiBudWxsOwogIH0sCgogIHByZXZpb3VzX3NpYmxpbmdfZWxlbWVudDogZnVuY3Rpb24gKGVsKSB7CiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZzsKCiAgICB3aGlsZSAoZWwgJiYgZWwubm9kZVR5cGUgIT0gMSkKICAgICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7CgogICAgcmV0dXJuIGVsOwogIH0sCgogIG5leHRfc2libGluZ19lbGVtZW50OiBmdW5jdGlvbiAoZWwpIHsKICAgIGVsID0gZWwubmV4dFNpYmxpbmc7CgogICAgd2hpbGUgKGVsICYmIGVsLm5vZGVUeXBlICE9IDEpCiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7CgogICAgcmV0dXJuIGVsOwogIH0sCgogIGZpcnN0X2NoaWxkX2VsZW1lbnQ6IGZ1bmN0aW9uIChlbCkgewogICAgdmFyIG5vZGU7CgogICAgZm9yIChub2RlID0gZWwuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpCiAgICAgICAgYnJlYWs7CiAgICB9CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgZmlyc3RfdGFnOiBmdW5jdGlvbiAoZWxlbWVudCwgdGFnKSB7CiAgICB2YXIgbm9kZTsKCiAgICBpZiAoIXRoaXMuaXNfeGh0bWwpCiAgICAgIHRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpOwoKICAgIGZvciAobm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5ub2RlTmFtZSA9PSB0YWcpCiAgICAgICAgYnJlYWs7CiAgICB9CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgaGlkZV9zZWxlY3Rpb246IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSAvLyBGaXJlZm94LCBDaHJvbWl1bSwgU2FmYXJpLCBPcGVyYQogICAgewogICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpOwoKICAgICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkKICAgICAgewogICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApOwogICAgICAgIHJhbmdlLmNvbGxhcHNlIChmYWxzZSk7CiAgICAgIH0KICAgIH0KICAgIGVsc2UgLy8gSW50ZXJuZXQgRXhwbG9yZXIKICAgIHsKICAgICAgdmFyIHRleHRSYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSAoKTsKICAgICAgdGV4dFJhbmdlLmNvbGxhcHNlIChmYWxzZSk7CiAgICB9CiAgfSwKCiAgZ2V0X3NlbGVjdGVkX3RleHQ6IGZ1bmN0aW9uICgpIHsKICAgIHRyeQogICAgewogICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikKICAgICAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7CgogICAgICBpZiAoZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKQogICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpOwoKICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikKICAgICAgICByZXR1cm4gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dDsKICAgIH0KICAgIGNhdGNoIChlKQogICAgewogICAgfQoKICAgIHJldHVybiAiIjsKICB9LAoKICAvLyBtYWtlIG5vdGUgb2YgbGVuZ3RoIG9mIHNlbGVjdGVkIHRleHQKICAvLyBhcyB0aGlzIGV2YWx1YXRlcyB0byB6ZXJvIGluIGNsaWNrIGV2ZW50CiAgbW91c2VfYnV0dG9uX3VwOiBmdW5jdGlvbiAoZSkgewogICAgdzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuID0gdzNjX3NsaWR5LmdldF9zZWxlY3RlZF90ZXh0KCkubGVuZ3RoOwogIH0sCgogIG1vdXNlX2J1dHRvbl9kb3duOiBmdW5jdGlvbiAoZSkgewogICAgdzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuID0gdzNjX3NsaWR5LmdldF9zZWxlY3RlZF90ZXh0KCkubGVuZ3RoOwogICAgdzNjX3NsaWR5Lm1vdXNlX3ggPSBlLmNsaWVudFg7CiAgICB3M2Nfc2xpZHkubW91c2VfeSA9IGUuY2xpZW50WTsKICB9LAoKICAvLyByaWdodCBtb3VzZSBidXR0b24gY2xpY2sgaXMgcmVzZXJ2ZWQgZm9yIGNvbnRleHQgbWVudXMKICAvLyBpdCBpcyBtb3JlIHJlbGlhYmxlIHRvIGRldGVjdCByaWdodGNsaWNrIHRoYW4gbGVmdGNsaWNrCiAgbW91c2VfYnV0dG9uX2NsaWNrOiBmdW5jdGlvbiAoZSkgewogICAgaWYgKCFlKQogICAgICB2YXIgZSA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoTWF0aC5hYnMoZS5jbGllbnRYIC13M2Nfc2xpZHkubW91c2VfeCkgKwogICAgICAgIE1hdGguYWJzKGUuY2xpZW50WSAtdzNjX3NsaWR5Lm1vdXNlX3kpID4gMTApCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmICh3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPiAwKQogICAgICByZXR1cm4gdHJ1ZTsKCiAgICB2YXIgcmlnaHRjbGljayA9IGZhbHNlOwogICAgdmFyIGxlZnRjbGljayA9IGZhbHNlOwogICAgdmFyIG1pZGRsZWNsaWNrID0gZmFsc2U7CiAgICB2YXIgdGFyZ2V0OwoKICAgIGlmICghZSkKICAgICAgdmFyIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgaWYgKGUudGFyZ2V0KQogICAgICB0YXJnZXQgPSBlLnRhcmdldDsKICAgIGVsc2UgaWYgKGUuc3JjRWxlbWVudCkKICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgIC8vIHdvcmsgYXJvdW5kIFNhZmFyaSBidWcKICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMykKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgaWYgKGUud2hpY2gpIC8vIGFsbCBicm93c2VycyBleGNlcHQgSUUKICAgIHsKICAgICAgbGVmdGNsaWNrID0gKGUud2hpY2ggPT0gMSk7CiAgICAgIG1pZGRsZWNsaWNrID0gKGUud2hpY2ggPT0gMik7CiAgICAgIHJpZ2h0Y2xpY2sgPSAoZS53aGljaCA9PSAzKTsKICAgIH0KICAgIGVsc2UgaWYgKGUuYnV0dG9uKQogICAgewogICAgICAvLyBLb25xdWVyb3IgZ2l2ZXMgMSBmb3IgbGVmdCwgNCBmb3IgbWlkZGxlCiAgICAgIC8vIElFNiBnaXZlcyAwIGZvciBsZWZ0IGFuZCBub3QgMSBhcyBJIGV4cGVjdGVkCgogICAgICBpZiAoZS5idXR0b24gPT0gNCkKICAgICAgICBtaWRkbGVjbGljayA9IHRydWU7CgogICAgICAvLyBhbGwgYnJvd3NlcnMgYWdyZWUgb24gMiBmb3IgcmlnaHQgYnV0dG9uCiAgICAgIHJpZ2h0Y2xpY2sgPSAoZS5idXR0b24gPT0gMik7CiAgICB9CiAgICBlbHNlCiAgICAgIGxlZnRjbGljayA9IHRydWU7CgogICAgaWYgKHczY19zbGlkeS5zZWxlY3RlZF90ZXh0X2xlbiA+IDApCiAgICB7CiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIC8vIGRpc21pc3MgdGFibGUgb2YgY29udGVudHMKICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKGZhbHNlKTsKCiAgICAvLyBjaGVjayBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHRoYXQgcHJvYmFibHkgd2FudCdzIGNsaWNrcwogICAgLy8gZS5nLiBhLCBlbWJlZCwgb2JqZWN0LCBpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCwgb3B0aW9uCiAgICB2YXIgdGFnID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7CgogICAgaWYgKHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkICYmIGxlZnRjbGljayAmJgogICAgICAgICF3M2Nfc2xpZHkuc3BlY2lhbF9lbGVtZW50KHRhcmdldCkgJiYKICAgICAgICAhdGFyZ2V0Lm9uY2xpY2spCiAgICB7CiAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKHRydWUpOwogICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgICAgZS5jYW5jZWwgPSB0cnVlOwogICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICBzcGVjaWFsX2VsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7CiAgICBpZiAodGhpcy5oYXNfY2xhc3MoZWxlbWVudCwgIm5vbi1pbnRlcmFjdGl2ZSIpKQogICAgICByZXR1cm4gZmFsc2U7CgogICAgdmFyIHRhZyA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsKCiAgICByZXR1cm4gZWxlbWVudC5vbmtleWRvd24gfHwKICAgICAgZWxlbWVudC5vbmNsaWNrIHx8CiAgICAgIHRhZyA9PSAiYSIgfHwKICAgICAgdGFnID09ICJlbWJlZCIgfHwKICAgICAgdGFnID09ICJvYmplY3QiIHx8CiAgICAgIHRhZyA9PSAidmlkZW8iIHx8CiAgICAgIHRhZyA9PSAiYXVkaW8iIHx8CiAgICAgIHRhZyA9PSAic3ZnIiB8fAogICAgICB0YWcgPT0gImNhbnZhcyIgfHwKICAgICAgdGFnID09ICJpbnB1dCIgfHwKICAgICAgdGFnID09ICJ0ZXh0YXJlYSIgfHwKICAgICAgdGFnID09ICJzZWxlY3QiIHx8CiAgICAgIHRhZyA9PSAib3B0aW9uIjsKICB9LAoKICBzbGlkeV9jaHJvbWU6IGZ1bmN0aW9uIChlbCkgewogICAgd2hpbGUgKGVsKQogICAgewogICAgICBpZiAoZWwgPT0gdzNjX3NsaWR5LnRvYyB8fAogICAgICAgICAgZWwgPT0gdzNjX3NsaWR5LnRvb2xiYXIgfHwKICAgICAgICAgIHczY19zbGlkeS5oYXNfY2xhc3MoZWwsICJvdXRsaW5lIikpCiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICBlbCA9IGVsLnBhcmVudE5vZGU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIGdldF9rZXk6IGZ1bmN0aW9uIChlKQogIHsKICAgIHZhciBrZXk7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9ICJ1bmRlZmluZWQiKQogICAgICBrZXkgPSB3aW5kb3cuZXZlbnQua2V5Q29kZTsKICAgIGVsc2UgaWYgKGUud2hpY2gpCiAgICAgIGtleSA9IGUud2hpY2g7CgogICAgcmV0dXJuIGtleTsKICB9LAoKICBnZXRfdGFyZ2V0OiBmdW5jdGlvbiAoZSkgewogICAgdmFyIHRhcmdldDsKCiAgICBpZiAoIWUpCiAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgaWYgKGUudGFyZ2V0KQogICAgICB0YXJnZXQgPSBlLnRhcmdldDsKICAgIGVsc2UgaWYgKGUuc3JjRWxlbWVudCkKICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgIGlmICh0YXJnZXQubm9kZVR5cGUgIT0gMSkKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgcmV0dXJuIHRhcmdldDsKICB9LAoKICAvLyBkb2VzIGRpc3BsYXkgcHJvcGVydHkgcHJvdmlkZSBjb3JyZWN0IGRlZmF1bHRzPwogIGlzX2Jsb2NrOiBmdW5jdGlvbiAoZWxlbSkgewogICAgdmFyIHRhZyA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsKCiAgICByZXR1cm4gdGFnID09ICJvbCIgfHwgdGFnID09ICJ1bCIgfHwgdGFnID09ICJwIiB8fCB0YWcgPT0gImRsIiB8fAogICAgICAgICAgIHRhZyA9PSAibGkiIHx8IHRhZyA9PSAidGFibGUiIHx8IHRhZyA9PSAicHJlIiB8fAogICAgICAgICAgIHRhZyA9PSAiaDEiIHx8IHRhZyA9PSAiaDIiIHx8IHRhZyA9PSAiaDMiIHx8CiAgICAgICAgICAgdGFnID09ICJoNCIgfHwgdGFnID09ICJoNSIgfHwgdGFnID09ICJoNiIgfHwKICAgICAgICAgICB0YWcgPT0gImJsb2NrcXVvdGUiIHx8IHRhZyA9PSAiYWRkcmVzcyI7IAogIH0sCgogIGFkZF9saXN0ZW5lcjogZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7CiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpCiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpOwogICAgZWxzZQogICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCJvbiIrZXZlbnQsIGhhbmRsZXIpOwogIH0sCgogIC8vIHVzZWQgdG8gcHJldmVudCBldmVudCBwcm9wYWdhdGlvbiBmcm9tIGZpZWxkIGNvbnRyb2xzCiAgc3RvcF9wcm9wYWdhdGlvbjogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBldmVudCA9IGV2ZW50ID8gZXZlbnQgOiB3aW5kb3cuZXZlbnQ7CiAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlOyAgLy8gZm9yIElFCgogICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikKICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgY2FuY2VsOiBmdW5jdGlvbiAoZXZlbnQpIHsKICAgIGlmIChldmVudCkKICAgIHsKICAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7CiAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOwoKICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KQogICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7CiAgICB9CgogICAgdzNjX3NsaWR5LmtleV93YW50ZWQgPSBmYWxzZTsKICAgIHJldHVybiBmYWxzZTsKICB9LAoKLy8gZm9yIGVhY2ggbGFuZ3VhZ2UgZGVmaW5lIGFuIGFzc29jaWF0aXZlIGFycmF5Ci8vIGFuZCBhbHNvIHRoZSBoZWxwIHRleHQgd2hpY2ggaXMgbG9uZ2VyCgogIHN0cmluZ3NfZXM6IHsKICAgICJzbGlkZSI6InDDoWcuIiwKICAgICJoZWxwPyI6IkF5dWRhIiwKICAgICJjb250ZW50cz8iOiLDjW5kaWNlIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6InRhYmxhIGRlIGNvbnRlbmlkb3MiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiVGFibGEgZGUgQ29udGVuaWRvcyIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZWluaWNpYXIgcHJlc2VudGFjacOzbiIsCiAgICAicmVzdGFydD8iOiJJbmljaW8iCiAgfSwKICBoZWxwX2VzOgogICAgIlV0aWxpY2UgZWwgcmF0w7NuLCBiYXJyYSBlc3BhY2lhZG9yYSwgdGVjbGFzIEl6ZGEvRGNoYSwgIiArCiAgICAibyBSZSBww6FnIHkgQXYgcMOhZy4gVXNlIFMgeSBCIHBhcmEgY2FtYmlhciBlbCB0YW1hw7FvIGRlIGZ1ZW50ZS4iLAoKICBzdHJpbmdzX2NhOiB7CiAgICAic2xpZGUiOiJww6BnLi4iLAogICAgImhlbHA/IjoiQWp1ZGEiLAogICAgImNvbnRlbnRzPyI6IsONbmRleCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJ0YXVsYSBkZSBjb250aW5ndXRzIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlRhdWxhIGRlIENvbnRpbmd1dHMiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmVpbmljaWFyIHByZXNlbnRhY2nDsyIsCiAgICAicmVzdGFydD8iOiJJbmljaSIKICB9LAogIGhlbHBfY2E6CiAgICAiVXRpbGl0emkgZWwgcmF0b2zDrSwgYmFycmEgZXNwYWlhZG9yYSwgdGVjbGVzIEVzcS4vRHRhLiAiICsKICAgICJvIFJlIHDDoGcgeSBBdiBww6BnLiBVc2kgUyBpIEIgcGVyIGNhbnZpYXIgZ3JhbmTDoHJpYSBkZSBmb250LiIsCgogIHN0cmluZ3NfY3M6IHsKICAgICJzbGlkZSI6InNuw61tZWsiLAogICAgImhlbHA/IjoibsOhcG92xJtkYSIsCiAgICAiY29udGVudHM/Ijoib2JzYWgiLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoib2JzYWggcHJlemVudGFjZSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJPYnNhaCBwcmV6ZW50YWNlIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6Inpub3Z1IHNwdXN0aXQgcHJlemVudGFjaSIsCiAgICAicmVzdGFydD8iOiJyZXN0YXJ0IgogIH0sCiAgaGVscF9jczoKICAgICJQcmV6ZW50YWNpIG3Fr8W+ZXRlIHByb2Now6F6ZXQgcG9tb2PDrSBrbGlrbnV0w60gbXnFoWksIG1lemVybsOta3UsICIgKwogICAgIsWhaXBlayB2bGV2byBhIHZwcmF2byBuZWJvIGtsw6F2ZXMgUGFnZVVwIGEgUGFnZURvd24uIFDDrXNtbyBzZSAiICsKICAgICJkw6EgenbEm3TFoWl0IGEgem1lbsWhaXQgcG9tb2PDrSBrbMOhdmVzIEIgYSBTLiIsCgogIHN0cmluZ3Nfbmw6IHsKICAgICJzbGlkZSI6InBhZ2luYSIsCiAgICAiaGVscD8iOiJIZWxwPyIsCiAgICAiY29udGVudHM/IjoiSW5ob3VkPyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJpbmhvdWRzb3BnYXZlIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IkluaG91ZHNvcGdhdmUiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiaGVyc3RhcnQgcHJlc2VudGF0aWUiLAogICAgInJlc3RhcnQ/IjoiSGVyc3RhcnQ/IgogIH0sCiAgaGVscF9ubDoKICAgICAiTmF2aWdlZXIgZC5tLnYuIGhldCBtdWlzLCBzcGF0aWViYXIsIExpbmtzL1JlY2h0cyB0b2V0c2VuLCAiICsKICAgICAib2YgUGdVcCBlbiBQZ0RuLiBHZWJydWlrIFMgZW4gQiBvbSBkZSBrYXJha3Rlcmdyb290dGUgdGUgdmVyYW5kZXJlbi4iLAoKICBzdHJpbmdzX2RlOiB7CiAgICAic2xpZGUiOiJTZWl0ZSIsCiAgICAiaGVscD8iOiJIaWxmZSIsCiAgICAiY29udGVudHM/Ijoiw5xiZXJzaWNodCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJJbmhhbHRzdmVyemVpY2huaXMiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiSW5oYWx0c3ZlcnplaWNobmlzIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IlByw6RzZW50YXRpb24gbmV1IHN0YXJ0ZW4iLAogICAgInJlc3RhcnQ/IjoiTmV1c3RhcnQiCiAgfSwKICBoZWxwX2RlOgogICAgIkJlbnV0emVuIFNpZSBkaWUgTWF1cywgTGVlcnNjaGxhZywgZGllIEN1cnNvcnRhc3RlbiBsaW5rcy9yZWNodHMgb2RlciAiICsKICAgICJQYWdlIHVwL1BhZ2UgRG93biB6dW0gV2VjaHNlbG4gZGVyIFNlaXRlbiB1bmQgUyB1bmQgQiBmw7xyIGRpZSBTY2hyaWZ0Z3LDtnNzZS4iLAoKICBzdHJpbmdzX3BsOiB7CiAgICAic2xpZGUiOiJzbGFqZCIsCiAgICAiaGVscD8iOiJwb21vYz8iLAogICAgImNvbnRlbnRzPyI6InNwaXMgdHJlxZtjaT8iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoic3BpcyB0cmXFm2NpIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlNwaXMgVHJlxZtjaSIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZXN0YXJ0dWogcHJlemVudGFjasSZIiwKICAgICJyZXN0YXJ0PyI6InJlc3RhcnQ/IgogIH0sCiAgaGVscF9wbDoKICAgICJabWllbmlhaiBzbGFqZHkga2xpa2FqxIVjIG15c3rEhSwgbmFjaXNrYWrEhWMgc3BhY2rEmSwgc3RyemHFgmtpIGxld28vcHJhd28iICsKICAgICJsdWIgUGdVcCAvIFBnRG4uIFXFvHlqIGtsYXdpc3p5IFMgaSBCLCBhYnkgem1pZW5pxIcgcm96bWlhciBjemN6aW9ua2kuIiwKCiAgc3RyaW5nc19mcjogewogICAgInNsaWRlIjoicGFnZSIsCiAgICAiaGVscD8iOiJBaWRlIiwKICAgICJjb250ZW50cz8iOiJJbmRleCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJ0YWJsZSBkZXMgbWF0acOocmVzIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlRhYmxlIGRlcyBtYXRpw6hyZXMiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmVjb21tZW5jZXIgbCdleHBvc8OpIiwKICAgICJyZXN0YXJ0PyI6IkTDqWJ1dCIKICB9LAogIGhlbHBfZnI6CiAgICAiTmF2aWd1ZXogYXZlYyBsYSBzb3VyaXMsIGxhIGJhcnJlIGQnZXNwYWNlLCBsZXMgZmzDqGNoZXMgIiArCiAgICAiZ2F1Y2hlL2Ryb2l0ZSBvdSBsZXMgdG91Y2hlcyBQZyBVcCwgUGcgRG4uIFV0aWxpc2V6ICIgKwogICAgImxlcyB0b3VjaGVzIFMgZXQgQiBwb3VyIG1vZGlmaWVyIGxhIHRhaWxsZSBkZSBsYSBwb2xpY2UuIiwKCiAgc3RyaW5nc19odTogewogICAgInNsaWRlIjoib2xkYWwiLAogICAgImhlbHA/Ijoic2Vnw610c8OpZyIsCiAgICAiY29udGVudHM/IjoidGFydGFsb20iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoidGFydGFsb21qZWd5esOpayIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJUYXJ0YWxvbWplZ3l6w6lrIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6ImJlbXV0YXTDsyDDumpyYWluZMOtdMOhc2EiLAogICAgInJlc3RhcnQ/Ijoiw7pqcmFpbmTDrXTDoXMiCiAgfSwKICBoZWxwX2h1OgogICAgIkF6IG9sZGFsYWsga8O2enRpIGzDqXBrZWTDqXNoZXoga2F0dGludHNvbiBheiBlZ8OpcnJlbCwgdmFneSAiICsKICAgICJoYXN6bsOhbGphIGEgc3rDs2vDtnosIGEgYmFsLCB2YWd5IGEgam9iYiBuecOtbCwgaWxsZXR2ZSBhIFBhZ2UgRG93biwgIiArCiAgICAiUGFnZSBVcCBiaWxsZW50ecWxa2V0LiBBeiBTIMOpcyBhIEIgYmlsbGVudHnFsWtrZWwgdsOhbHRvenRhdGhhdGphICIgKwogICAgImEgc3rDtnZlZyBtw6lyZXTDqXQuIiwKCiAgc3RyaW5nc19pdDogewogICAgInNsaWRlIjoicGFnLiIsCiAgICAiaGVscD8iOiJBaXV0byIsCiAgICAiY29udGVudHM/IjoiSW5kaWNlIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6ImluZGljZSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJJbmRpY2UiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmljb21pbmNpYXJlIGxhIHByZXNlbnRhemlvbmUiLAogICAgInJlc3RhcnQ/IjoiSW5pemlvIgogIH0sCiAgaGVscF9pdDoKICAgICJOYXZpZ2FyZSBjb24gbW91c2UsIGJhcnJhIHNwYXppbywgZnJlY2NlIHNpbmlzdHJhL2Rlc3RyYSBvICIgKwogICAgIlBnVXAgZSBQZ0RuLiBVc2FyZSBTIGUgQiBwZXIgY2FtYmlhcmUgbGEgZGltZW5zaW9uZSBkZWkgY2FyYXR0ZXJpLiIsCgogIHN0cmluZ3NfZWw6IHsKICAgICJzbGlkZSI6Is+DzrXOu86vzrTOsSIsCiAgICAiaGVscD8iOiLOss6/zq7OuM61zrnOsTsiLAogICAgImNvbnRlbnRzPyI6Is+AzrXPgc65zrXPh8+MzrzOtc69zrE7IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6Is+Azq/Ovc6xzrrOsc+CIM+AzrXPgc65zrXPh86/zrzOrc69z4nOvSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiLOoM6vzr3Osc66zrHPgiDOoM61z4HOuc61z4fOv868zq3Ovc+Jzr0iLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoizrXPgM6xzr3Otc66zrrOr869zrfPg863IM+AzrHPgc6/z4XPg86vzrHPg863z4IiLAogICAgInJlc3RhcnQ/IjoizrXPgM6xzr3Otc66zrrOr869zrfPg863OyIKICB9LAogIGhlbHBfZWw6CiAgICAizqDOu86/zrfOs863zrjOtc6vz4TOtSDOvM61IM+Ezr8gzrrOu86vzrogz4TOv8+FIM+Azr/Ovc+EzrnOus65zr/PjSwgz4TOvyBzcGFjZSwgz4TOsSDOss6tzrvOtyDOsc+BzrnPg8+EzrXPgc6sL860zrXOvs65zqwsICIgKwogICAgIs6uIFBhZ2UgVXAgzrrOsc65IFBhZ2UgRG93bi4gzqfPgc63z4POuc68zr/PgM6/zrnOrs+Dz4TOtSDPhM6xIM+AzrvOrs66z4TPgc6xIFMgzrrOsc65IEIgzrPOuc6xIM69zrEgzrHOu867zqzOvs61z4TOtSAiICsKICAgICLPhM6/IM68zq3Os861zrjOv8+CIM+EzrfPgiDOs8+BzrHOvM68zrHPhM6/z4POtc65z4HOrM+CLiIsCgogIHN0cmluZ3NfamE6IHsKICAgICJzbGlkZSI6IuOCueODqeOCpOODiSIsCiAgICAiaGVscD8iOiLjg5jjg6vjg5ciLAogICAgImNvbnRlbnRzPyI6IuebruasoSIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiLnm67mrKHjgpLooajnpLoiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi55uu5qyhIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IuacgOWIneOBi+OCieWGjeeUnyIsCiAgICAicmVzdGFydD8iOiLmnIDliJ3jgYvjgokiCiAgfSwKICBoZWxwX2phOgogICAgICLjg57jgqbjgrnlt6bjgq/jg6rjg4Pjgq8g44O7IOOCueODmuODvOOCuSDjg7sg5bem5Y+z44Kt44O8ICIgKwogICAgICLjgb7jgZ/jga8gUGFnZSBVcCDjg7sgUGFnZSBEb3du44Gn5pON5L2c77yMIFMg44O7IELjgafjg5Xjgqnjg7Pjg4jjgrXjgqTjgrrlpInmm7QiLAoKICBzdHJpbmdzX3poOiB7CiAgICAic2xpZGUiOiLlubvnga/niYciLAogICAgImhlbHA/Ijoi5biu5YqpPyIsCiAgICAiY29udGVudHM/Ijoi5YaF5a65PyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiLnm67lvZUiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi55uu5b2VIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IumHjeaWsOWQr+WKqOWxleekuiIsCiAgICAicmVzdGFydD8iOiLph43mlrDlkK/liqg/IgogIH0sCiAgaGVscF96aDoKICAgICLnlKjpvKDmoIfngrnlh7ssIOepuuagvOadoSwg5bem5Y+z566t5aS0LCBQZyBVcCDlkowgUGcgRG4g5a+86IiqLiAiICsKICAgICLnlKggUywgQiDmlLnlj5jlrZfkvZPlpKflsI8uIiwKCiAgc3RyaW5nc19ydTogewogICAgInNsaWRlIjoi0YHQu9Cw0LnQtCIsCiAgICAiaGVscD8iOiLQv9C+0LzQvtGJ0Yw/IiwKICAgICJjb250ZW50cz8iOiLRgdC+0LTQtdGA0LbQsNC90LjQtT8iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoi0L7Qs9C70LDQstC70LXQvdC40LUiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi0J7Qs9C70LDQstC70LXQvdC40LUiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoi0L/QtdGA0LXQt9Cw0L/Rg9GB0YLQuNGC0Ywg0L/RgNC10LfQtdC90YLQsNGG0LjRjiIsCiAgICAicmVzdGFydD8iOiLQv9C10YDQtdC30LDQv9GD0YHQuj8iCiAgfSwKICBoZWxwX3J1OgogICAgItCf0LXRgNC10LzQtdGJ0LDQudGC0LXRgdGMINC60LvQuNC60LDRjyDQvNGL0YjQutC+0LksINC40YHQv9C+0LvRjNC30YPRjyDQutC70LDQstC40YjRgyDQv9GA0L7QsdC10LssINGB0YLRgNC10LvQutC4IiArCiAgICAi0LLQu9C10LLQvi/QstC/0YDQsNCy0L4g0LjQu9C4IFBnIFVwINC4IFBnIERuLiDQmtC70LDQstC40YjQuCBTINC4IEIg0LzQtdC90Y/RjtGCINGA0LDQt9C80LXRgCDRiNGA0LjRhNGC0LAuIiwKCiAgc3RyaW5nc19zdjogewogICAgInNsaWRlIjoic2lkYSIsCiAgICAiaGVscD8iOiJoasOkbHAiLAogICAgImNvbnRlbnRzPyI6ImlubmVow6VsbCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJpbm5laMOlbGxzZsO2cnRlY2tuaW5nIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IklubmVow6VsbHNmw7ZydGVja25pbmciLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoidmlzYSBwcmVzZW50YXRpb25lbiBmcsOlbiBiw7ZyamFuIiwKICAgICJyZXN0YXJ0PyI6ImLDtnJqYSBvbSIKICB9LAogIGhlbHBfc3Y6CiAgICAiQmzDpGRkcmEgbWVkIGV0dCBrbGljayBtZWQgdsOkbnN0cmEgbXVza25hcHBlbiwgbWVsbGFuc2xhZ3N0YW5nZW50ZW4sICIgKwogICAgInbDpG5zdGVyLSBvY2ggaMO2Z2VycGlsdGFuZ2VudGVybmEgZWxsZXIgdGFuZ2VudGVybmEgUGcgVXAsIFBnIERuLiAiICsKICAgICJBbnbDpG5kIHRhbmdlbnRlcm5hIFMgb2NoIEIgZsO2ciBhdHQgw6RuZHJhIHRleHRlbnMgc3Rvcmxlay4iLAoKICBzdHJpbmdzOiB7IH0sCgogIGxvY2FsaXplOiBmdW5jdGlvbiAoc3JjKSB7CiAgICBpZiAoc3JjID09ICIiKQogICAgICByZXR1cm4gc3JjOwoKICAgICAvLyB0cnkgZnVsbCBsYW5ndWFnZSBjb2RlLCBlLmcuIGVuLVVTCiAgICAgdmFyIHMsIGxvb2t1cCA9IHczY19zbGlkeS5zdHJpbmdzW3czY19zbGlkeS5sYW5nXTsKCiAgICAgaWYgKGxvb2t1cCkKICAgICB7CiAgICAgICBzID0gbG9va3VwW3NyY107CgogICAgICAgaWYgKHMpCiAgICAgICAgcmV0dXJuIHM7CiAgICAgfQoKICAgICAvLyBzdHJpcCBjb3VudHJ5IGNvZGUgc3VmZml4LCBlLmcuCiAgICAgLy8gdHJ5IGVuIGlmIHVuZGVmaW5lZCBmb3IgZW4tVVMKICAgICB2YXIgbGcgPSB3M2Nfc2xpZHkubGFuZy5zcGxpdCgiLSIpOwoKICAgICBpZiAobGcubGVuZ3RoID4gMSkKICAgICB7CiAgICAgICBsb29rdXAgPSB3M2Nfc2xpZHkuc3RyaW5nc1tsZ1swXV07CgogICAgICAgaWYgKGxvb2t1cCkKICAgICAgIHsKICAgICAgICAgcyA9IGxvb2t1cFtzcmNdOwoKICAgICAgICAgaWYgKHMpCiAgICAgICAgICByZXR1cm4gczsKICAgICAgIH0KICAgICB9CgogICAgIC8vIG90aGVyd2lzZSBzdHJpbmcgYXMgaXMKICAgICByZXR1cm4gc3JjOwogIH0sCgogIGluaXRfbG9jYWxpemF0aW9uOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgaTE4biA9IHczY19zbGlkeTsKICAgIHZhciBoZWxwX3RleHQgPSB3M2Nfc2xpZHkuaGVscF90ZXh0OwoKICAgIC8vIGVhY2ggc3VjaCBsYW5ndWFnZSBhcnJheSBpcyBkZWNsYXJlZCBpbiB0aGUgbG9jYWxpemUgYXJyYXkKICAgIC8vIHRoaXMgaXMgdXNlZCBhcyBpbiAgdzNjX3NsaWR5LmxvY2FsaXplKCJmb28iKTsKICAgIHRoaXMuc3RyaW5ncyA9IHsKICAgICAgImVzIjp0aGlzLnN0cmluZ3NfZXMsCiAgICAgICJjYSI6dGhpcy5zdHJpbmdzX2NhLAogICAgICAiY3MiOnRoaXMuc3RyaW5nc19jcywKICAgICAgIm5sIjp0aGlzLnN0cmluZ3NfbmwsCiAgICAgICJkZSI6dGhpcy5zdHJpbmdzX2RlLAogICAgICAicGwiOnRoaXMuc3RyaW5nc19wbCwKICAgICAgImZyIjp0aGlzLnN0cmluZ3NfZnIsCiAgICAgICJodSI6dGhpcy5zdHJpbmdzX2h1LAogICAgICAiaXQiOnRoaXMuc3RyaW5nc19pdCwKICAgICAgImVsIjp0aGlzLnN0cmluZ3NfZWwsCiAgICAgICJqcCI6dGhpcy5zdHJpbmdzX2phLAogICAgICAiemgiOnRoaXMuc3RyaW5nc196aCwKICAgICAgInJ1Ijp0aGlzLnN0cmluZ3NfcnUsCiAgICAgICJzdiI6dGhpcy5zdHJpbmdzX3N2CiAgICB9LAoKICAgIGkxOG4uc3RyaW5nc19lc1toZWxwX3RleHRdID0gaTE4bi5oZWxwX2VzOwogICAgaTE4bi5zdHJpbmdzX2NhW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfY2E7CiAgICBpMThuLnN0cmluZ3NfY3NbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9jczsKICAgIGkxOG4uc3RyaW5nc19ubFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX25sOwogICAgaTE4bi5zdHJpbmdzX2RlW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfZGU7CiAgICBpMThuLnN0cmluZ3NfcGxbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9wbDsKICAgIGkxOG4uc3RyaW5nc19mcltoZWxwX3RleHRdID0gaTE4bi5oZWxwX2ZyOwogICAgaTE4bi5zdHJpbmdzX2h1W2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfaHU7CiAgICBpMThuLnN0cmluZ3NfaXRbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9pdDsKICAgIGkxOG4uc3RyaW5nc19lbFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX2VsOwogICAgaTE4bi5zdHJpbmdzX2phW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfamE7CiAgICBpMThuLnN0cmluZ3NfemhbaGVscF90ZXh0XSA9IGkxOG4uaGVscF96aDsKICAgIGkxOG4uc3RyaW5nc19ydVtoZWxwX3RleHRdID0gaTE4bi5oZWxwX3J1OwogICAgaTE4bi5zdHJpbmdzX3N2W2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfc3Y7CgogICAgdzNjX3NsaWR5LmxhbmcgPSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJsYW5nIik7CgogICAgaWYgKCF3M2Nfc2xpZHkubGFuZykKICAgICAgdzNjX3NsaWR5LmxhbmcgPSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJ4bWw6bGFuZyIpOwoKICAgIGlmICghdzNjX3NsaWR5LmxhbmcpCiAgICAgIHczY19zbGlkeS5sYW5nID0gImVuIjsKICB9Cn07CgovLyBoYWNrIGZvciBiYWNrIGJ1dHRvbiBiZWhhdmlvcgppZiAodzNjX3NsaWR5LmllNiB8fCB3M2Nfc2xpZHkuaWU3KQp7CiAgZG9jdW1lbnQud3JpdGUoIjxpZnJhbWUgaWQ9J2hpc3RvcnlGcmFtZScgIiArCiAgInNyYz0namF2YXNjcmlwdDpcIjxodG1sIisiPjwvIisiaHRtbD5cIicgIiArCiAgImhlaWdodD0nMScgd2lkdGg9JzEnICIgKwogICJzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7bGVmdDotODAwcHgnPjwvaWZyYW1lPiIpOwp9CgovLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIGZvciBpbml0aWFsaXphdGlvbgp3M2Nfc2xpZHkuc2V0X3VwKCk7CgovLyBoaWRlIHRoZSBzbGlkZXMgYXMgc29vbiBhcyBib2R5IGVsZW1lbnQgaXMgYXZhaWxhYmxlCi8vIHRvIHJlZHVjZSBhbm5veWluZyBzY3JlZW4gbWVzcyBiZWZvcmUgdGhlIG9ubG9hZCBldmVudApzZXRUaW1lb3V0KHczY19zbGlkeS5oaWRlX3NsaWRlcywgNTApOwoK"></script>
  <script>(function() {
  if (!window.w3c_slidy) return;
  if (!window.Shiny) return;
  if (!window.$) return;
  // whenever a slide changes, tell shiny to recalculate what is displayed
  window.w3c_slidy.add_observer(function (slide_num) {
    // slide_num starts at position 1
    $(w3c_slidy.slides[slide_num - 1]).trigger("shown");
  });
})()
</script>
  <script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      if (cel) {
        cel.style.position = "absolute";
        var pad = unpackPadding(sizing.padding);
        cel.style.top = pad.top + "px";
        cel.style.right = pad.right + "px";
        cel.style.bottom = pad.bottom + "px";
        cel.style.left = pad.left + "px";
        el.style.width = "100%";
        el.style.height = "100%";
      }

      return {
        getWidth: function() { return cel.offsetWidth; },
        getHeight: function() { return cel.offsetHeight; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return el.offsetWidth; },
        getHeight: function() { return el.offsetHeight; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var result = bindingDef.initialize(el, el.offsetWidth,
              el.offsetHeight);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          initResult = binding.initialize(el,
            sizeObj ? sizeObj.getWidth() : el.offsetWidth,
            sizeObj ? sizeObj.getHeight() : el.offsetHeight
          );
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = {
            w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
            h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
          };
          var resizeHandler = function(e) {
            var size = {
              w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
              h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
            };
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();

</script>
  <script>/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/returnExports.js
(function (root, factory) {
  /*global define */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.returnExports = factory();
  }
}(this, function () {
  'use strict';

  var _apply = Function.call.bind(Function.apply);
  var _call = Function.call.bind(Function.call);
  var isArray = Array.isArray;
  var keys = Object.keys;

  var not = function notThunker(func) {
    return function notThunk() {
      return !_apply(func, this, arguments);
    };
  };
  var throwsError = function (func) {
    try {
      func();
      return false;
    } catch (e) {
      return true;
    }
  };
  var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {
    try {
      return func();
    } catch (e) {
      return false;
    }
  };

  var isCallableWithoutNew = not(throwsError);
  var arePropertyDescriptorsSupported = function () {
    // if Object.defineProperty exists but throws, it's IE 8
    return !throwsError(function () {
      return Object.defineProperty({}, 'x', { get: function () { } }); // eslint-disable-line getter-return
    });
  };
  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
  var functionsHaveNames = (function foo() {}).name === 'foo'; // eslint-disable-line no-extra-parens

  var _forEach = Function.call.bind(Array.prototype.forEach);
  var _reduce = Function.call.bind(Array.prototype.reduce);
  var _filter = Function.call.bind(Array.prototype.filter);
  var _some = Function.call.bind(Array.prototype.some);

  var defineProperty = function (object, name, value, force) {
    if (!force && name in object) { return; }
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };

  // Define configurable, writable and non-enumerable props
  // if they dont exist.
  var defineProperties = function (object, map, forceOverride) {
    _forEach(keys(map), function (name) {
      var method = map[name];
      defineProperty(object, name, method, !!forceOverride);
    });
  };

  var _toString = Function.call.bind(Object.prototype.toString);
  var isCallable = typeof /abc/ === 'function' ? function IsCallableSlow(x) {
    // Some old browsers (IE, FF) say that typeof /abc/ === 'function'
    return typeof x === 'function' && _toString(x) === '[object Function]';
  } : function IsCallableFast(x) { return typeof x === 'function'; };

  var Value = {
    getter: function (object, name, getter) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        get: getter
      });
    },
    proxy: function (originalObject, key, targetObject) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
      Object.defineProperty(targetObject, key, {
        configurable: originalDescriptor.configurable,
        enumerable: originalDescriptor.enumerable,
        get: function getKey() { return originalObject[key]; },
        set: function setKey(value) { originalObject[key] = value; }
      });
    },
    redefine: function (object, property, newValue) {
      if (supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(object, property);
        descriptor.value = newValue;
        Object.defineProperty(object, property, descriptor);
      } else {
        object[property] = newValue;
      }
    },
    defineByDescriptor: function (object, property, descriptor) {
      if (supportsDescriptors) {
        Object.defineProperty(object, property, descriptor);
      } else if ('value' in descriptor) {
        object[property] = descriptor.value;
      }
    },
    preserveToString: function (target, source) {
      if (source && isCallable(source.toString)) {
        defineProperty(target, 'toString', source.toString.bind(source), true);
      }
    }
  };

  // Simple shim for Object.create on ES3 browsers
  // (unlike real shim, no attempt to support `prototype === null`)
  var create = Object.create || function (prototype, properties) {
    var Prototype = function Prototype() {};
    Prototype.prototype = prototype;
    var object = new Prototype();
    if (typeof properties !== 'undefined') {
      keys(properties).forEach(function (key) {
        Value.defineByDescriptor(object, key, properties[key]);
      });
    }
    return object;
  };

  var supportsSubclassing = function (C, f) {
    if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }
    return valueOrFalseIfThrows(function () {
      var Sub = function Subclass(arg) {
        var o = new C(arg);
        Object.setPrototypeOf(o, Subclass.prototype);
        return o;
      };
      Object.setPrototypeOf(Sub, C);
      Sub.prototype = create(C.prototype, {
        constructor: { value: Sub }
      });
      return f(Sub);
    });
  };

  var getGlobal = function () {
    /* global self, window */
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') { return self; }
    if (typeof window !== 'undefined') { return window; }
    if (typeof global !== 'undefined') { return global; }
    throw new Error('unable to locate global object');
  };

  var globals = getGlobal();
  var globalIsFinite = globals.isFinite;
  var _indexOf = Function.call.bind(String.prototype.indexOf);
  var _arrayIndexOfApply = Function.apply.bind(Array.prototype.indexOf);
  var _concat = Function.call.bind(Array.prototype.concat);
  // var _sort = Function.call.bind(Array.prototype.sort);
  var _strSlice = Function.call.bind(String.prototype.slice);
  var _push = Function.call.bind(Array.prototype.push);
  var _pushApply = Function.apply.bind(Array.prototype.push);
  var _join = Function.call.bind(Array.prototype.join);
  var _shift = Function.call.bind(Array.prototype.shift);
  var _max = Math.max;
  var _min = Math.min;
  var _floor = Math.floor;
  var _abs = Math.abs;
  var _exp = Math.exp;
  var _log = Math.log;
  var _sqrt = Math.sqrt;
  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
  var ArrayIterator; // make our implementation private
  var noop = function () {};

  var OrigMap = globals.Map;
  var origMapDelete = OrigMap && OrigMap.prototype['delete'];
  var origMapGet = OrigMap && OrigMap.prototype.get;
  var origMapHas = OrigMap && OrigMap.prototype.has;
  var origMapSet = OrigMap && OrigMap.prototype.set;

  var Symbol = globals.Symbol || {};
  var symbolSpecies = Symbol.species || '@@species';

  var numberIsNaN = Number.isNaN || function isNaN(value) {
    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN('foo') => true
    return value !== value;
  };
  var numberIsFinite = Number.isFinite || function isFinite(value) {
    return typeof value === 'number' && globalIsFinite(value);
  };
  var _sign = isCallable(Math.sign) ? Math.sign : function sign(value) {
    var number = Number(value);
    if (number === 0) { return number; }
    if (numberIsNaN(number)) { return number; }
    return number < 0 ? -1 : 1;
  };
  var _log1p = function log1p(value) {
    var x = Number(value);
    if (x < -1 || numberIsNaN(x)) { return NaN; }
    if (x === 0 || x === Infinity) { return x; }
    if (x === -1) { return -Infinity; }

    return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));
  };

  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
  // can be replaced with require('is-arguments') if we ever use a build process instead
  var isStandardArguments = function isArguments(value) {
    return _toString(value) === '[object Arguments]';
  };
  var isLegacyArguments = function isArguments(value) {
    return value !== null &&
      typeof value === 'object' &&
      typeof value.length === 'number' &&
      value.length >= 0 &&
      _toString(value) !== '[object Array]' &&
      _toString(value.callee) === '[object Function]';
  };
  var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

  var Type = {
    primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },
    string: function (x) { return _toString(x) === '[object String]'; },
    regex: function (x) { return _toString(x) === '[object RegExp]'; },
    symbol: function (x) {
      return typeof globals.Symbol === 'function' && typeof x === 'symbol';
    }
  };

  var overrideNative = function overrideNative(object, property, replacement) {
    var original = object[property];
    defineProperty(object, property, replacement, true);
    Value.preserveToString(object[property], original);
  };

  // eslint-disable-next-line no-restricted-properties
  var hasSymbols = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' && Type.symbol(Symbol());

  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
  // we're going to use an arbitrary _-prefixed name to make our shims
  // work properly with each other, even though we don't have full Iterator
  // support.  That is, `Array.from(map.keys())` will work, but we don't
  // pretend to export a "real" Iterator interface.
  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
  // Firefox ships a partial implementation using the name @@iterator.
  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
  // So use that name if we detect it.
  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }

  // Reflect
  if (!globals.Reflect) {
    defineProperty(globals, 'Reflect', {}, true);
  }
  var Reflect = globals.Reflect;

  var $String = String;

  /* global document */
  var domAll = (typeof document === 'undefined' || !document) ? null : document.all;
  var isNullOrUndefined = domAll == null ? function isNullOrUndefined(x) {
    return x == null;
  } : function isNullOrUndefinedAndNotDocumentAll(x) {
    return x == null && x !== domAll;
  };

  var ES = {
    // http://www.ecma-international.org/ecma-262/6.0/#sec-call
    Call: function Call(F, V) {
      var args = arguments.length > 2 ? arguments[2] : [];
      if (!ES.IsCallable(F)) {
        throw new TypeError(F + ' is not a function');
      }
      return _apply(F, V, args);
    },

    RequireObjectCoercible: function (x, optMessage) {
      if (isNullOrUndefined(x)) {
        throw new TypeError(optMessage || 'Cannot call method on ' + x);
      }
      return x;
    },

    // This might miss the "(non-standard exotic and does not implement
    // [[Call]])" case from
    // http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation
    // but we can't find any evidence these objects exist in practice.
    // If we find some in the future, you could test `Object(x) === x`,
    // which is reliable according to
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toobject
    // but is not well optimized by runtimes and creates an object
    // whenever it returns false, and thus is very slow.
    TypeIsObject: function (x) {
      if (x === void 0 || x === null || x === true || x === false) {
        return false;
      }
      return typeof x === 'function' || typeof x === 'object' || x === domAll;
    },

    ToObject: function (o, optMessage) {
      return Object(ES.RequireObjectCoercible(o, optMessage));
    },

    IsCallable: isCallable,

    IsConstructor: function (x) {
      // We can't tell callables from constructors in ES5
      return ES.IsCallable(x);
    },

    ToInt32: function (x) {
      return ES.ToNumber(x) >> 0;
    },

    ToUint32: function (x) {
      return ES.ToNumber(x) >>> 0;
    },

    ToNumber: function (value) {
      if (hasSymbols && _toString(value) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return +value;
    },

    ToInteger: function (value) {
      var number = ES.ToNumber(value);
      if (numberIsNaN(number)) { return 0; }
      if (number === 0 || !numberIsFinite(number)) { return number; }
      return (number > 0 ? 1 : -1) * _floor(_abs(number));
    },

    ToLength: function (value) {
      var len = ES.ToInteger(value);
      if (len <= 0) { return 0; } // includes converting -0 to +0
      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
      return len;
    },

    SameValue: function (a, b) {
      if (a === b) {
        // 0 === -0, but they are not identical.
        if (a === 0) { return 1 / a === 1 / b; }
        return true;
      }
      return numberIsNaN(a) && numberIsNaN(b);
    },

    SameValueZero: function (a, b) {
      // same as SameValue except for SameValueZero(+0, -0) == true
      return (a === b) || (numberIsNaN(a) && numberIsNaN(b));
    },

    IsIterable: function (o) {
      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
    },

    GetIterator: function (o) {
      if (isArguments(o)) {
        // special case support for `arguments`
        return new ArrayIterator(o, 'value');
      }
      var itFn = ES.GetMethod(o, $iterator$);
      if (!ES.IsCallable(itFn)) {
        // Better diagnostics if itFn is null or undefined
        throw new TypeError('value is not an iterable');
      }
      var it = ES.Call(itFn, o);
      if (!ES.TypeIsObject(it)) {
        throw new TypeError('bad iterator');
      }
      return it;
    },

    GetMethod: function (o, p) {
      var func = ES.ToObject(o)[p];
      if (isNullOrUndefined(func)) {
        return void 0;
      }
      if (!ES.IsCallable(func)) {
        throw new TypeError('Method not callable: ' + p);
      }
      return func;
    },

    IteratorComplete: function (iterResult) {
      return !!iterResult.done;
    },

    IteratorClose: function (iterator, completionIsThrow) {
      var returnMethod = ES.GetMethod(iterator, 'return');
      if (returnMethod === void 0) {
        return;
      }
      var innerResult, innerException;
      try {
        innerResult = ES.Call(returnMethod, iterator);
      } catch (e) {
        innerException = e;
      }
      if (completionIsThrow) {
        return;
      }
      if (innerException) {
        throw innerException;
      }
      if (!ES.TypeIsObject(innerResult)) {
        throw new TypeError("Iterator's return method returned a non-object.");
      }
    },

    IteratorNext: function (it) {
      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
      if (!ES.TypeIsObject(result)) {
        throw new TypeError('bad iterator');
      }
      return result;
    },

    IteratorStep: function (it) {
      var result = ES.IteratorNext(it);
      var done = ES.IteratorComplete(result);
      return done ? false : result;
    },

    Construct: function (C, args, newTarget, isES6internal) {
      var target = typeof newTarget === 'undefined' ? C : newTarget;

      if (!isES6internal && Reflect.construct) {
        // Try to use Reflect.construct if available
        return Reflect.construct(C, args, target);
      }
      // OK, we have to fake it.  This will only work if the
      // C.[[ConstructorKind]] == "base" -- but that's the only
      // kind we can make in ES5 code anyway.

      // OrdinaryCreateFromConstructor(target, "%ObjectPrototype%")
      var proto = target.prototype;
      if (!ES.TypeIsObject(proto)) {
        proto = Object.prototype;
      }
      var obj = create(proto);
      // Call the constructor.
      var result = ES.Call(C, obj, args);
      return ES.TypeIsObject(result) ? result : obj;
    },

    SpeciesConstructor: function (O, defaultConstructor) {
      var C = O.constructor;
      if (C === void 0) {
        return defaultConstructor;
      }
      if (!ES.TypeIsObject(C)) {
        throw new TypeError('Bad constructor');
      }
      var S = C[symbolSpecies];
      if (isNullOrUndefined(S)) {
        return defaultConstructor;
      }
      if (!ES.IsConstructor(S)) {
        throw new TypeError('Bad @@species');
      }
      return S;
    },

    CreateHTML: function (string, tag, attribute, value) {
      var S = ES.ToString(string);
      var p1 = '<' + tag;
      if (attribute !== '') {
        var V = ES.ToString(value);
        var escapedV = V.replace(/"/g, '&quot;');
        p1 += ' ' + attribute + '="' + escapedV + '"';
      }
      var p2 = p1 + '>';
      var p3 = p2 + S;
      return p3 + '</' + tag + '>';
    },

    IsRegExp: function IsRegExp(argument) {
      if (!ES.TypeIsObject(argument)) {
        return false;
      }
      var isRegExp = argument[Symbol.match];
      if (typeof isRegExp !== 'undefined') {
        return !!isRegExp;
      }
      return Type.regex(argument);
    },

    ToString: function ToString(string) {
      if (hasSymbols && _toString(string) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return $String(string);
    }
  };

  // Well-known Symbol shims
  if (supportsDescriptors && hasSymbols) {
    var defineWellKnownSymbol = function defineWellKnownSymbol(name) {
      if (Type.symbol(Symbol[name])) {
        return Symbol[name];
      }
      // eslint-disable-next-line no-restricted-properties
      var sym = Symbol['for']('Symbol.' + name);
      Object.defineProperty(Symbol, name, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: sym
      });
      return sym;
    };
    if (!Type.symbol(Symbol.search)) {
      var symbolSearch = defineWellKnownSymbol('search');
      var originalSearch = String.prototype.search;
      defineProperty(RegExp.prototype, symbolSearch, function search(string) {
        return ES.Call(originalSearch, string, [this]);
      });
      var searchShim = function search(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(regexp)) {
          var searcher = ES.GetMethod(regexp, symbolSearch);
          if (typeof searcher !== 'undefined') {
            return ES.Call(searcher, regexp, [O]);
          }
        }
        return ES.Call(originalSearch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'search', searchShim);
    }
    if (!Type.symbol(Symbol.replace)) {
      var symbolReplace = defineWellKnownSymbol('replace');
      var originalReplace = String.prototype.replace;
      defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {
        return ES.Call(originalReplace, string, [this, replaceValue]);
      });
      var replaceShim = function replace(searchValue, replaceValue) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(searchValue)) {
          var replacer = ES.GetMethod(searchValue, symbolReplace);
          if (typeof replacer !== 'undefined') {
            return ES.Call(replacer, searchValue, [O, replaceValue]);
          }
        }
        return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);
      };
      overrideNative(String.prototype, 'replace', replaceShim);
    }
    if (!Type.symbol(Symbol.split)) {
      var symbolSplit = defineWellKnownSymbol('split');
      var originalSplit = String.prototype.split;
      defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {
        return ES.Call(originalSplit, string, [this, limit]);
      });
      var splitShim = function split(separator, limit) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(separator)) {
          var splitter = ES.GetMethod(separator, symbolSplit);
          if (typeof splitter !== 'undefined') {
            return ES.Call(splitter, separator, [O, limit]);
          }
        }
        return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);
      };
      overrideNative(String.prototype, 'split', splitShim);
    }
    var symbolMatchExists = Type.symbol(Symbol.match);
    var stringMatchIgnoresSymbolMatch = symbolMatchExists && (function () {
      // Firefox 41, through Nightly 45 has Symbol.match, but String#match ignores it.
      // Firefox 40 and below have Symbol.match but String#match works fine.
      var o = {};
      o[Symbol.match] = function () { return 42; };
      return 'a'.match(o) !== 42;
    }());
    if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {
      var symbolMatch = defineWellKnownSymbol('match');

      var originalMatch = String.prototype.match;
      defineProperty(RegExp.prototype, symbolMatch, function match(string) {
        return ES.Call(originalMatch, string, [this]);
      });

      var matchShim = function match(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (!isNullOrUndefined(regexp)) {
          var matcher = ES.GetMethod(regexp, symbolMatch);
          if (typeof matcher !== 'undefined') {
            return ES.Call(matcher, regexp, [O]);
          }
        }
        return ES.Call(originalMatch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'match', matchShim);
    }
  }

  var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {
    Value.preserveToString(replacement, original);
    if (Object.setPrototypeOf) {
      // sets up proper prototype chain where possible
      Object.setPrototypeOf(original, replacement);
    }
    if (supportsDescriptors) {
      _forEach(Object.getOwnPropertyNames(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        Value.proxy(original, key, replacement);
      });
    } else {
      _forEach(Object.keys(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        replacement[key] = original[key];
      });
    }
    replacement.prototype = original.prototype;
    Value.redefine(original.prototype, 'constructor', replacement);
  };

  var defaultSpeciesGetter = function () { return this; };
  var addDefaultSpecies = function (C) {
    if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
      Value.getter(C, symbolSpecies, defaultSpeciesGetter);
    }
  };

  var addIterator = function (prototype, impl) {
    var implementation = impl || function iterator() { return this; };
    defineProperty(prototype, $iterator$, implementation);
    if (!prototype[$iterator$] && Type.symbol($iterator$)) {
      // implementations are buggy when $iterator$ is a Symbol
      prototype[$iterator$] = implementation;
    }
  };

  var createDataProperty = function createDataProperty(object, name, value) {
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };
  var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {
    createDataProperty(object, name, value);
    if (!ES.SameValue(object[name], value)) {
      throw new TypeError('property is nonconfigurable');
    }
  };

  var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {
    // This is an es5 approximation to es6 construct semantics.  in es6,
    // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)
    // just sets the internal variable NewTarget (in es6 syntax `new.target`)
    // to Foo and then returns Foo().

    // Many ES6 object then have constructors of the form:
    // 1. If NewTarget is undefined, throw a TypeError exception
    // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)

    // So we're going to emulate those first two steps.
    if (!ES.TypeIsObject(o)) {
      throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);
    }
    var proto = defaultNewTarget.prototype;
    if (!ES.TypeIsObject(proto)) {
      proto = defaultProto;
    }
    var obj = create(proto);
    for (var name in slots) {
      if (_hasOwnProperty(slots, name)) {
        var value = slots[name];
        defineProperty(obj, name, value, true);
      }
    }
    return obj;
  };

  // Firefox 31 reports this function's length as 0
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
  if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
    var originalFromCodePoint = String.fromCodePoint;
    overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) {
      return ES.Call(originalFromCodePoint, this, arguments);
    });
  }

  var StringShims = {
    fromCodePoint: function fromCodePoint(codePoints) {
      var result = [];
      var next;
      for (var i = 0, length = arguments.length; i < length; i++) {
        next = Number(arguments[i]);
        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
          throw new RangeError('Invalid code point ' + next);
        }

        if (next < 0x10000) {
          _push(result, String.fromCharCode(next));
        } else {
          next -= 0x10000;
          _push(result, String.fromCharCode((next >> 10) + 0xD800));
          _push(result, String.fromCharCode((next % 0x400) + 0xDC00));
        }
      }
      return _join(result, '');
    },

    raw: function raw(template) {
      var numberOfSubstitutions = arguments.length - 1;
      var cooked = ES.ToObject(template, 'bad template');
      var raw = ES.ToObject(cooked.raw, 'bad raw value');
      var len = raw.length;
      var literalSegments = ES.ToLength(len);
      if (literalSegments <= 0) {
        return '';
      }

      var stringElements = [];
      var nextIndex = 0;
      var nextKey, next, nextSeg, nextSub;
      while (nextIndex < literalSegments) {
        nextKey = ES.ToString(nextIndex);
        nextSeg = ES.ToString(raw[nextKey]);
        _push(stringElements, nextSeg);
        if (nextIndex + 1 >= literalSegments) {
          break;
        }
        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';
        nextSub = ES.ToString(next);
        _push(stringElements, nextSub);
        nextIndex += 1;
      }
      return _join(stringElements, '');
    }
  };
  if (String.raw && String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {
    // IE 11 TP has a broken String.raw implementation
    overrideNative(String, 'raw', StringShims.raw);
  }
  defineProperties(String, StringShims);

  // Fast repeat, uses the `Exponentiation by squaring` algorithm.
  // Perf: http://jsperf.com/string-repeat2/2
  var stringRepeat = function repeat(s, times) {
    if (times < 1) { return ''; }
    if (times % 2) { return repeat(s, times - 1) + s; }
    var half = repeat(s, times / 2);
    return half + half;
  };
  var stringMaxLength = Infinity;

  var StringPrototypeShims = {
    repeat: function repeat(times) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var numTimes = ES.ToInteger(times);
      if (numTimes < 0 || numTimes >= stringMaxLength) {
        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
      }
      return stringRepeat(thisStr, numTimes);
    },

    startsWith: function startsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "startsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      var start = _max(ES.ToInteger(position), 0);
      return _strSlice(S, start, start + searchStr.length) === searchStr;
    },

    endsWith: function endsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "endsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var len = S.length;
      var endPosition;
      if (arguments.length > 1) {
        endPosition = arguments[1];
      }
      var pos = typeof endPosition === 'undefined' ? len : ES.ToInteger(endPosition);
      var end = _min(_max(pos, 0), len);
      return _strSlice(S, end - searchStr.length, end) === searchStr;
    },

    includes: function includes(searchString) {
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('"includes" does not accept a RegExp');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      // Somehow this trick makes method 100% compat with the spec.
      return _indexOf(this, searchStr, position) !== -1;
    },

    codePointAt: function codePointAt(pos) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var position = ES.ToInteger(pos);
      var length = thisStr.length;
      if (position >= 0 && position < length) {
        var first = thisStr.charCodeAt(position);
        var isEnd = position + 1 === length;
        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
        var second = thisStr.charCodeAt(position + 1);
        if (second < 0xDC00 || second > 0xDFFF) { return first; }
        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
      }
    }
  };
  if (String.prototype.includes && 'a'.includes('a', Infinity) !== false) {
    overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
  }

  if (String.prototype.startsWith && String.prototype.endsWith) {
    var startsWithRejectsRegex = throwsError(function () {
      /* throws if spec-compliant */
      return '/a/'.startsWith(/a/);
    });
    var startsWithHandlesInfinity = valueOrFalseIfThrows(function () {
      return 'abc'.startsWith('a', Infinity) === false;
    });
    if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {
      // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
  }
  if (hasSymbols) {
    var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.startsWith(re);
    });
    if (!startsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
    }
    var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.endsWith(re);
    });
    if (!endsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
    var includesSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.includes(re);
    });
    if (!includesSupportsSymbolMatch) {
      overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
    }
  }

  defineProperties(String.prototype, StringPrototypeShims);

  // whitespace from: http://es5.github.io/#x15.5.4.20
  // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
  var ws = [
    '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
    '\u2029\uFEFF'
  ].join('');
  var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
  var trimShim = function trim() {
    return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, '');
  };
  var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
  var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
  var isBadHexRegex = /^[-+]0x[0-9a-f]+$/i;
  var hasStringTrimBug = nonWS.trim().length !== nonWS.length;
  defineProperty(String.prototype, 'trim', trimShim, hasStringTrimBug);

  // Given an argument x, it will return an IteratorResult object,
  // with value set to x and done to false.
  // Given no arguments, it will return an iterator completion object.
  var iteratorResult = function (x) {
    return { value: x, done: arguments.length === 0 };
  };

  // see http://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype-@@iterator
  var StringIterator = function (s) {
    ES.RequireObjectCoercible(s);
    this._s = ES.ToString(s);
    this._i = 0;
  };
  StringIterator.prototype.next = function () {
    var s = this._s;
    var i = this._i;
    if (typeof s === 'undefined' || i >= s.length) {
      this._s = void 0;
      return iteratorResult();
    }
    var first = s.charCodeAt(i);
    var second, len;
    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
      len = 1;
    } else {
      second = s.charCodeAt(i + 1);
      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
    }
    this._i = i + len;
    return iteratorResult(s.substr(i, len));
  };
  addIterator(StringIterator.prototype);
  addIterator(String.prototype, function () {
    return new StringIterator(this);
  });

  var ArrayShims = {
    from: function from(items) {
      var C = this;
      var mapFn;
      if (arguments.length > 1) {
        mapFn = arguments[1];
      }
      var mapping, T;
      if (typeof mapFn === 'undefined') {
        mapping = false;
      } else {
        if (!ES.IsCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }
        if (arguments.length > 2) {
          T = arguments[2];
        }
        mapping = true;
      }

      // Note that that Arrays will use ArrayIterator:
      // https://bugs.ecmascript.org/show_bug.cgi?id=2416
      var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== 'undefined';

      var length, result, i;
      if (usingIterator) {
        result = ES.IsConstructor(C) ? Object(new C()) : [];
        var iterator = ES.GetIterator(items);
        var next, nextValue;

        i = 0;
        while (true) {
          next = ES.IteratorStep(iterator);
          if (next === false) {
            break;
          }
          nextValue = next.value;
          try {
            if (mapping) {
              nextValue = typeof T === 'undefined' ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);
            }
            result[i] = nextValue;
          } catch (e) {
            ES.IteratorClose(iterator, true);
            throw e;
          }
          i += 1;
        }
        length = i;
      } else {
        var arrayLike = ES.ToObject(items);
        length = ES.ToLength(arrayLike.length);
        result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
        var value;
        for (i = 0; i < length; ++i) {
          value = arrayLike[i];
          if (mapping) {
            value = typeof T === 'undefined' ? mapFn(value, i) : _call(mapFn, T, value, i);
          }
          createDataPropertyOrThrow(result, i, value);
        }
      }

      result.length = length;
      return result;
    },

    of: function of() {
      var len = arguments.length;
      var C = this;
      var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
      for (var k = 0; k < len; ++k) {
        createDataPropertyOrThrow(A, k, arguments[k]);
      }
      A.length = len;
      return A;
    }
  };
  defineProperties(Array, ArrayShims);
  addDefaultSpecies(Array);

  // Our ArrayIterator is private; see
  // https://github.com/paulmillr/es6-shim/issues/252
  ArrayIterator = function (array, kind) {
    this.i = 0;
    this.array = array;
    this.kind = kind;
  };

  defineProperties(ArrayIterator.prototype, {
    next: function () {
      var i = this.i;
      var array = this.array;
      if (!(this instanceof ArrayIterator)) {
        throw new TypeError('Not an ArrayIterator');
      }
      if (typeof array !== 'undefined') {
        var len = ES.ToLength(array.length);
        if (i < len) {
        //for (; i < len; i++) {
          var kind = this.kind;
          var retval;
          if (kind === 'key') {
            retval = i;
          } else if (kind === 'value') {
            retval = array[i];
          } else if (kind === 'entry') {
            retval = [i, array[i]];
          }
          this.i = i + 1;
          return iteratorResult(retval);
        }
      }
      this.array = void 0;
      return iteratorResult();
    }
  });
  addIterator(ArrayIterator.prototype);

  /*
  var orderKeys = function orderKeys(a, b) {
    var aNumeric = String(ES.ToInteger(a)) === a;
    var bNumeric = String(ES.ToInteger(b)) === b;
    if (aNumeric && bNumeric) {
      return b - a;
    } else if (aNumeric && !bNumeric) {
      return -1;
    } else if (!aNumeric && bNumeric) {
      return 1;
    } else {
      return a.localeCompare(b);
    }
  };

  var getAllKeys = function getAllKeys(object) {
    var ownKeys = [];
    var keys = [];

    for (var key in object) {
      _push(_hasOwnProperty(object, key) ? ownKeys : keys, key);
    }
    _sort(ownKeys, orderKeys);
    _sort(keys, orderKeys);

    return _concat(ownKeys, keys);
  };
  */

  // note: this is positioned here because it depends on ArrayIterator
  var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {
    // Detects a bug in Webkit nightly r181886
    var Foo = function Foo(len) { this.length = len; };
    Foo.prototype = [];
    var fooArr = Array.of.apply(Foo, [1, 2]);
    return fooArr instanceof Foo && fooArr.length === 2;
  }());
  if (!arrayOfSupportsSubclassing) {
    overrideNative(Array, 'of', ArrayShims.of);
  }

  var ArrayPrototypeShims = {
    copyWithin: function copyWithin(target, start) {
      var o = ES.ToObject(this);
      var len = ES.ToLength(o.length);
      var relativeTarget = ES.ToInteger(target);
      var relativeStart = ES.ToInteger(start);
      var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
      var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var relativeEnd = typeof end === 'undefined' ? len : ES.ToInteger(end);
      var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);
      var count = _min(finalItem - from, len - to);
      var direction = 1;
      if (from < to && to < (from + count)) {
        direction = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count > 0) {
        if (from in o) {
          o[to] = o[from];
        } else {
          delete o[to];
        }
        from += direction;
        to += direction;
        count -= 1;
      }
      return o;
    },

    fill: function fill(value) {
      var start;
      if (arguments.length > 1) {
        start = arguments[1];
      }
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var O = ES.ToObject(this);
      var len = ES.ToLength(O.length);
      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
      end = ES.ToInteger(typeof end === 'undefined' ? len : end);

      var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
      var relativeEnd = end < 0 ? len + end : end;

      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
        O[i] = value;
      }
      return O;
    },

    find: function find(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#find: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0, value; i < length; i++) {
        value = list[i];
        if (thisArg) {
          if (_call(predicate, thisArg, value, i, list)) {
            return value;
          }
        } else if (predicate(value, i, list)) {
          return value;
        }
      }
    },

    findIndex: function findIndex(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#findIndex: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0; i < length; i++) {
        if (thisArg) {
          if (_call(predicate, thisArg, list[i], i, list)) {
            return i;
          }
        } else if (predicate(list[i], i, list)) {
          return i;
        }
      }
      return -1;
    },

    keys: function keys() {
      return new ArrayIterator(this, 'key');
    },

    values: function values() {
      return new ArrayIterator(this, 'value');
    },

    entries: function entries() {
      return new ArrayIterator(this, 'entry');
    }
  };
  // Safari 7.1 defines Array#keys and Array#entries natively,
  // but the resulting ArrayIterator objects don't have a "next" method.
  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
    delete Array.prototype.keys;
  }
  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
    delete Array.prototype.entries;
  }

  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
    defineProperties(Array.prototype, {
      values: Array.prototype[$iterator$]
    });
    if (Type.symbol(Symbol.unscopables)) {
      Array.prototype[Symbol.unscopables].values = true;
    }
  }
  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
  if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {
    var originalArrayPrototypeValues = Array.prototype.values;
    overrideNative(Array.prototype, 'values', function values() { return ES.Call(originalArrayPrototypeValues, this, arguments); });
    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
  }
  defineProperties(Array.prototype, ArrayPrototypeShims);

  if (1 / [true].indexOf(true, -0) < 0) {
    // indexOf when given a position arg of -0 should return +0.
    // https://github.com/tc39/ecma262/pull/316
    defineProperty(Array.prototype, 'indexOf', function indexOf(searchElement) {
      var value = _arrayIndexOfApply(this, arguments);
      if (value === 0 && (1 / value) < 0) {
        return 0;
      }
      return value;
    }, true);
  }

  addIterator(Array.prototype, function () { return this.values(); });
  // Chrome defines keys/values/entries on Array, but doesn't give us
  // any way to identify its iterator.  So add our own shimmed field.
  if (Object.getPrototypeOf) {
    addIterator(Object.getPrototypeOf([].values()));
  }

  // note: this is positioned here because it relies on Array#entries
  var arrayFromSwallowsNegativeLengths = (function () {
    // Detects a Firefox bug in v32
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
    return valueOrFalseIfThrows(function () {
      return Array.from({ length: -1 }).length === 0;
    });
  }());
  var arrayFromHandlesIterables = (function () {
    // Detects a bug in Webkit nightly r181886
    var arr = Array.from([0].entries());
    return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
  }());
  if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
    overrideNative(Array, 'from', ArrayShims.from);
  }
  var arrayFromHandlesUndefinedMapFunction = (function () {
    // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,
    // but the spec doesn't care if it's provided or not - undefined doesn't throw.
    return valueOrFalseIfThrows(function () {
      return Array.from([0], void 0);
    });
  }());
  if (!arrayFromHandlesUndefinedMapFunction) {
    var origArrayFrom = Array.from;
    overrideNative(Array, 'from', function from(items) {
      if (arguments.length > 1 && typeof arguments[1] !== 'undefined') {
        return ES.Call(origArrayFrom, this, arguments);
      } else {
        return _call(origArrayFrom, this, items);
      }
    });
  }

  var int32sAsOne = -(Math.pow(2, 32) - 1);
  var toLengthsCorrectly = function (method, reversed) {
    var obj = { length: int32sAsOne };
    obj[reversed ? (obj.length >>> 0) - 1 : 0] = true;
    return valueOrFalseIfThrows(function () {
      _call(method, obj, function () {
        // note: in nonconforming browsers, this will be called
        // -1 >>> 0 times, which is 4294967295, so the throw matters.
        throw new RangeError('should not reach here');
      }, []);
      return true;
    });
  };
  if (!toLengthsCorrectly(Array.prototype.forEach)) {
    var originalForEach = Array.prototype.forEach;
    overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {
      return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.map)) {
    var originalMap = Array.prototype.map;
    overrideNative(Array.prototype, 'map', function map(callbackFn) {
      return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.filter)) {
    var originalFilter = Array.prototype.filter;
    overrideNative(Array.prototype, 'filter', function filter(callbackFn) {
      return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.some)) {
    var originalSome = Array.prototype.some;
    overrideNative(Array.prototype, 'some', function some(callbackFn) {
      return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.every)) {
    var originalEvery = Array.prototype.every;
    overrideNative(Array.prototype, 'every', function every(callbackFn) {
      return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.reduce)) {
    var originalReduce = Array.prototype.reduce;
    overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {
      return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);
    });
  }
  if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
    var originalReduceRight = Array.prototype.reduceRight;
    overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {
      return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);
    });
  }

  var lacksOctalSupport = Number('0o10') !== 8;
  var lacksBinarySupport = Number('0b10') !== 2;
  var trimsNonWhitespace = _some(nonWS, function (c) {
    return Number(c + 0 + c) === 0;
  });
  if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {
    var OrigNumber = Number;
    var binaryRegex = /^0b[01]+$/i;
    var octalRegex = /^0o[0-7]+$/i;
    // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
    var isBinary = binaryRegex.test.bind(binaryRegex);
    var isOctal = octalRegex.test.bind(octalRegex);
    var toPrimitive = function (O, hint) { // need to replace this with `es-to-primitive/es6`
      var result;
      if (typeof O.valueOf === 'function') {
        result = O.valueOf();
        if (Type.primitive(result)) {
          return result;
        }
      }
      if (typeof O.toString === 'function') {
        result = O.toString();
        if (Type.primitive(result)) {
          return result;
        }
      }
      throw new TypeError('No default value');
    };
    var hasNonWS = nonWSregex.test.bind(nonWSregex);
    var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);
    var NumberShim = (function () {
      // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.
      var NumberShim = function Number(value) {
        var primValue;
        if (arguments.length > 0) {
          primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');
        } else {
          primValue = 0;
        }
        if (typeof primValue === 'string') {
          primValue = ES.Call(trimShim, primValue);
          if (isBinary(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 2);
          } else if (isOctal(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 8);
          } else if (hasNonWS(primValue) || isBadHex(primValue)) {
            primValue = NaN;
          }
        }
        var receiver = this;
        var valueOfSucceeds = valueOrFalseIfThrows(function () {
          OrigNumber.prototype.valueOf.call(receiver);
          return true;
        });
        if (receiver instanceof NumberShim && !valueOfSucceeds) {
          return new OrigNumber(primValue);
        }
        return OrigNumber(primValue);
      };
      return NumberShim;
    }());
    wrapConstructor(OrigNumber, NumberShim, {});
    // this is necessary for ES3 browsers, where these properties are non-enumerable.
    defineProperties(NumberShim, {
      NaN: OrigNumber.NaN,
      MAX_VALUE: OrigNumber.MAX_VALUE,
      MIN_VALUE: OrigNumber.MIN_VALUE,
      NEGATIVE_INFINITY: OrigNumber.NEGATIVE_INFINITY,
      POSITIVE_INFINITY: OrigNumber.POSITIVE_INFINITY
    });
    /* eslint-disable no-undef, no-global-assign */
    Number = NumberShim;
    Value.redefine(globals, 'Number', NumberShim);
    /* eslint-enable no-undef, no-global-assign */
  }

  var maxSafeInteger = Math.pow(2, 53) - 1;
  defineProperties(Number, {
    MAX_SAFE_INTEGER: maxSafeInteger,
    MIN_SAFE_INTEGER: -maxSafeInteger,
    EPSILON: 2.220446049250313e-16,

    parseInt: globals.parseInt,
    parseFloat: globals.parseFloat,

    isFinite: numberIsFinite,

    isInteger: function isInteger(value) {
      return numberIsFinite(value) && ES.ToInteger(value) === value;
    },

    isSafeInteger: function isSafeInteger(value) {
      return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
    },

    isNaN: numberIsNaN
  });
  // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)
  defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);

  // Work around bugs in Array#find and Array#findIndex -- early
  // implementations skipped holes in sparse arrays. (Note that the
  // implementations of find/findIndex indirectly use shimmed
  // methods of Number, so this test has to happen down here.)
  /* eslint-disable no-sparse-arrays */
  if ([, 1].find(function () { return true; }) === 1) {
    overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);
  }
  if ([, 1].findIndex(function () { return true; }) !== 0) {
    overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);
  }
  /* eslint-enable no-sparse-arrays */

  var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
  var ensureEnumerable = function ensureEnumerable(obj, prop) {
    if (supportsDescriptors && isEnumerableOn(obj, prop)) {
      Object.defineProperty(obj, prop, { enumerable: false });
    }
  };
  var sliceArgs = function sliceArgs() {
    // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
    // and https://gist.github.com/WebReflection/4327762cb87a8c634a29
    var initial = Number(this);
    var len = arguments.length;
    var desiredArgCount = len - initial;
    var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
    for (var i = initial; i < len; ++i) {
      args[i - initial] = arguments[i];
    }
    return args;
  };
  var assignTo = function assignTo(source) {
    return function assignToSource(target, key) {
      target[key] = source[key];
      return target;
    };
  };
  var assignReducer = function (target, source) {
    var sourceKeys = keys(Object(source));
    var symbols;
    if (ES.IsCallable(Object.getOwnPropertySymbols)) {
      symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
    }
    return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);
  };

  var ObjectShims = {
    // 19.1.3.1
    assign: function (target, source) {
      var to = ES.ToObject(target, 'Cannot convert undefined or null to object');
      return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);
    },

    // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865
    is: function is(a, b) {
      return ES.SameValue(a, b);
    }
  };
  var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {
    // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
    // which is 72% slower than our shim, and Firefox 40's native implementation.
    var thrower = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(thrower, 'xy');
    } catch (e) {
      return thrower[1] === 'y';
    }
  }());
  if (assignHasPendingExceptions) {
    overrideNative(Object, 'assign', ObjectShims.assign);
  }
  defineProperties(Object, ObjectShims);

  if (supportsDescriptors) {
    var ES5ObjectShims = {
      // 19.1.3.9
      // shim from https://gist.github.com/WebReflection/5593554
      setPrototypeOf: (function (Object, magic) {
        var set;

        var checkArgs = function (O, proto) {
          if (!ES.TypeIsObject(O)) {
            throw new TypeError('cannot set prototype on a non-object');
          }
          if (!(proto === null || ES.TypeIsObject(proto))) {
            throw new TypeError('can only set prototype to an object or null' + proto);
          }
        };

        var setPrototypeOf = function (O, proto) {
          checkArgs(O, proto);
          _call(set, O, proto);
          return O;
        };

        try {
          // this works already in Firefox and Safari
          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
          _call(set, {}, null);
        } catch (e) {
          if (Object.prototype !== {}[magic]) {
            // IE < 11 cannot be shimmed
            return;
          }
          // probably Chrome or some old Mobile stock browser
          set = function (proto) {
            this[magic] = proto;
          };
          // please note that this will **not** work
          // in those browsers that do not inherit
          // __proto__ by mistake from Object.prototype
          // in these cases we should probably throw an error
          // or at least be informed about the issue
          setPrototypeOf.polyfill = setPrototypeOf(
            setPrototypeOf({}, null),
            Object.prototype
          ) instanceof Object;
          // setPrototypeOf.polyfill === true means it works as meant
          // setPrototypeOf.polyfill === false means it's not 100% reliable
          // setPrototypeOf.polyfill === undefined
          // or
          // setPrototypeOf.polyfill ==  null means it's not a polyfill
          // which means it works as expected
          // we can even delete Object.prototype.__proto__;
        }
        return setPrototypeOf;
      }(Object, '__proto__'))
    };

    defineProperties(Object, ES5ObjectShims);
  }

  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
  // but Object.create(null) does.
  if (Object.setPrototypeOf && Object.getPrototypeOf &&
      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
      Object.getPrototypeOf(Object.create(null)) === null) {
    (function () {
      var FAKENULL = Object.create(null);
      var gpo = Object.getPrototypeOf;
      var spo = Object.setPrototypeOf;
      Object.getPrototypeOf = function (o) {
        var result = gpo(o);
        return result === FAKENULL ? null : result;
      };
      Object.setPrototypeOf = function (o, p) {
        var proto = p === null ? FAKENULL : p;
        return spo(o, proto);
      };
      Object.setPrototypeOf.polyfill = false;
    }());
  }

  var objectKeysAcceptsPrimitives = !throwsError(function () { return Object.keys('foo'); });
  if (!objectKeysAcceptsPrimitives) {
    var originalObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      return originalObjectKeys(ES.ToObject(value));
    });
    keys = Object.keys;
  }
  var objectKeysRejectsRegex = throwsError(function () { return Object.keys(/a/g); });
  if (objectKeysRejectsRegex) {
    var regexRejectingObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      if (Type.regex(value)) {
        var regexKeys = [];
        for (var k in value) {
          if (_hasOwnProperty(value, k)) {
            _push(regexKeys, k);
          }
        }
        return regexKeys;
      }
      return regexRejectingObjectKeys(value);
    });
    keys = Object.keys;
  }

  if (Object.getOwnPropertyNames) {
    var objectGOPNAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyNames('foo'); });
    if (!objectGOPNAcceptsPrimitives) {
      var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
      overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
        var val = ES.ToObject(value);
        if (_toString(val) === '[object Window]') {
          try {
            return originalObjectGetOwnPropertyNames(val);
          } catch (e) {
            // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
            return _concat([], cachedWindowNames);
          }
        }
        return originalObjectGetOwnPropertyNames(val);
      });
    }
  }
  if (Object.getOwnPropertyDescriptor) {
    var objectGOPDAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyDescriptor('foo', 'bar'); });
    if (!objectGOPDAcceptsPrimitives) {
      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
      });
    }
  }
  if (Object.seal) {
    var objectSealAcceptsPrimitives = !throwsError(function () { return Object.seal('foo'); });
    if (!objectSealAcceptsPrimitives) {
      var originalObjectSeal = Object.seal;
      overrideNative(Object, 'seal', function seal(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectSeal(value);
      });
    }
  }
  if (Object.isSealed) {
    var objectIsSealedAcceptsPrimitives = !throwsError(function () { return Object.isSealed('foo'); });
    if (!objectIsSealedAcceptsPrimitives) {
      var originalObjectIsSealed = Object.isSealed;
      overrideNative(Object, 'isSealed', function isSealed(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsSealed(value);
      });
    }
  }
  if (Object.freeze) {
    var objectFreezeAcceptsPrimitives = !throwsError(function () { return Object.freeze('foo'); });
    if (!objectFreezeAcceptsPrimitives) {
      var originalObjectFreeze = Object.freeze;
      overrideNative(Object, 'freeze', function freeze(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectFreeze(value);
      });
    }
  }
  if (Object.isFrozen) {
    var objectIsFrozenAcceptsPrimitives = !throwsError(function () { return Object.isFrozen('foo'); });
    if (!objectIsFrozenAcceptsPrimitives) {
      var originalObjectIsFrozen = Object.isFrozen;
      overrideNative(Object, 'isFrozen', function isFrozen(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsFrozen(value);
      });
    }
  }
  if (Object.preventExtensions) {
    var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { return Object.preventExtensions('foo'); });
    if (!objectPreventExtensionsAcceptsPrimitives) {
      var originalObjectPreventExtensions = Object.preventExtensions;
      overrideNative(Object, 'preventExtensions', function preventExtensions(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectPreventExtensions(value);
      });
    }
  }
  if (Object.isExtensible) {
    var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { return Object.isExtensible('foo'); });
    if (!objectIsExtensibleAcceptsPrimitives) {
      var originalObjectIsExtensible = Object.isExtensible;
      overrideNative(Object, 'isExtensible', function isExtensible(value) {
        if (!ES.TypeIsObject(value)) { return false; }
        return originalObjectIsExtensible(value);
      });
    }
  }
  if (Object.getPrototypeOf) {
    var objectGetProtoAcceptsPrimitives = !throwsError(function () { return Object.getPrototypeOf('foo'); });
    if (!objectGetProtoAcceptsPrimitives) {
      var originalGetProto = Object.getPrototypeOf;
      overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {
        return originalGetProto(ES.ToObject(value));
      });
    }
  }

  var hasFlags = supportsDescriptors && (function () {
    var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');
    return desc && ES.IsCallable(desc.get);
  }());
  if (supportsDescriptors && !hasFlags) {
    var regExpFlagsGetter = function flags() {
      if (!ES.TypeIsObject(this)) {
        throw new TypeError('Method called on incompatible type: must be an object.');
      }
      var result = '';
      if (this.global) {
        result += 'g';
      }
      if (this.ignoreCase) {
        result += 'i';
      }
      if (this.multiline) {
        result += 'm';
      }
      if (this.unicode) {
        result += 'u';
      }
      if (this.sticky) {
        result += 'y';
      }
      return result;
    };

    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
  }

  var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function () {
    return String(new RegExp(/a/g, 'i')) === '/a/i';
  });
  var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && (function () {
    // Edge 0.12 supports flags fully, but does not support Symbol.match
    var regex = /./;
    regex[Symbol.match] = false;
    return RegExp(regex) === regex;
  }());

  var regexToStringIsGeneric = valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'abc' }) === '/abc/';
  });
  var regexToStringSupportsGenericFlags = regexToStringIsGeneric && valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'a', flags: 'b' }) === '/a/b';
  });
  if (!regexToStringIsGeneric || !regexToStringSupportsGenericFlags) {
    var origRegExpToString = RegExp.prototype.toString;
    defineProperty(RegExp.prototype, 'toString', function toString() {
      var R = ES.RequireObjectCoercible(this);
      if (Type.regex(R)) {
        return _call(origRegExpToString, R);
      }
      var pattern = $String(R.source);
      var flags = $String(R.flags);
      return '/' + pattern + '/' + flags;
    }, true);
    Value.preserveToString(RegExp.prototype.toString, origRegExpToString);
  }

  if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {
    var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get;
    var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'source') || {};
    var legacySourceGetter = function () {
      // prior to it being a getter, it's own + nonconfigurable
      return this.source;
    };
    var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;

    var OrigRegExp = RegExp;
    var RegExpShim = (function () {
      return function RegExp(pattern, flags) {
        var patternIsRegExp = ES.IsRegExp(pattern);
        var calledWithNew = this instanceof RegExp;
        if (!calledWithNew && patternIsRegExp && typeof flags === 'undefined' && pattern.constructor === RegExp) {
          return pattern;
        }

        var P = pattern;
        var F = flags;
        if (Type.regex(pattern)) {
          P = ES.Call(sourceGetter, pattern);
          F = typeof flags === 'undefined' ? ES.Call(flagsGetter, pattern) : flags;
          return new RegExp(P, F);
        } else if (patternIsRegExp) {
          P = pattern.source;
          F = typeof flags === 'undefined' ? pattern.flags : flags;
        }
        return new OrigRegExp(pattern, flags);
      };
    }());
    wrapConstructor(OrigRegExp, RegExpShim, {
      $input: true // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
    });
    /* eslint-disable no-undef, no-global-assign */
    RegExp = RegExpShim;
    Value.redefine(globals, 'RegExp', RegExpShim);
    /* eslint-enable no-undef, no-global-assign */
  }

  if (supportsDescriptors) {
    var regexGlobals = {
      input: '$_',
      lastMatch: '$&',
      lastParen: '$+',
      leftContext: '$`',
      rightContext: '$\''
    };
    _forEach(keys(regexGlobals), function (prop) {
      if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
        Value.getter(RegExp, regexGlobals[prop], function get() {
          return RegExp[prop];
        });
      }
    });
  }
  addDefaultSpecies(RegExp);

  var inverseEpsilon = 1 / Number.EPSILON;
  var roundTiesToEven = function roundTiesToEven(n) {
    // Even though this reduces down to `return n`, it takes advantage of built-in rounding.
    return (n + inverseEpsilon) - inverseEpsilon;
  };
  var BINARY_32_EPSILON = Math.pow(2, -23);
  var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
  var BINARY_32_MIN_VALUE = Math.pow(2, -126);
  var E = Math.E;
  var LOG2E = Math.LOG2E;
  var LOG10E = Math.LOG10E;
  var numberCLZ = Number.prototype.clz;
  delete Number.prototype.clz; // Safari 8 has Number#clz

  var MathShims = {
    acosh: function acosh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || value < 1) { return NaN; }
      if (x === 1) { return 0; }
      if (x === Infinity) { return x; }

      var xInvSquared = 1 / (x * x);
      if (x < 2) {
        return _log1p(x - 1 + (_sqrt(1 - xInvSquared) * x));
      }
      var halfX = x / 2;
      return _log1p(halfX + (_sqrt(1 - xInvSquared) * halfX) - 1) + (1 / LOG2E);
    },

    asinh: function asinh(value) {
      var x = Number(value);
      if (x === 0 || !globalIsFinite(x)) {
        return x;
      }

      var a = _abs(x);
      var aSquared = a * a;
      var s = _sign(x);
      if (a < 1) {
        return s * _log1p(a + (aSquared / (_sqrt(aSquared + 1) + 1)));
      }
      return s * (_log1p((a / 2) + (_sqrt(1 + (1 / aSquared)) * a / 2) - 1) + (1 / LOG2E));
    },

    atanh: function atanh(value) {
      var x = Number(value);

      if (x === 0) { return x; }
      if (x === -1) { return -Infinity; }
      if (x === 1) { return Infinity; }
      if (numberIsNaN(x) || x < -1 || x > 1) {
        return NaN;
      }

      var a = _abs(x);
      return _sign(x) * _log1p(2 * a / (1 - a)) / 2;
    },

    cbrt: function cbrt(value) {
      var x = Number(value);
      if (x === 0) { return x; }
      var negate = x < 0;
      var result;
      if (negate) { x = -x; }
      if (x === Infinity) {
        result = Infinity;
      } else {
        result = _exp(_log(x) / 3);
        // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
        result = ((x / (result * result)) + (2 * result)) / 3;
      }
      return negate ? -result : result;
    },

    clz32: function clz32(value) {
      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
      var x = Number(value);
      var number = ES.ToUint32(x);
      if (number === 0) {
        return 32;
      }
      return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * LOG2E);
    },

    cosh: function cosh(value) {
      var x = Number(value);
      if (x === 0) { return 1; } // +0 or -0
      if (numberIsNaN(x)) { return NaN; }
      if (!globalIsFinite(x)) { return Infinity; }

      var t = _exp(_abs(x) - 1);
      return (t + (1 / (t * E * E))) * (E / 2);
    },

    expm1: function expm1(value) {
      var x = Number(value);
      if (x === -Infinity) { return -1; }
      if (!globalIsFinite(x) || x === 0) { return x; }
      if (_abs(x) > 0.5) {
        return _exp(x) - 1;
      }
      // A more precise approximation using Taylor series expansion
      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
      var t = x;
      var sum = 0;
      var n = 1;
      while (sum + t !== sum) {
        sum += t;
        n += 1;
        t *= x / n;
      }
      return sum;
    },

    hypot: function hypot(x, y) {
      var result = 0;
      var largest = 0;
      for (var i = 0; i < arguments.length; ++i) {
        var value = _abs(Number(arguments[i]));
        if (largest < value) {
          result *= (largest / value) * (largest / value);
          result += 1;
          largest = value;
        } else {
          result += value > 0 ? (value / largest) * (value / largest) : value;
        }
      }
      return largest === Infinity ? Infinity : largest * _sqrt(result);
    },

    log2: function log2(value) {
      return _log(value) * LOG2E;
    },

    log10: function log10(value) {
      return _log(value) * LOG10E;
    },

    log1p: _log1p,

    sign: _sign,

    sinh: function sinh(value) {
      var x = Number(value);
      if (!globalIsFinite(x) || x === 0) { return x; }

      var a = _abs(x);
      if (a < 1) {
        var u = Math.expm1(a);
        return _sign(x) * u * (1 + (1 / (u + 1))) / 2;
      }
      var t = _exp(a - 1);
      return _sign(x) * (t - (1 / (t * E * E))) * (E / 2);
    },

    tanh: function tanh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || x === 0) { return x; }
      // can exit early at +-20 as JS loses precision for true value at this integer
      if (x >= 20) { return 1; }
      if (x <= -20) { return -1; }

      return (Math.expm1(x) - Math.expm1(-x)) / (_exp(x) + _exp(-x));
    },

    trunc: function trunc(value) {
      var x = Number(value);
      return x < 0 ? -_floor(-x) : _floor(x);
    },

    imul: function imul(x, y) {
      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
      var a = ES.ToUint32(x);
      var b = ES.ToUint32(y);
      var ah = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return (al * bl) + ((((ah * bl) + (al * bh)) << 16) >>> 0) | 0;
    },

    fround: function fround(x) {
      var v = Number(x);
      if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
        return v;
      }
      var sign = _sign(v);
      var abs = _abs(v);
      if (abs < BINARY_32_MIN_VALUE) {
        return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
      }
      // Veltkamp's splitting (?)
      var a = (1 + (BINARY_32_EPSILON / Number.EPSILON)) * abs;
      var result = a - (a - abs);
      if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
        return sign * Infinity;
      }
      return sign * result;
    }
  };

  var withinULPDistance = function withinULPDistance(result, expected, distance) {
    return _abs(1 - (result / expected)) / Number.EPSILON < (distance || 8);
  };

  defineProperties(Math, MathShims);
  // Chrome < 40 sinh returns  for large numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(710) === Infinity);
  // Chrome < 40 cosh returns  for large numbers
  defineProperty(Math, 'cosh', MathShims.cosh, Math.cosh(710) === Infinity);
  // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0
  defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
  // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)
  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
  // Chrome < 54 asinh returns  for large numbers and should not
  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(1e+300) === Infinity);
  // Chrome < 54 atanh incorrectly returns 0 for large numbers
  defineProperty(Math, 'atanh', MathShims.atanh, Math.atanh(1e-300) === 0);
  // Chrome 40 has an imprecise Math.tanh with very small numbers
  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
  // Chrome 40 loses Math.acosh precision with high numbers
  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
  // Chrome < 54 has an inaccurate acosh for EPSILON deltas
  defineProperty(Math, 'acosh', MathShims.acosh, !withinULPDistance(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
  // Firefox 38 on Windows
  defineProperty(Math, 'cbrt', MathShims.cbrt, !withinULPDistance(Math.cbrt(1e-300), 1e-100));
  // node 0.11 has an imprecise Math.sinh with very small numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
  var expm1OfTen = Math.expm1(10);
  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);
  // node v12.11 - v12.15 report NaN
  defineProperty(Math, 'hypot', MathShims.hypot, Math.hypot(Infinity, NaN) !== Infinity);

  var origMathRound = Math.round;
  // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12
  var roundHandlesBoundaryConditions = Math.round(0.5 - (Number.EPSILON / 4)) === 0 &&
    Math.round(-0.5 + (Number.EPSILON / 3.99)) === 1;

  // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.
  // This behavior should be governed by "round to nearest, ties to even mode"
  // see http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-type
  // These are the boundary cases where it breaks.
  var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
  var largestPositiveNumberWhereRoundBreaks = (2 * inverseEpsilon) - 1;
  var roundDoesNotIncreaseIntegers = [
    smallestPositiveNumberWhereRoundBreaks,
    largestPositiveNumberWhereRoundBreaks
  ].every(function (num) {
    return Math.round(num) === num;
  });
  defineProperty(Math, 'round', function round(x) {
    var floor = _floor(x);
    var ceil = floor === -1 ? -0 : floor + 1;
    return x - floor < 0.5 ? floor : ceil;
  }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
  Value.preserveToString(Math.round, origMathRound);

  var origImul = Math.imul;
  if (Math.imul(0xffffffff, 5) !== -5) {
    // Safari 6.1, at least, reports "0" for this value
    Math.imul = MathShims.imul;
    Value.preserveToString(Math.imul, origImul);
  }
  if (Math.imul.length !== 2) {
    // Safari 8.0.4 has a length of 1
    // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658
    overrideNative(Math, 'imul', function imul(x, y) {
      return ES.Call(origImul, Math, arguments);
    });
  }

  // Promises
  // Simplest possible implementation; use a 3rd-party library if you
  // want the best possible speed and/or long stack traces.
  var PromiseShim = (function () {
    var setTimeout = globals.setTimeout;
    // some environments don't have setTimeout - no way to shim here.
    if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }

    ES.IsPromise = function (promise) {
      if (!ES.TypeIsObject(promise)) {
        return false;
      }
      if (typeof promise._promise === 'undefined') {
        return false; // uninitialized, or missing our hidden field.
      }
      return true;
    };

    // "PromiseCapability" in the spec is what most promise implementations
    // call a "deferred".
    var PromiseCapability = function (C) {
      if (!ES.IsConstructor(C)) {
        throw new TypeError('Bad promise constructor');
      }
      var capability = this;
      var resolver = function (resolve, reject) {
        if (capability.resolve !== void 0 || capability.reject !== void 0) {
          throw new TypeError('Bad Promise implementation!');
        }
        capability.resolve = resolve;
        capability.reject = reject;
      };
      // Initialize fields to inform optimizers about the object shape.
      capability.resolve = void 0;
      capability.reject = void 0;
      capability.promise = new C(resolver);
      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
        throw new TypeError('Bad promise constructor');
      }
    };

    // find an appropriate setImmediate-alike
    var makeZeroTimeout;
    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
      makeZeroTimeout = function () {
        // from http://dbaron.org/log/20100309-faster-timeouts
        var timeouts = [];
        var messageName = 'zero-timeout-message';
        var setZeroTimeout = function (fn) {
          _push(timeouts, fn);
          window.postMessage(messageName, '*');
        };
        var handleMessage = function (event) {
          if (event.source === window && event.data === messageName) {
            event.stopPropagation();
            if (timeouts.length === 0) { return; }
            var fn = _shift(timeouts);
            fn();
          }
        };
        window.addEventListener('message', handleMessage, true);
        return setZeroTimeout;
      };
    }
    var makePromiseAsap = function () {
      // An efficient task-scheduler based on a pre-existing Promise
      // implementation, which we can use even if we override the
      // global Promise below (in order to workaround bugs)
      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
      var P = globals.Promise;
      var pr = P && P.resolve && P.resolve();
      return pr && function (task) {
        return pr.then(task);
      };
    };
    var enqueue = ES.IsCallable(globals.setImmediate) ?
      globals.setImmediate :
      typeof process === 'object' && process.nextTick ? process.nextTick : makePromiseAsap() ||
      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() : function (task) { setTimeout(task, 0); }); // fallback

    // Constants for Promise implementation
    var PROMISE_IDENTITY = function (x) { return x; };
    var PROMISE_THROWER = function (e) { throw e; };
    var PROMISE_PENDING = 0;
    var PROMISE_FULFILLED = 1;
    var PROMISE_REJECTED = 2;
    // We store fulfill/reject handlers and capabilities in a single array.
    var PROMISE_FULFILL_OFFSET = 0;
    var PROMISE_REJECT_OFFSET = 1;
    var PROMISE_CAPABILITY_OFFSET = 2;
    // This is used in an optimization for chaining promises via then.
    var PROMISE_FAKE_CAPABILITY = {};

    var enqueuePromiseReactionJob = function (handler, capability, argument) {
      enqueue(function () {
        promiseReactionJob(handler, capability, argument);
      });
    };

    var promiseReactionJob = function (handler, promiseCapability, argument) {
      var handlerResult, f;
      if (promiseCapability === PROMISE_FAKE_CAPABILITY) {
        // Fast case, when we don't actually need to chain through to a
        // (real) promiseCapability.
        return handler(argument);
      }
      try {
        handlerResult = handler(argument);
        f = promiseCapability.resolve;
      } catch (e) {
        handlerResult = e;
        f = promiseCapability.reject;
      }
      f(handlerResult);
    };

    var fulfillPromise = function (promise, value) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.fulfillReactionHandler0,
          _promise.reactionCapability0,
          value
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_FULFILL_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              value
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = value;
      _promise.state = PROMISE_FULFILLED;
      _promise.reactionLength = 0;
    };

    var rejectPromise = function (promise, reason) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.rejectReactionHandler0,
          _promise.reactionCapability0,
          reason
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_REJECT_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              reason
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = reason;
      _promise.state = PROMISE_REJECTED;
      _promise.reactionLength = 0;
    };

    var createResolvingFunctions = function (promise) {
      var alreadyResolved = false;
      var resolve = function (resolution) {
        var then;
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        if (resolution === promise) {
          return rejectPromise(promise, new TypeError('Self resolution'));
        }
        if (!ES.TypeIsObject(resolution)) {
          return fulfillPromise(promise, resolution);
        }
        try {
          then = resolution.then;
        } catch (e) {
          return rejectPromise(promise, e);
        }
        if (!ES.IsCallable(then)) {
          return fulfillPromise(promise, resolution);
        }
        enqueue(function () {
          promiseResolveThenableJob(promise, resolution, then);
        });
      };
      var reject = function (reason) {
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        return rejectPromise(promise, reason);
      };
      return { resolve: resolve, reject: reject };
    };

    var optimizedThen = function (then, thenable, resolve, reject) {
      // Optimization: since we discard the result, we can pass our
      // own then implementation a special hint to let it know it
      // doesn't have to create it.  (The PROMISE_FAKE_CAPABILITY
      // object is local to this implementation and unforgeable outside.)
      if (then === Promise$prototype$then) {
        _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);
      } else {
        _call(then, thenable, resolve, reject);
      }
    };
    var promiseResolveThenableJob = function (promise, thenable, then) {
      var resolvingFunctions = createResolvingFunctions(promise);
      var resolve = resolvingFunctions.resolve;
      var reject = resolvingFunctions.reject;
      try {
        optimizedThen(then, thenable, resolve, reject);
      } catch (e) {
        reject(e);
      }
    };

    var Promise$prototype, Promise$prototype$then;
    var Promise = (function () {
      var PromiseShim = function Promise(resolver) {
        if (!(this instanceof PromiseShim)) {
          throw new TypeError('Constructor Promise requires "new"');
        }
        if (this && this._promise) {
          throw new TypeError('Bad construction');
        }
        // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
        if (!ES.IsCallable(resolver)) {
          throw new TypeError('not a valid resolver');
        }
        var promise = emulateES6construct(this, PromiseShim, Promise$prototype, {
          _promise: {
            result: void 0,
            state: PROMISE_PENDING,
            // The first member of the "reactions" array is inlined here,
            // since most promises only have one reaction.
            // We've also exploded the 'reaction' object to inline the
            // "handler" and "capability" fields, since both fulfill and
            // reject reactions share the same capability.
            reactionLength: 0,
            fulfillReactionHandler0: void 0,
            rejectReactionHandler0: void 0,
            reactionCapability0: void 0
          }
        });
        var resolvingFunctions = createResolvingFunctions(promise);
        var reject = resolvingFunctions.reject;
        try {
          resolver(resolvingFunctions.resolve, reject);
        } catch (e) {
          reject(e);
        }
        return promise;
      };
      return PromiseShim;
    }());
    Promise$prototype = Promise.prototype;

    var _promiseAllResolver = function (index, values, capability, remaining) {
      var alreadyCalled = false;
      return function (x) {
        if (alreadyCalled) { return; }
        alreadyCalled = true;
        values[index] = x;
        if ((--remaining.count) === 0) {
          var resolve = capability.resolve;
          resolve(values); // call w/ this===undefined
        }
      };
    };

    var performPromiseAll = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var values = [];
      var remaining = { count: 1 };
      var next, nextValue;
      var index = 0;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        values[index] = void 0;
        var nextPromise = C.resolve(nextValue);
        var resolveElement = _promiseAllResolver(
          index,
          values,
          resultCapability,
          remaining
        );
        remaining.count += 1;
        optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);
        index += 1;
      }
      if ((--remaining.count) === 0) {
        var resolve = resultCapability.resolve;
        resolve(values); // call w/ this===undefined
      }
      return resultCapability.promise;
    };

    var performPromiseRace = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var next, nextValue, nextPromise;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            // NOTE: If iterable has no items, resulting promise will never
            // resolve; see:
            // https://github.com/domenic/promises-unwrapping/issues/75
            // https://bugs.ecmascript.org/show_bug.cgi?id=2515
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        nextPromise = C.resolve(nextValue);
        optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);
      }
      return resultCapability.promise;
    };

    defineProperties(Promise, {
      all: function all(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseAll(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      race: function race(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseRace(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      reject: function reject(reason) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        var capability = new PromiseCapability(C);
        var rejectFunc = capability.reject;
        rejectFunc(reason); // call with this===undefined
        return capability.promise;
      },

      resolve: function resolve(v) {
        // See https://esdiscuss.org/topic/fixing-promise-resolve for spec
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        if (ES.IsPromise(v)) {
          var constructor = v.constructor;
          if (constructor === C) {
            return v;
          }
        }
        var capability = new PromiseCapability(C);
        var resolveFunc = capability.resolve;
        resolveFunc(v); // call with this===undefined
        return capability.promise;
      }
    });

    defineProperties(Promise$prototype, {
      'catch': function (onRejected) {
        return this.then(null, onRejected);
      },

      then: function then(onFulfilled, onRejected) {
        var promise = this;
        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
        var C = ES.SpeciesConstructor(promise, Promise);
        var resultCapability;
        var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;
        if (returnValueIsIgnored && C === Promise) {
          resultCapability = PROMISE_FAKE_CAPABILITY;
        } else {
          resultCapability = new PromiseCapability(C);
        }
        // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)
        // Note that we've split the 'reaction' object into its two
        // components, "capabilities" and "handler"
        // "capabilities" is always equal to `resultCapability`
        var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;
        var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;
        var _promise = promise._promise;
        var value;
        if (_promise.state === PROMISE_PENDING) {
          if (_promise.reactionLength === 0) {
            _promise.fulfillReactionHandler0 = fulfillReactionHandler;
            _promise.rejectReactionHandler0 = rejectReactionHandler;
            _promise.reactionCapability0 = resultCapability;
          } else {
            var idx = 3 * (_promise.reactionLength - 1);
            _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;
            _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;
            _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;
          }
          _promise.reactionLength += 1;
        } else if (_promise.state === PROMISE_FULFILLED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            fulfillReactionHandler,
            resultCapability,
            value
          );
        } else if (_promise.state === PROMISE_REJECTED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            rejectReactionHandler,
            resultCapability,
            value
          );
        } else {
          throw new TypeError('unexpected Promise state');
        }
        return resultCapability.promise;
      }
    });
    // This helps the optimizer by ensuring that methods which take
    // capabilities aren't polymorphic.
    PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise);
    Promise$prototype$then = Promise$prototype.then;

    return Promise;
  }());

  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
  if (globals.Promise) {
    delete globals.Promise.accept;
    delete globals.Promise.defer;
    delete globals.Promise.prototype.chain;
  }

  if (typeof PromiseShim === 'function') {
    // export the Promise constructor.
    defineProperties(globals, { Promise: PromiseShim });
    // In Chrome 33 (and thereabouts) Promise is defined, but the
    // implementation is buggy in a number of ways.  Let's check subclassing
    // support to see if we have a buggy implementation.
    var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
      return S.resolve(42).then(function () {}) instanceof S;
    });
    var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () {
      return globals.Promise.reject(42).then(null, 5).then(null, noop);
    });
    var promiseRequiresObjectContext = throwsError(function () { return globals.Promise.call(3, noop); });
    // Promise.resolve() was errata'ed late in the ES6 process.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742
    //      https://code.google.com/p/v8/issues/detail?id=4161
    // It serves as a proxy for a number of other bugs in early Promise
    // implementations.
    var promiseResolveBroken = (function (Promise) {
      var p = Promise.resolve(5);
      p.constructor = {};
      var p2 = Promise.resolve(p);
      try {
        p2.then(null, noop).then(null, noop); // avoid "uncaught rejection" warnings in console
      } catch (e) {
        return true; // v8 native Promises break here https://code.google.com/p/chromium/issues/detail?id=575314
      }
      return p === p2; // This *should* be false!
    }(globals.Promise));

    // Chrome 46 (probably older too) does not retrieve a thenable's .then synchronously
    var getsThenSynchronously = supportsDescriptors && (function () {
      var count = 0;
      // eslint-disable-next-line getter-return
      var thenable = Object.defineProperty({}, 'then', { get: function () { count += 1; } });
      Promise.resolve(thenable);
      return count === 1;
    }());

    var BadResolverPromise = function BadResolverPromise(executor) {
      var p = new Promise(executor);
      executor(3, function () {});
      this.then = p.then;
      this.constructor = BadResolverPromise;
    };
    BadResolverPromise.prototype = Promise.prototype;
    BadResolverPromise.all = Promise.all;
    // Chrome Canary 49 (probably older too) has some implementation bugs
    var hasBadResolverPromise = valueOrFalseIfThrows(function () {
      return !!BadResolverPromise.all([1, 2]);
    });

    if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||
        !promiseRequiresObjectContext || promiseResolveBroken ||
        !getsThenSynchronously || hasBadResolverPromise) {
      /* globals Promise: true */
      /* eslint-disable no-undef, no-global-assign */
      Promise = PromiseShim;
      /* eslint-enable no-undef, no-global-assign */
      overrideNative(globals, 'Promise', PromiseShim);
    }
    if (Promise.all.length !== 1) {
      var origAll = Promise.all;
      overrideNative(Promise, 'all', function all(iterable) {
        return ES.Call(origAll, this, arguments);
      });
    }
    if (Promise.race.length !== 1) {
      var origRace = Promise.race;
      overrideNative(Promise, 'race', function race(iterable) {
        return ES.Call(origRace, this, arguments);
      });
    }
    if (Promise.resolve.length !== 1) {
      var origResolve = Promise.resolve;
      overrideNative(Promise, 'resolve', function resolve(x) {
        return ES.Call(origResolve, this, arguments);
      });
    }
    if (Promise.reject.length !== 1) {
      var origReject = Promise.reject;
      overrideNative(Promise, 'reject', function reject(r) {
        return ES.Call(origReject, this, arguments);
      });
    }
    ensureEnumerable(Promise, 'all');
    ensureEnumerable(Promise, 'race');
    ensureEnumerable(Promise, 'resolve');
    ensureEnumerable(Promise, 'reject');
    addDefaultSpecies(Promise);
  }

  // Map and Set require a true ES5 environment
  // Their fast path also requires that the environment preserve
  // property insertion order, which is not guaranteed by the spec.
  var testOrder = function (a) {
    var b = keys(_reduce(a, function (o, k) {
      o[k] = true;
      return o;
    }, {}));
    return a.join(':') === b.join(':');
  };
  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
  // some engines (eg, Chrome) only preserve insertion order for string keys
  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

  if (supportsDescriptors) {

    var fastkey = function fastkey(key, skipInsertionOrderCheck) {
      if (!skipInsertionOrderCheck && !preservesInsertionOrder) {
        return null;
      }
      if (isNullOrUndefined(key)) {
        return '^' + ES.ToString(key);
      } else if (typeof key === 'string') {
        return '$' + key;
      } else if (typeof key === 'number') {
        // note that -0 will get coerced to "0" when used as a property key
        if (!preservesNumericInsertionOrder) {
          return 'n' + key;
        }
        return key;
      } else if (typeof key === 'boolean') {
        return 'b' + key;
      }
      return null;
    };

    var emptyObject = function emptyObject() {
      // accomodate some older not-quite-ES5 browsers
      return Object.create ? Object.create(null) : {};
    };

    var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (entry) {
          if (!ES.TypeIsObject(entry)) {
            throw new TypeError('Iterator value ' + entry + ' is not an entry object');
          }
          map.set(entry[0], entry[1]);
        });
      } else if (iterable instanceof MapConstructor) {
        _call(MapConstructor.prototype.forEach, iterable, function (value, key) {
          map.set(key, value);
        });
      } else {
        var iter, adder;
        if (!isNullOrUndefined(iterable)) {
          adder = map.set;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextItem = next.value;
            try {
              if (!ES.TypeIsObject(nextItem)) {
                throw new TypeError('Iterator value ' + nextItem + ' is not an entry object');
              }
              _call(adder, map, nextItem[0], nextItem[1]);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };
    var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (value) {
          set.add(value);
        });
      } else if (iterable instanceof SetConstructor) {
        _call(SetConstructor.prototype.forEach, iterable, function (value) {
          set.add(value);
        });
      } else {
        var iter, adder;
        if (!isNullOrUndefined(iterable)) {
          adder = set.add;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextValue = next.value;
            try {
              _call(adder, set, nextValue);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };

    var collectionShims = {
      Map: (function () {

        var empty = {};

        var MapEntry = function MapEntry(key, value) {
          this.key = key;
          this.value = value;
          this.next = null;
          this.prev = null;
        };

        MapEntry.prototype.isRemoved = function isRemoved() {
          return this.key === empty;
        };

        var isMap = function isMap(map) {
          return !!map._es6map;
        };

        var requireMapSlot = function requireMapSlot(map, method) {
          if (!ES.TypeIsObject(map) || !isMap(map)) {
            throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(map));
          }
        };

        var MapIterator = function MapIterator(map, kind) {
          requireMapSlot(map, '[[MapIterator]]');
          this.head = map._head;
          this.i = this.head;
          this.kind = kind;
        };

        MapIterator.prototype = {
          isMapIterator: true,
          next: function next() {
            if (!this.isMapIterator) {
              throw new TypeError('Not a MapIterator');
            }
            var i = this.i;
            var kind = this.kind;
            var head = this.head;
            if (typeof this.i === 'undefined') {
              return iteratorResult();
            }
            while (i.isRemoved() && i !== head) {
              // back up off of removed entries
              i = i.prev;
            }
            // advance to next unreturned element.
            var result;
            while (i.next !== head) {
              i = i.next;
              if (!i.isRemoved()) {
                if (kind === 'key') {
                  result = i.key;
                } else if (kind === 'value') {
                  result = i.value;
                } else {
                  result = [i.key, i.value];
                }
                this.i = i;
                return iteratorResult(result);
              }
            }
            // once the iterator is done, it is done forever.
            this.i = void 0;
            return iteratorResult();
          }
        };
        addIterator(MapIterator.prototype);

        var Map$prototype;
        var MapShim = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          if (this && this._es6map) {
            throw new TypeError('Bad construction');
          }
          var map = emulateES6construct(this, Map, Map$prototype, {
            _es6map: true,
            _head: null,
            _map: OrigMap ? new OrigMap() : null,
            _size: 0,
            _storage: emptyObject()
          });

          var head = new MapEntry(null, null);
          // circular doubly-linked list.
          /* eslint no-multi-assign: 1 */
          head.next = head.prev = head;
          map._head = head;

          // Optionally initialize map from iterable
          if (arguments.length > 0) {
            addIterableToMap(Map, map, arguments[0]);
          }
          return map;
        };
        Map$prototype = MapShim.prototype;

        Value.getter(Map$prototype, 'size', function () {
          if (typeof this._size === 'undefined') {
            throw new TypeError('size method called on incompatible Map');
          }
          return this._size;
        });

        defineProperties(Map$prototype, {
          get: function get(key) {
            requireMapSlot(this, 'get');
            var entry;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              entry = this._storage[fkey];
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            if (this._map) {
              // fast object key path
              entry = origMapGet.call(this._map, key);
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return i.value;
              }
            }
          },

          has: function has(key) {
            requireMapSlot(this, 'has');
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              return typeof this._storage[fkey] !== 'undefined';
            }
            if (this._map) {
              // fast object key path
              return origMapHas.call(this._map, key);
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return true;
              }
            }
            return false;
          },

          set: function set(key, value) {
            requireMapSlot(this, 'set');
            var head = this._head;
            var i = head;
            var entry;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] !== 'undefined') {
                this._storage[fkey].value = value;
                return this;
              } else {
                entry = this._storage[fkey] = new MapEntry(key, value); /* eslint no-multi-assign: 1 */
                i = head.prev;
                // fall through
              }
            } else if (this._map) {
              // fast object key path
              if (origMapHas.call(this._map, key)) {
                origMapGet.call(this._map, key).value = value;
              } else {
                entry = new MapEntry(key, value);
                origMapSet.call(this._map, key, entry);
                i = head.prev;
                // fall through
              }
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.value = value;
                return this;
              }
            }
            entry = entry || new MapEntry(key, value);
            if (ES.SameValue(-0, key)) {
              entry.key = +0; // coerce -0 to +0 in entry
            }
            entry.next = this._head;
            entry.prev = this._head.prev;
            entry.prev.next = entry;
            entry.next.prev = entry;
            this._size += 1;
            return this;
          },

          'delete': function (key) {
            requireMapSlot(this, 'delete');
            var head = this._head;
            var i = head;
            var fkey = fastkey(key, true);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] === 'undefined') {
                return false;
              }
              i = this._storage[fkey].prev;
              delete this._storage[fkey];
              // fall through
            } else if (this._map) {
              // fast object key path
              if (!origMapHas.call(this._map, key)) {
                return false;
              }
              i = origMapGet.call(this._map, key).prev;
              origMapDelete.call(this._map, key);
              // fall through
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.key = empty;
                i.value = empty;
                i.prev.next = i.next;
                i.next.prev = i.prev;
                this._size -= 1;
                return true;
              }
            }
            return false;
          },

          clear: function clear() {
            /* eslint no-multi-assign: 1 */
            requireMapSlot(this, 'clear');
            this._map = OrigMap ? new OrigMap() : null;
            this._size = 0;
            this._storage = emptyObject();
            var head = this._head;
            var i = head;
            var p = i.next;
            while ((i = p) !== head) {
              i.key = empty;
              i.value = empty;
              p = i.next;
              i.next = i.prev = head;
            }
            head.next = head.prev = head;
          },

          keys: function keys() {
            requireMapSlot(this, 'keys');
            return new MapIterator(this, 'key');
          },

          values: function values() {
            requireMapSlot(this, 'values');
            return new MapIterator(this, 'value');
          },

          entries: function entries() {
            requireMapSlot(this, 'entries');
            return new MapIterator(this, 'key+value');
          },

          forEach: function forEach(callback) {
            requireMapSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var it = this.entries();
            for (var entry = it.next(); !entry.done; entry = it.next()) {
              if (context) {
                _call(callback, context, entry.value[1], entry.value[0], this);
              } else {
                callback(entry.value[1], entry.value[0], this);
              }
            }
          }
        });
        addIterator(Map$prototype, Map$prototype.entries);

        return MapShim;
      }()),

      Set: (function () {
        var isSet = function isSet(set) {
          return set._es6set && typeof set._storage !== 'undefined';
        };
        var requireSetSlot = function requireSetSlot(set, method) {
          if (!ES.TypeIsObject(set) || !isSet(set)) {
            // https://github.com/paulmillr/es6-shim/issues/176
            throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(set));
          }
        };

        // Creating a Map is expensive.  To speed up the common case of
        // Sets containing only string or numeric keys, we use an object
        // as backing storage and lazily create a full Map only when
        // required.
        var Set$prototype;
        var SetShim = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          if (this && this._es6set) {
            throw new TypeError('Bad construction');
          }
          var set = emulateES6construct(this, Set, Set$prototype, {
            _es6set: true,
            '[[SetData]]': null,
            _storage: emptyObject()
          });
          if (!set._es6set) {
            throw new TypeError('bad set');
          }

          // Optionally initialize Set from iterable
          if (arguments.length > 0) {
            addIterableToSet(Set, set, arguments[0]);
          }
          return set;
        };
        Set$prototype = SetShim.prototype;

        var decodeKey = function (key) {
          var k = key;
          if (k === '^null') {
            return null;
          } else if (k === '^undefined') {
            return void 0;
          } else {
            var first = k.charAt(0);
            if (first === '$') {
              return _strSlice(k, 1);
            } else if (first === 'n') {
              return +_strSlice(k, 1);
            } else if (first === 'b') {
              return k === 'btrue';
            }
          }
          return +k;
        };
        // Switch from the object backing storage to a full Map.
        var ensureMap = function ensureMap(set) {
          if (!set['[[SetData]]']) {
            var m = new collectionShims.Map();
            set['[[SetData]]'] = m;
            _forEach(keys(set._storage), function (key) {
              var k = decodeKey(key);
              m.set(k, k);
            });
            set['[[SetData]]'] = m;
          }
          set._storage = null; // free old backing storage
        };

        Value.getter(SetShim.prototype, 'size', function () {
          requireSetSlot(this, 'size');
          if (this._storage) {
            return keys(this._storage).length;
          }
          ensureMap(this);
          return this['[[SetData]]'].size;
        });

        defineProperties(SetShim.prototype, {
          has: function has(key) {
            requireSetSlot(this, 'has');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              return !!this._storage[fkey];
            }
            ensureMap(this);
            return this['[[SetData]]'].has(key);
          },

          add: function add(key) {
            requireSetSlot(this, 'add');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              this._storage[fkey] = true;
              return this;
            }
            ensureMap(this);
            this['[[SetData]]'].set(key, key);
            return this;
          },

          'delete': function (key) {
            requireSetSlot(this, 'delete');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              var hasFKey = _hasOwnProperty(this._storage, fkey);
              return (delete this._storage[fkey]) && hasFKey;
            }
            ensureMap(this);
            return this['[[SetData]]']['delete'](key);
          },

          clear: function clear() {
            requireSetSlot(this, 'clear');
            if (this._storage) {
              this._storage = emptyObject();
            }
            if (this['[[SetData]]']) {
              this['[[SetData]]'].clear();
            }
          },

          values: function values() {
            requireSetSlot(this, 'values');
            ensureMap(this);
            return new SetIterator(this['[[SetData]]'].values());
          },

          entries: function entries() {
            requireSetSlot(this, 'entries');
            ensureMap(this);
            return new SetIterator(this['[[SetData]]'].entries());
          },

          forEach: function forEach(callback) {
            requireSetSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var entireSet = this;
            ensureMap(entireSet);
            this['[[SetData]]'].forEach(function (value, key) {
              if (context) {
                _call(callback, context, key, key, entireSet);
              } else {
                callback(key, key, entireSet);
              }
            });
          }
        });
        defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);
        addIterator(SetShim.prototype, SetShim.prototype.values);

        var SetIterator = function SetIterator(it) {
          this.it = it;
        };
        SetIterator.prototype = {
          isSetIterator: true,
          next: function next() {
            if (!this.isSetIterator) {
              throw new TypeError('Not a SetIterator');
            }
            return this.it.next();
          }
        };
        addIterator(SetIterator.prototype);

        return SetShim;
      }())
    };

    var isGoogleTranslate = globals.Set && !Set.prototype['delete'] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray(new Set().keys);
    if (isGoogleTranslate) {
      // special-case force removal of wildly invalid Set implementation in Google Translate iframes
      // see https://github.com/paulmillr/es6-shim/issues/438 / https://twitter.com/ljharb/status/849335573114363904
      globals.Set = collectionShims.Set;
    }
    if (globals.Map || globals.Set) {
      // Safari 8, for example, doesn't accept an iterable.
      var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });
      if (!mapAcceptsArguments) {
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMap();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, globals.Map.prototype);
          return m;
        };
        globals.Map.prototype = create(OrigMap.prototype);
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMap);
      }
      var testMap = new Map();
      var mapUsesSameValueZero = (function () {
        // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4
        var m = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);
        m.set(-0, m);
        return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);
      }());
      var mapSupportsChaining = testMap.set(1, 2) === testMap;
      if (!mapUsesSameValueZero || !mapSupportsChaining) {
        overrideNative(Map.prototype, 'set', function set(k, v) {
          _call(origMapSet, this, k === 0 ? 0 : k, v);
          return this;
        });
      }
      if (!mapUsesSameValueZero) {
        defineProperties(Map.prototype, {
          get: function get(k) {
            return _call(origMapGet, this, k === 0 ? 0 : k);
          },
          has: function has(k) {
            return _call(origMapHas, this, k === 0 ? 0 : k);
          }
        }, true);
        Value.preserveToString(Map.prototype.get, origMapGet);
        Value.preserveToString(Map.prototype.has, origMapHas);
      }
      var testSet = new Set();
      var setUsesSameValueZero = Set.prototype['delete'] && Set.prototype.add && Set.prototype.has && (function (s) {
        s['delete'](0);
        s.add(-0);
        return !s.has(0);
      }(testSet));
      var setSupportsChaining = testSet.add(1) === testSet;
      if (!setUsesSameValueZero || !setSupportsChaining) {
        var origSetAdd = Set.prototype.add;
        Set.prototype.add = function add(v) {
          _call(origSetAdd, this, v === 0 ? 0 : v);
          return this;
        };
        Value.preserveToString(Set.prototype.add, origSetAdd);
      }
      if (!setUsesSameValueZero) {
        var origSetHas = Set.prototype.has;
        Set.prototype.has = function has(v) {
          return _call(origSetHas, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype.has, origSetHas);
        var origSetDel = Set.prototype['delete'];
        Set.prototype['delete'] = function SetDelete(v) {
          return _call(origSetDel, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype['delete'], origSetDel);
      }
      var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {
        var m = new M([]);
        // Firefox 32 is ok with the instantiating the subclass but will
        // throw when the map is used.
        m.set(42, 42);
        return m instanceof M;
      });
      // without Object.setPrototypeOf, subclassing is not possible
      var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing;
      var mapRequiresNew = (function () {
        try {
          return !(globals.Map() instanceof globals.Map);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMap();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, Map.prototype);
          return m;
        };
        globals.Map.prototype = OrigMap.prototype;
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMap);
      }
      var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {
        var s = new S([]);
        s.add(42, 42);
        return s instanceof S;
      });
      // without Object.setPrototypeOf, subclassing is not possible
      var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing;
      var setRequiresNew = (function () {
        try {
          return !(globals.Set() instanceof globals.Set);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
        var OrigSet = globals.Set;
        globals.Set = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          var s = new OrigSet();
          if (arguments.length > 0) {
            addIterableToSet(Set, s, arguments[0]);
          }
          delete s.constructor;
          Object.setPrototypeOf(s, Set.prototype);
          return s;
        };
        globals.Set.prototype = OrigSet.prototype;
        defineProperty(globals.Set.prototype, 'constructor', globals.Set, true);
        Value.preserveToString(globals.Set, OrigSet);
      }
      var newMap = new globals.Map();
      var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {
        return newMap.keys().next().done;
      });
      /*
        - In Firefox < 23, Map#size is a function.
        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
        - In Firefox 24, Map and Set do not implement forEach
        - In Firefox 25 at least, Map and Set are callable without "new"
      */
      if (
        typeof globals.Map.prototype.clear !== 'function' ||
        new globals.Set().size !== 0 ||
        newMap.size !== 0 ||
        typeof globals.Map.prototype.keys !== 'function' ||
        typeof globals.Set.prototype.keys !== 'function' ||
        typeof globals.Map.prototype.forEach !== 'function' ||
        typeof globals.Set.prototype.forEach !== 'function' ||
        isCallableWithoutNew(globals.Map) ||
        isCallableWithoutNew(globals.Set) ||
        typeof newMap.keys().next !== 'function' || // Safari 8
        mapIterationThrowsStopIterator || // Firefox 25
        !mapSupportsSubclassing
      ) {
        defineProperties(globals, {
          Map: collectionShims.Map,
          Set: collectionShims.Set
        }, true);
      }

      if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
        // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190
        defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
      }

      // Shim incomplete iterator implementations.
      addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
      addIterator(Object.getPrototypeOf((new globals.Set()).keys()));

      if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {
        // Microsoft Edge v0.11.10074.0 is missing a name on Set#has
        var anonymousSetHas = globals.Set.prototype.has;
        overrideNative(globals.Set.prototype, 'has', function has(key) {
          return _call(anonymousSetHas, this, key);
        });
      }
    }
    defineProperties(globals, collectionShims);
    addDefaultSpecies(globals.Map);
    addDefaultSpecies(globals.Set);
  }

  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
    if (!ES.TypeIsObject(target)) {
      throw new TypeError('target must be an object');
    }
  };

  // Some Reflect methods are basically the same as
  // those on the Object global, except that a TypeError is thrown if
  // target isn't an object. As well as returning a boolean indicating
  // the success of the operation.
  var ReflectShims = {
    // Apply method in a functional form.
    apply: function apply() {
      return ES.Call(ES.Call, null, arguments);
    },

    // New operator in a functional form.
    construct: function construct(constructor, args) {
      if (!ES.IsConstructor(constructor)) {
        throw new TypeError('First argument must be a constructor.');
      }
      var newTarget = arguments.length > 2 ? arguments[2] : constructor;
      if (!ES.IsConstructor(newTarget)) {
        throw new TypeError('new.target must be a constructor.');
      }
      return ES.Construct(constructor, args, newTarget, 'internal');
    },

    // When deleting a non-existent or configurable property,
    // true is returned.
    // When attempting to delete a non-configurable property,
    // it will return false.
    deleteProperty: function deleteProperty(target, key) {
      throwUnlessTargetIsObject(target);
      if (supportsDescriptors) {
        var desc = Object.getOwnPropertyDescriptor(target, key);

        if (desc && !desc.configurable) {
          return false;
        }
      }

      // Will return true.
      return delete target[key];
    },

    has: function has(target, key) {
      throwUnlessTargetIsObject(target);
      return key in target;
    }
  };

  if (Object.getOwnPropertyNames) {
    Object.assign(ReflectShims, {
      // Basically the result of calling the internal [[OwnPropertyKeys]].
      // Concatenating propertyNames and propertySymbols should do the trick.
      // This should continue to work together with a Symbol shim
      // which overrides Object.getOwnPropertyNames and implements
      // Object.getOwnPropertySymbols.
      ownKeys: function ownKeys(target) {
        throwUnlessTargetIsObject(target);
        var keys = Object.getOwnPropertyNames(target);

        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
          _pushApply(keys, Object.getOwnPropertySymbols(target));
        }

        return keys;
      }
    });
  }

  var callAndCatchException = function ConvertExceptionToBoolean(func) {
    return !throwsError(func);
  };

  if (Object.preventExtensions) {
    Object.assign(ReflectShims, {
      isExtensible: function isExtensible(target) {
        throwUnlessTargetIsObject(target);
        return Object.isExtensible(target);
      },
      preventExtensions: function preventExtensions(target) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          return Object.preventExtensions(target);
        });
      }
    });
  }

  if (supportsDescriptors) {
    var internalGet = function get(target, key, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent === null) {
          return void 0;
        }

        return internalGet(parent, key, receiver);
      }

      if ('value' in desc) {
        return desc.value;
      }

      if (desc.get) {
        return ES.Call(desc.get, receiver);
      }

      return void 0;
    };

    var internalSet = function set(target, key, value, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent !== null) {
          return internalSet(parent, key, value, receiver);
        }

        desc = {
          value: void 0,
          writable: true,
          enumerable: true,
          configurable: true
        };
      }

      if ('value' in desc) {
        if (!desc.writable) {
          return false;
        }

        if (!ES.TypeIsObject(receiver)) {
          return false;
        }

        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

        if (existingDesc) {
          return Reflect.defineProperty(receiver, key, {
            value: value
          });
        } else {
          return Reflect.defineProperty(receiver, key, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }

      if (desc.set) {
        _call(desc.set, receiver, value);
        return true;
      }

      return false;
    };

    Object.assign(ReflectShims, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          return Object.defineProperty(target, propertyKey, attributes);
        });
      },

      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        throwUnlessTargetIsObject(target);
        return Object.getOwnPropertyDescriptor(target, propertyKey);
      },

      // Syntax in a functional form.
      get: function get(target, key) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 2 ? arguments[2] : target;

        return internalGet(target, key, receiver);
      },

      set: function set(target, key, value) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 3 ? arguments[3] : target;

        return internalSet(target, key, value, receiver);
      }
    });
  }

  if (Object.getPrototypeOf) {
    var objectDotGetPrototypeOf = Object.getPrototypeOf;
    ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
      throwUnlessTargetIsObject(target);
      return objectDotGetPrototypeOf(target);
    };
  }

  if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
    var willCreateCircularPrototype = function (object, lastProto) {
      var proto = lastProto;
      while (proto) {
        if (object === proto) {
          return true;
        }
        proto = ReflectShims.getPrototypeOf(proto);
      }
      return false;
    };

    Object.assign(ReflectShims, {
      // Sets the prototype of the given object.
      // Returns true on success, otherwise false.
      setPrototypeOf: function setPrototypeOf(object, proto) {
        throwUnlessTargetIsObject(object);
        if (proto !== null && !ES.TypeIsObject(proto)) {
          throw new TypeError('proto must be an object or null');
        }

        // If they already are the same, we're done.
        if (proto === Reflect.getPrototypeOf(object)) {
          return true;
        }

        // Cannot alter prototype if object not extensible.
        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
          return false;
        }

        // Ensure that we do not create a circular prototype chain.
        if (willCreateCircularPrototype(object, proto)) {
          return false;
        }

        Object.setPrototypeOf(object, proto);

        return true;
      }
    });
  }
  var defineOrOverrideReflectProperty = function (key, shim) {
    if (!ES.IsCallable(globals.Reflect[key])) {
      defineProperty(globals.Reflect, key, shim);
    } else {
      var acceptsPrimitives = valueOrFalseIfThrows(function () {
        globals.Reflect[key](1);
        globals.Reflect[key](NaN);
        globals.Reflect[key](true);
        return true;
      });
      if (acceptsPrimitives) {
        overrideNative(globals.Reflect, key, shim);
      }
    }
  };
  Object.keys(ReflectShims).forEach(function (key) {
    defineOrOverrideReflectProperty(key, ReflectShims[key]);
  });
  var originalReflectGetProto = globals.Reflect.getPrototypeOf;
  if (functionsHaveNames && originalReflectGetProto && originalReflectGetProto.name !== 'getPrototypeOf') {
    overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {
      return _call(originalReflectGetProto, globals.Reflect, target);
    });
  }
  if (globals.Reflect.setPrototypeOf) {
    if (valueOrFalseIfThrows(function () {
      globals.Reflect.setPrototypeOf(1, {});
      return true;
    })) {
      overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);
    }
  }
  if (globals.Reflect.defineProperty) {
    if (!valueOrFalseIfThrows(function () {
      var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });
      // "extensible" fails on Edge 0.12
      var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});
      return basic && extensible;
    })) {
      overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);
    }
  }
  if (globals.Reflect.construct) {
    if (!valueOrFalseIfThrows(function () {
      var F = function F() {};
      return globals.Reflect.construct(function () {}, [], F) instanceof F;
    })) {
      overrideNative(globals.Reflect, 'construct', ReflectShims.construct);
    }
  }

  if (String(new Date(NaN)) !== 'Invalid Date') {
    var dateToString = Date.prototype.toString;
    var shimmedDateToString = function toString() {
      var valueOf = +this;
      if (valueOf !== valueOf) {
        return 'Invalid Date';
      }
      return ES.Call(dateToString, this);
    };
    overrideNative(Date.prototype, 'toString', shimmedDateToString);
  }

  // Annex B HTML methods
  // http://www.ecma-international.org/ecma-262/6.0/#sec-additional-properties-of-the-string.prototype-object
  var stringHTMLshims = {
    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
  };
  _forEach(Object.keys(stringHTMLshims), function (key) {
    var method = String.prototype[key];
    var shouldOverwrite = false;
    if (ES.IsCallable(method)) {
      var output = _call(method, '', ' " ');
      var quotesCount = _concat([], output.match(/"/g)).length;
      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
    } else {
      shouldOverwrite = true;
    }
    if (shouldOverwrite) {
      overrideNative(String.prototype, key, stringHTMLshims[key]);
    }
  });

  var JSONstringifiesSymbols = (function () {
    // Microsoft Edge v0.12 stringifies Symbols incorrectly
    if (!hasSymbols) { return false; } // Symbols are not supported
    var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;
    if (!stringify) { return false; } // JSON.stringify is not supported
    if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`
    if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`
    var obj = { a: Symbol() };
    obj[Symbol()] = true;
    if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted
    return false;
  }());
  var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {
    // Chrome 45 throws on stringifying object symbols
    if (!hasSymbols) { return true; } // Symbols are not supported
    return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';
  });
  if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
    var origStringify = JSON.stringify;
    overrideNative(JSON, 'stringify', function stringify(value) {
      if (typeof value === 'symbol') { return; }
      var replacer;
      if (arguments.length > 1) {
        replacer = arguments[1];
      }
      var args = [value];
      if (!isArray(replacer)) {
        var replaceFn = ES.IsCallable(replacer) ? replacer : null;
        var wrappedReplacer = function (key, val) {
          var parsedValue = replaceFn ? _call(replaceFn, this, key, val) : val;
          if (typeof parsedValue !== 'symbol') {
            if (Type.symbol(parsedValue)) {
              return assignTo({})(parsedValue);
            } else {
              return parsedValue;
            }
          }
        };
        args.push(wrappedReplacer);
      } else {
        // create wrapped replacer that handles an array replacer?
        args.push(replacer);
      }
      if (arguments.length > 2) {
        args.push(arguments[2]);
      }
      return origStringify.apply(this, args);
    });
  }

  return globals;
}));</script>
  <script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var proto = require('./Array.prototype');

module.exports = {
	prototype: proto,
	shim: function shimArray() {
		proto.shim();
	}
};

},{"./Array.prototype":3}],2:[function(require,module,exports){
'use strict';

module.exports = require('array-includes');

},{"array-includes":14}],3:[function(require,module,exports){
'use strict';

var includes = require('./Array.prototype.includes');

module.exports = {
	includes: includes,
	shim: function shimArrayPrototype() {
		includes.shim();
	}
};

},{"./Array.prototype.includes":2}],4:[function(require,module,exports){
'use strict';

var getDescriptors = require('object.getownpropertydescriptors');
var entries = require('object.entries');
var values = require('object.values');

module.exports = {
	entries: entries,
	getOwnPropertyDescriptors: getDescriptors,
	shim: function shimObject() {
		getDescriptors.shim();
		entries.shim();
		values.shim();
	},
	values: values
};

},{"object.entries":38,"object.getownpropertydescriptors":64,"object.values":89}],5:[function(require,module,exports){
'use strict';

var stringPrototype = require('./String.prototype');

module.exports = {
	prototype: stringPrototype,
	shim: function shimString() {
		stringPrototype.shim();
	}
};

},{"./String.prototype":7}],6:[function(require,module,exports){
'use strict';

module.exports = require('string-at');

},{"string-at":114}],7:[function(require,module,exports){
'use strict';

var at = require('./String.prototype.at');
var padStart = require('./String.prototype.padStart');
var padEnd = require('./String.prototype.padEnd');
var trimLeft = require('./String.prototype.trimLeft');
var trimRight = require('./String.prototype.trimRight');

module.exports = {
	at: at,
	padStart: padStart,
	padEnd: padEnd,
	trimLeft: trimLeft,
	trimRight: trimRight,
	shim: function shimStringPrototype() {
		at.shim();
		padStart.shim();
		padEnd.shim();
		trimLeft.shim();
		trimRight.shim();
	}
};

},{"./String.prototype.at":6,"./String.prototype.padEnd":8,"./String.prototype.padStart":9,"./String.prototype.trimLeft":10,"./String.prototype.trimRight":11}],8:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.padend');

},{"string.prototype.padend":137}],9:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.padstart');

},{"string.prototype.padstart":162}],10:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.trimleft');

},{"string.prototype.trimleft":187}],11:[function(require,module,exports){
'use strict';

module.exports = require('string.prototype.trimright');

},{"string.prototype.trimright":197}],12:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es7-shim
 * @license es7-shim Copyright 2014 by contributors, MIT License
 * see https://github.com/es-shims/es7-shim/blob/master/LICENSE
 */

'use strict';

var $Array = require('./Array');
var $Object = require('./Object');
var $String = require('./String');

module.exports = {
	Array: $Array,
	Object: $Object,
	String: $String,
	shim: function shimES7() {
		$Array.shim();
		$Object.shim();
		$String.shim();
	}
};

},{"./Array":1,"./Object":4,"./String":5}],13:[function(require,module,exports){
(function (global){
'use strict';

var ES = require('es-abstract/es6');
var $isNaN = Number.isNaN || function (a) { return a !== a; };
var $isFinite = Number.isFinite || function (n) { return typeof n === 'number' && global.isFinite(n); };
var indexOf = Array.prototype.indexOf;

module.exports = function includes(searchElement) {
	var fromIndex = arguments.length > 1 ? ES.ToInteger(arguments[1]) : 0;
	if (indexOf && !$isNaN(searchElement) && $isFinite(fromIndex) && typeof searchElement !== 'undefined') {
		return indexOf.apply(this, arguments) > -1;
	}

	var O = ES.ToObject(this);
	var length = ES.ToLength(O.length);
	if (length === 0) {
		return false;
	}
	var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);
	while (k < length) {
		if (ES.SameValueZero(searchElement, O[k])) {
			return true;
		}
		k += 1;
	}
	return false;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"es-abstract/es6":17}],14:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var ES = require('es-abstract/es6');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var polyfill = getPolyfill();
var shim = require('./shim');

var slice = Array.prototype.slice;

/* eslint-disable no-unused-vars */
var boundIncludesShim = function includes(array, searchElement) {
/* eslint-enable no-unused-vars */
	ES.RequireObjectCoercible(array);
	return polyfill.apply(array, slice.call(arguments, 1));
};
define(boundIncludesShim, {
	implementation: implementation,
	getPolyfill: getPolyfill,
	shim: shim
});

module.exports = boundIncludesShim;

},{"./implementation":13,"./polyfill":35,"./shim":36,"define-properties":15,"es-abstract/es6":17}],15:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var foreach = require('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"foreach":26,"object-keys":33}],16:[function(require,module,exports){
'use strict';

var $isNaN = Number.isNaN || function (a) { return a !== a; };
var $isFinite = require('./helpers/isFinite');

var sign = require('./helpers/sign');
var mod = require('./helpers/mod');

var IsCallable = require('is-callable');
var toPrimitive = require('es-to-primitive/es5');

// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: toPrimitive,

	ToBoolean: function ToBoolean(value) {
		return Boolean(value);
	},
	ToNumber: function ToNumber(value) {
		return Number(value);
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number)) { return 0; }
		if (number === 0 || !$isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new TypeError(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: IsCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
        return $isNaN(x) && $isNaN(y);
	}
};

module.exports = ES5;

},{"./helpers/isFinite":19,"./helpers/mod":21,"./helpers/sign":22,"es-to-primitive/es5":23,"is-callable":29}],17:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;

var $isNaN = Number.isNaN || function (a) { return a !== a; };
var $isFinite = require('./helpers/isFinite');
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var assign = require('./helpers/assign');
var sign = require('./helpers/sign');
var mod = require('./helpers/mod');
var isPrimitive = require('./helpers/isPrimitive');
var toPrimitive = require('es-to-primitive/es6');
var parseInteger = parseInt;
var bind = require('function-bind');
var strSlice = bind.call(Function.call, String.prototype.slice);
var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
var invalidHexLiteral = /^[\-\+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);

// whitespace from: http://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var replace = bind.call(Function.call, String.prototype.replace);
var trim = function (value) {
	return replace(value, trimRegex, '');
};

var ES5 = require('./es5');

var hasRegExpMatcher = require('is-regex');

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
var ES6 = assign(assign({}, ES5), {

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	Call: function Call(F, V) {
		var args = arguments.length > 2 ? arguments[2] : [];
		if (!this.IsCallable(F)) {
			throw new TypeError(F + ' is not a function');
		}
		return F.apply(V, args);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
	ToPrimitive: toPrimitive,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
	// ToBoolean: ES5.ToBoolean,

	// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
	ToNumber: function ToNumber(argument) {
		var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
		if (typeof value === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a number');
		}
		if (typeof value === 'string') {
			if (isBinary(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 2));
			} else if (isOctal(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 8));
			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
				return NaN;
			} else {
				var trimmed = trim(value);
				if (trimmed !== value) {
					return this.ToNumber(trimmed);
				}
			}
		}
		return Number(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
	// ToInteger: ES5.ToNumber,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
	// ToInt32: ES5.ToInt32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
	// ToUint32: ES5.ToUint32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
	ToInt16: function ToInt16(argument) {
		var int16bit = this.ToUint16(argument);
		return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
	// ToUint16: ES5.ToUint16,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
	ToInt8: function ToInt8(argument) {
		var int8bit = this.ToUint8(argument);
		return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
	ToUint8: function ToUint8(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x100);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
	ToUint8Clamp: function ToUint8Clamp(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number <= 0) { return 0; }
		if (number >= 0xFF) { return 0xFF; }
		var f = Math.floor(argument);
		if (f + 0.5 < number) { return f + 1; }
		if (number < f + 0.5) { return f; }
		if (f % 2 !== 0) { return f + 1; }
		return f;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
	ToString: function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a string');
		}
		return String(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
	ToObject: function ToObject(value) {
		this.RequireObjectCoercible(value);
		return Object(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
	ToPropertyKey: function ToPropertyKey(argument) {
		var key = this.ToPrimitive(argument, String);
		return typeof key === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	ToLength: function ToLength(argument) {
		var len = this.ToInteger(argument);
		if (len <= 0) { return 0; } // includes converting -0 to +0
		if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
		return len;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-canonicalnumericindexstring
	CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
		if (toStr.call(argument) !== '[object String]') {
			throw new TypeError('must be a string');
		}
		if (argument === '-0') { return -0; }
		var n = this.ToNumber(argument);
		if (this.SameValue(this.ToString(n), argument)) { return n; }
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
	RequireObjectCoercible: ES5.CheckObjectCoercible,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
	IsArray: Array.isArray || function IsArray(argument) {
		return toStr.call(argument) === '[object Array]';
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
	// IsCallable: ES5.IsCallable,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
	IsConstructor: function IsConstructor(argument) {
		return this.IsCallable(argument); // unfortunately there's no way to truly check this without try/catch `new argument`
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
	IsExtensible: function IsExtensible(obj) {
		if (!Object.preventExtensions) { return true; }
		if (isPrimitive(obj)) {
			return false;
		}
		return Object.isExtensible(obj);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
	IsInteger: function IsInteger(argument) {
		if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
			return false;
		}
		var abs = Math.abs(argument);
		return Math.floor(abs) === abs;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
	IsPropertyKey: function IsPropertyKey(argument) {
		return typeof argument === 'string' || typeof argument === 'symbol';
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
	IsRegExp: function IsRegExp(argument) {
		if (!argument || typeof argument !== 'object') {
			return false;
		}
		if (hasSymbols) {
			var isRegExp = RegExp[Symbol.match];
			if (typeof isRegExp !== 'undefined') {
				return ES5.ToBoolean(isRegExp);
			}
		}
		return hasRegExpMatcher(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
	// SameValue: ES5.SameValue,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
	SameValueZero: function SameValueZero(x, y) {
		return (x === y) || ($isNaN(x) && $isNaN(y));
	}
});

delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

module.exports = ES6;

},{"./es5":16,"./helpers/assign":18,"./helpers/isFinite":19,"./helpers/isPrimitive":20,"./helpers/mod":21,"./helpers/sign":22,"es-to-primitive/es6":24,"function-bind":28,"is-regex":31}],18:[function(require,module,exports){
var has = Object.prototype.hasOwnProperty;
module.exports = Object.assign || function assign(target, source) {
	for (var key in source) {
		if (has.call(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
};

},{}],19:[function(require,module,exports){
var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

},{}],20:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],21:[function(require,module,exports){
module.exports = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};

},{}],22:[function(require,module,exports){
module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};

},{}],23:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable');

// https://es5.github.io/#x8.12
var ES5internalSlots = {
	'[[DefaultValue]]': function (O, hint) {
		var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// https://es5.github.io/#x9
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
};

},{"./helpers/isPrimitive":25,"is-callable":29}],24:[function(require,module,exports){
'use strict';

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');
var isCallable = require('is-callable');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (PreferredType === String) {
			hint = 'string';
		} else if (PreferredType === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"./helpers/isPrimitive":25,"is-callable":29,"is-date-object":30,"is-symbol":32}],25:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],26:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],27:[function(require,module,exports){
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],28:[function(require,module,exports){
var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":27}],29:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFn(value) {
	try {
		var fnStr = fnToStr.call(value);
		var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
		var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
		var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
		return constructorRegex.test(spaceStripped);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionObject(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],30:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],31:[function(require,module,exports){
'use strict';

var regexExec = RegExp.prototype.exec;
var tryRegexExec = function tryRegexExec(value) {
	try {
		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;
};

},{}],32:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') { return false; }
		return symStringRegex.test(symToStr.call(value));
	};
	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') { return true; }
		if (toStr.call(value) !== '[object Symbol]') { return false; }
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {
	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false;
	};
}

},{}],33:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var blacklistedKeys = {
	$console: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$parent: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!blacklistedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":34}],34:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],35:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return Array.prototype.includes || implementation;
};

},{"./implementation":13}],36:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimArrayPrototypeIncludes() {
	var polyfill = getPolyfill();
	if (Array.prototype.includes !== polyfill) {
		define(Array.prototype, { includes: polyfill });
	}
	return polyfill;
};

},{"./polyfill":35,"define-properties":15}],37:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');
var has = require('has');
var bind = require('function-bind');
var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function entries(O) {
	var obj = ES.RequireObjectCoercible(O);
	var entrys = [];
	for (var key in obj) {
		if (has(obj, key) && isEnumerable(obj, key)) {
			entrys.push([key, obj[key]]);
		}
	}
	return entrys;
};

},{"es-abstract/es7":42,"function-bind":53,"has":54}],38:[function(require,module,exports){
'use strict';

var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

define(implementation, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = implementation;

},{"./implementation":37,"./polyfill":61,"./shim":62,"define-properties":39}],39:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":51,"object-keys":59}],40:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":44,"./helpers/mod":46,"./helpers/sign":47,"dup":16,"es-to-primitive/es5":48,"is-callable":55}],41:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":40,"./helpers/assign":43,"./helpers/isFinite":44,"./helpers/isPrimitive":45,"./helpers/mod":46,"./helpers/sign":47,"dup":17,"es-to-primitive/es6":49,"function-bind":53,"is-regex":57}],42:[function(require,module,exports){
'use strict';

var ES6 = require('./es6');
var assign = require('./helpers/assign');

var ES7 = assign(ES6, {
	// https://github.com/tc39/ecma262/pull/60
	SameValueNonNumber: function SameValueNonNumber(x, y) {
		if (typeof x === 'number' || typeof x !== typeof y) {
			throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
		}
		return this.SameValue(x, y);
	}
});

module.exports = ES7;

},{"./es6":41,"./helpers/assign":43}],43:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],44:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],45:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],46:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],47:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],48:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":50,"dup":23,"is-callable":55}],49:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":50,"dup":24,"is-callable":55,"is-date-object":56,"is-symbol":58}],50:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],51:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],52:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],53:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":52,"dup":28}],54:[function(require,module,exports){
var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":53}],55:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],56:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],57:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],58:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],59:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":60,"dup":33}],60:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],61:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.entries === 'function' ? Object.entries : implementation;
};

},{"./implementation":37}],62:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimEntries() {
	var polyfill = getPolyfill();
	define(Object, { entries: polyfill }, { entries: function () { return Object.entries !== polyfill; } });
	return polyfill;
};

},{"./polyfill":61,"define-properties":39}],63:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');

var defineProperty = Object.defineProperty;
var getDescriptor = Object.getOwnPropertyDescriptor;
var getOwnNames = Object.getOwnPropertyNames;
var getSymbols = Object.getOwnPropertySymbols;
var concat = Function.call.bind(Array.prototype.concat);
var reduce = Function.call.bind(Array.prototype.reduce);
var getAll = getSymbols ? function (obj) {
	return concat(getOwnNames(obj), getSymbols(obj));
} : getOwnNames;

var isES5 = ES.IsCallable(getDescriptor) && ES.IsCallable(getOwnNames);

var safePut = function put(obj, prop, val) {
	if (defineProperty && prop in obj) {
		defineProperty(obj, prop, {
			configurable: true,
			enumerable: true,
			value: val,
			writable: true
		});
	} else {
		obj[prop] = val;
	}
};

module.exports = function getOwnPropertyDescriptors(value) {
	ES.RequireObjectCoercible(value);
	if (!isES5) { throw new TypeError('getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor'); }

	var O = ES.ToObject(value);
	return reduce(getAll(O), function (acc, key) {
		safePut(acc, key, getDescriptor(O, key));
		return acc;
	}, {});
};

},{"es-abstract/es7":68}],64:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./implementation":63,"./polyfill":86,"./shim":87,"define-properties":65,"dup":38}],65:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":77,"object-keys":84}],66:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":70,"./helpers/mod":72,"./helpers/sign":73,"dup":16,"es-to-primitive/es5":74,"is-callable":80}],67:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":66,"./helpers/assign":69,"./helpers/isFinite":70,"./helpers/isPrimitive":71,"./helpers/mod":72,"./helpers/sign":73,"dup":17,"es-to-primitive/es6":75,"function-bind":79,"is-regex":82}],68:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":67,"./helpers/assign":69,"dup":42}],69:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],70:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],71:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],72:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],73:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],74:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":76,"dup":23,"is-callable":80}],75:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":76,"dup":24,"is-callable":80,"is-date-object":81,"is-symbol":83}],76:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],77:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],78:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],79:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":78,"dup":28}],80:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],81:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],82:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],83:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],84:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":85,"dup":33}],85:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],86:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.getOwnPropertyDescriptors === 'function' ? Object.getOwnPropertyDescriptors : implementation;
};

},{"./implementation":63}],87:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimGetOwnPropertyDescriptors() {
	var polyfill = getPolyfill();
	define(Object, { getOwnPropertyDescriptors: polyfill }, {
		getOwnPropertyDescriptors: function () { return Object.getOwnPropertyDescriptors !== polyfill; }
	});
	return polyfill;
};

},{"./polyfill":86,"define-properties":65}],88:[function(require,module,exports){
'use strict';

var ES = require('es-abstract/es7');
var has = require('has');
var bind = require('function-bind');
var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function values(O) {
	var obj = ES.RequireObjectCoercible(O);
	var vals = [];
	for (var key in obj) {
		if (has(obj, key) && isEnumerable(obj, key)) {
			vals.push(obj[key]);
		}
	}
	return vals;
};

},{"es-abstract/es7":93,"function-bind":104,"has":105}],89:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./implementation":88,"./polyfill":112,"./shim":113,"define-properties":90,"dup":38}],90:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":102,"object-keys":110}],91:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":95,"./helpers/mod":97,"./helpers/sign":98,"dup":16,"es-to-primitive/es5":99,"is-callable":106}],92:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":91,"./helpers/assign":94,"./helpers/isFinite":95,"./helpers/isPrimitive":96,"./helpers/mod":97,"./helpers/sign":98,"dup":17,"es-to-primitive/es6":100,"function-bind":104,"is-regex":108}],93:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":92,"./helpers/assign":94,"dup":42}],94:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],95:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],96:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],97:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],98:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],99:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":101,"dup":23,"is-callable":106}],100:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":101,"dup":24,"is-callable":106,"is-date-object":107,"is-symbol":109}],101:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],102:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],103:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],104:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":103,"dup":28}],105:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54,"function-bind":104}],106:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],107:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],108:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],109:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],110:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":111,"dup":33}],111:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],112:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.values === 'function' ? Object.values : implementation;
};

},{"./implementation":88}],113:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimValues() {
	var polyfill = getPolyfill();
	define(Object, { values: polyfill }, { values: function () { return Object.values !== polyfill; } });
	return polyfill;
};

},{"./polyfill":112,"define-properties":90}],114:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var ES = require('es-abstract/es7');
var bind = require('function-bind');

var atShim = function at(pos) {
	ES.RequireObjectCoercible(this);
	var O = ES.ToObject(this);
	var S = ES.ToString(O);
	var position = ES.ToInteger(pos);
	var size = S.length;
	if (position < 0 || position >= size) {
		return '';
	}
	// Get the first code unit and code unit value
	var cuFirst = S.charCodeAt(position);
	var cuSecond;
	var nextIndex = position + 1;
	var len = 1;
	// Check if its the start of a surrogate pair.
	var isHighSurrogate = cuFirst >= 0xD800 && cuFirst <= 0xDBFF;
	if (isHighSurrogate && size > nextIndex /* there is a next code unit */) {
		cuSecond = S.charCodeAt(nextIndex);
		if (cuSecond >= 0xDC00 && cuSecond <= 0xDFFF) { // low surrogate
			len = 2;
		}
	}
	return S.slice(position, position + len);
};

var at = bind.call(Function.call, atShim);
define(at, {
	method: atShim,
	shim: function shimStringPrototypeAt() {
		define(String.prototype, {
			at: atShim
		});
		return String.prototype.at;
	}
});

module.exports = at;

},{"define-properties":115,"es-abstract/es7":118,"function-bind":129}],115:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":127,"object-keys":134}],116:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":120,"./helpers/mod":122,"./helpers/sign":123,"dup":16,"es-to-primitive/es5":124,"is-callable":130}],117:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":116,"./helpers/assign":119,"./helpers/isFinite":120,"./helpers/isPrimitive":121,"./helpers/mod":122,"./helpers/sign":123,"dup":17,"es-to-primitive/es6":125,"function-bind":129,"is-regex":132}],118:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":117,"./helpers/assign":119,"dup":42}],119:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],120:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],121:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],122:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],123:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],124:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":126,"dup":23,"is-callable":130}],125:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":126,"dup":24,"is-callable":130,"is-date-object":131,"is-symbol":133}],126:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],127:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],128:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],129:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":128,"dup":28}],130:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],131:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],132:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],133:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],134:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":135,"dup":33}],135:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],136:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var ES = require('es-abstract/es7');
var slice = bind.call(Function.call, String.prototype.slice);

module.exports = function padEnd(maxLength) {
	var O = ES.RequireObjectCoercible(this);
	var S = ES.ToString(O);
	var stringLength = ES.ToLength(S.length);
	var fillString;
	if (arguments.length > 1) {
		fillString = arguments[1];
	}
	var filler = typeof fillString === 'undefined' ? '' : ES.ToString(fillString);
	if (filler === '') {
		filler = ' ';
	}
	var intMaxLength = ES.ToLength(maxLength);
	if (intMaxLength <= stringLength) {
		return S;
	}
	var fillLen = intMaxLength - stringLength;
	while (filler.length < fillLen) {
		var fLen = filler.length;
		var remainingCodeUnits = fillLen - fLen;
		filler += fLen > remainingCodeUnits ? slice(filler, 0, remainingCodeUnits) : filler;
	}

	var truncatedStringFiller = filler.length > fillLen ? slice(filler, 0, fillLen) : filler;
	return S + truncatedStringFiller;
};

},{"es-abstract/es7":141,"function-bind":152}],137:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');
var ES = require('es-abstract/es7');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var bound = bind.call(Function.apply, implementation);

var boundPadEnd = function padEnd(str, maxLength) {
	ES.RequireObjectCoercible(str);
	var args = [maxLength];
	if (arguments.length > 2) {
		args.push(arguments[2]);
	}
	return bound(str, args);
};

define(boundPadEnd, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundPadEnd;

},{"./implementation":136,"./polyfill":159,"./shim":160,"define-properties":138,"es-abstract/es7":141,"function-bind":152}],138:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":150,"object-keys":157}],139:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":143,"./helpers/mod":145,"./helpers/sign":146,"dup":16,"es-to-primitive/es5":147,"is-callable":153}],140:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":139,"./helpers/assign":142,"./helpers/isFinite":143,"./helpers/isPrimitive":144,"./helpers/mod":145,"./helpers/sign":146,"dup":17,"es-to-primitive/es6":148,"function-bind":152,"is-regex":155}],141:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":140,"./helpers/assign":142,"dup":42}],142:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],143:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],144:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],145:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],146:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],147:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":149,"dup":23,"is-callable":153}],148:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":149,"dup":24,"is-callable":153,"is-date-object":154,"is-symbol":156}],149:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],150:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],151:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],152:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":151,"dup":28}],153:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],154:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],155:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],156:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],157:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":158,"dup":33}],158:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],159:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof String.prototype.padEnd === 'function' ? String.prototype.padEnd : implementation;
};

},{"./implementation":136}],160:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimPadEnd() {
	var polyfill = getPolyfill();
	define(String.prototype, { padEnd: polyfill }, { padEnd: function () { return String.prototype.padEnd !== polyfill; } });
	return polyfill;
};

},{"./polyfill":159,"define-properties":138}],161:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var ES = require('es-abstract/es7');
var slice = bind.call(Function.call, String.prototype.slice);

module.exports = function padStart(maxLength) {
	var O = ES.RequireObjectCoercible(this);
	var S = ES.ToString(O);
	var stringLength = ES.ToLength(S.length);
	var fillString;
	if (arguments.length > 1) {
		fillString = arguments[1];
	}
	var filler = typeof fillString === 'undefined' ? '' : ES.ToString(fillString);
	if (filler === '') {
		filler = ' ';
	}
	var intMaxLength = ES.ToLength(maxLength);
	if (intMaxLength <= stringLength) {
		return S;
	}
	var fillLen = intMaxLength - stringLength;
	while (filler.length < fillLen) {
		var fLen = filler.length;
		var remainingCodeUnits = fillLen - fLen;
		filler += fLen > remainingCodeUnits ? slice(filler, 0, remainingCodeUnits) : filler;
	}

	var truncatedStringFiller = filler.length > fillLen ? slice(filler, 0, fillLen) : filler;
	return truncatedStringFiller + S;
};

},{"es-abstract/es7":166,"function-bind":177}],162:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');
var ES = require('es-abstract/es7');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var bound = bind.call(Function.apply, implementation);

var boundPadStart = function padStart(str, maxLength) {
	ES.RequireObjectCoercible(str);
	var args = [maxLength];
	if (arguments.length > 2) {
		args.push(arguments[2]);
	}
	return bound(str, args);
};

define(boundPadStart, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundPadStart;

},{"./implementation":161,"./polyfill":184,"./shim":185,"define-properties":163,"es-abstract/es7":166,"function-bind":177}],163:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":175,"object-keys":182}],164:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./helpers/isFinite":168,"./helpers/mod":170,"./helpers/sign":171,"dup":16,"es-to-primitive/es5":172,"is-callable":178}],165:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./es5":164,"./helpers/assign":167,"./helpers/isFinite":168,"./helpers/isPrimitive":169,"./helpers/mod":170,"./helpers/sign":171,"dup":17,"es-to-primitive/es6":173,"function-bind":177,"is-regex":180}],166:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./es6":165,"./helpers/assign":167,"dup":42}],167:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],168:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],169:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],170:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],171:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],172:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./helpers/isPrimitive":174,"dup":23,"is-callable":178}],173:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./helpers/isPrimitive":174,"dup":24,"is-callable":178,"is-date-object":179,"is-symbol":181}],174:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],175:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],176:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],177:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":176,"dup":28}],178:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],179:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],180:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],181:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],182:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":183,"dup":33}],183:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],184:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof String.prototype.padStart === 'function' ? String.prototype.padStart : implementation;
};

},{"./implementation":161}],185:[function(require,module,exports){
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimPadStart() {
	var polyfill = getPolyfill();
	define(String.prototype, { padStart: polyfill }, { padStart: function () { return String.prototype.padStart !== polyfill; } });
	return polyfill;
};

},{"./polyfill":184,"define-properties":163}],186:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var replace = bind.call(Function.call, String.prototype.replace);

var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;

module.exports = function trimLeft() {
	return replace(this, leftWhitespace, '');
};

},{"function-bind":191}],187:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var bound = bind.call(Function.call, getPolyfill());

define(bound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = bound;

},{"./implementation":186,"./polyfill":194,"./shim":195,"define-properties":188,"function-bind":191}],188:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":189,"object-keys":192}],189:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],190:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],191:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":190,"dup":28}],192:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":193,"dup":33}],193:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],194:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	if (!String.prototype.trimLeft) {
		return implementation;
	}
	var zeroWidthSpace = '\u200b';
	if (zeroWidthSpace.trimLeft() !== zeroWidthSpace) {
		return implementation;
	}
	return String.prototype.trimLeft;
};

},{"./implementation":186}],195:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimTrimLeft() {
	var polyfill = getPolyfill();
	define(
		String.prototype,
		{ trimLeft: polyfill },
		{ trimLeft: function () { return String.prototype.trimLeft !== polyfill; } }
	);
	return polyfill;
};

},{"./polyfill":194,"define-properties":188}],196:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var replace = bind.call(Function.call, String.prototype.replace);

var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;

module.exports = function trimRight() {
	return replace(this, rightWhitespace, '');
};

},{"function-bind":201}],197:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./implementation":196,"./polyfill":204,"./shim":205,"define-properties":198,"dup":187,"function-bind":201}],198:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"foreach":199,"object-keys":202}],199:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],200:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],201:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./implementation":200,"dup":28}],202:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./isArguments":203,"dup":33}],203:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],204:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	if (!String.prototype.trimRight) {
		return implementation;
	}
	var zeroWidthSpace = '\u200b';
	if (zeroWidthSpace.trimRight() !== zeroWidthSpace) {
		return implementation;
	}
	return String.prototype.trimRight;
};

},{"./implementation":196}],205:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimTrimRight() {
	var polyfill = getPolyfill();
	define(
		String.prototype,
		{ trimRight: polyfill },
		{ trimRight: function () { return String.prototype.trimRight !== polyfill; } }
	);
	return polyfill;
};

},{"./polyfill":204,"define-properties":198}],206:[function(require,module,exports){
'use strict';

module.exports = require('./es7-shim').shim();

},{"./es7-shim":12}]},{},[206]);</script>
  <script>"use strict";

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (e, r) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r((e = "undefined" != typeof globalThis ? globalThis : e || self).graphre = {});
}(void 0, function (e) {
  "use strict";

  var r = /*#__PURE__*/function () {
    function r() {
      _classCallCheck(this, r);

      var e = {};
      e._next = e._prev = e, this._sentinel = e;
    }

    _createClass(r, [{
      key: "dequeue",
      value: function dequeue() {
        var e = this._sentinel,
            r = e._prev;
        if (r !== e) return n(r), r;
      }
    }, {
      key: "enqueue",
      value: function enqueue(e) {
        var r = this._sentinel,
            t = e;
        t._prev && t._next && n(t), t._next = r._next, r._next._prev = t, r._next = t, t._prev = r;
      }
    }, {
      key: "toString",
      value: function toString() {
        for (var e = [], r = this._sentinel, n = r._prev; n !== r;) {
          e.push(JSON.stringify(n, t)), n = n._prev;
        }

        return "[" + e.join(", ") + "]";
      }
    }]);

    return r;
  }();

  function n(e) {
    e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;
  }

  function t(e, r) {
    if ("_next" !== e && "_prev" !== e) return r;
  }

  var o = Object.freeze({
    __proto__: null,
    List: r
  });
  var i = {};

  function a(e) {
    var r = [];

    var _iterator = _createForOfIteratorHelper(e),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var n = _step.value;
        r.push.apply(r, _toConsumableArray(n));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return r;
  }

  function s(e, r) {
    return null != e && e.hasOwnProperty(r);
  }

  function d(e) {
    var r = null == e ? 0 : e.length;
    return r ? e[r - 1] : void 0;
  }

  function u(e, r) {
    e = Object(e);
    var n = {};
    return Object.keys(e).forEach(function (t) {
      n[t] = r(e[t], t);
    }), n;
  }

  function f(e, r) {
    var n = Number.POSITIVE_INFINITY,
        t = void 0;

    var _iterator2 = _createForOfIteratorHelper(e),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var o = _step2.value;
        var i = r(o);
        i < n && (n = i, t = o);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return t;
  }

  function h(e, r) {
    var n = e < r ? 1 : -1;
    var t = -1,
        o = Math.max(Math.ceil((r - e) / (n || 1)), 0);
    var i = new Array(o);

    for (; o--;) {
      i[++t] = e, e += n;
    }

    return i;
  }

  function c(e, r) {
    return e.slice().sort(function (e, n) {
      return r(e) - r(n);
    });
  }

  function v(e) {
    i[e] || (i[e] = 0);
    return "".concat(e).concat(++i[e]);
  }

  function l(e) {
    return e ? Object.keys(e).map(function (r) {
      return e[r];
    }) : [];
  }

  function g(e, r) {
    for (var n = [], t = 0; t < e; t++) {
      n.push(r());
    }

    return n;
  }

  function p(e) {
    return void 0 === e;
  }

  function m(e, r) {
    for (var _i = 0, _Object$keys = Object.keys(e); _i < _Object$keys.length; _i++) {
      var n = _Object$keys[_i];
      r(e[n], n);
    }
  }

  function w(e) {
    return 0 === Object.keys(e).length;
  }

  function _(e) {
    var r = {},
        n = e.nodes().filter(function (r) {
      return !e.children(r).length;
    }),
        t = g(Math.max.apply(Math, _toConsumableArray(n.map(function (r) {
      return e.node(r).rank;
    }))) + 1, function () {
      return [];
    });
    return c(n, function (r) {
      return e.node(r).rank;
    }).forEach(function n(o) {
      if (!s(r, o)) {
        r[o] = !0;
        var i = e.node(o);
        t[i.rank].push(o), e.successors(o).forEach(n);
      }
    }), t;
  }

  function b(e, r) {
    for (var n = 0, t = 1; t < r.length; ++t) {
      n += y(e, r[t - 1], r[t]);
    }

    return n;
  }

  function y(e, r, n) {
    for (var t = {}, o = 0; o < n.length; o++) {
      t[n[o]] = o;
    }

    for (var i = a(r.map(function (r) {
      return c(e.outEdges(r).map(function (r) {
        return {
          pos: t[r.w],
          weight: e.edge(r).weight
        };
      }), function (e) {
        return e.pos;
      });
    })), s = 1; s < n.length;) {
      s <<= 1;
    }

    var d = 2 * s - 1;
    s -= 1;
    var u = g(d, function () {
      return 0;
    }),
        f = 0;
    return i.forEach(function (e) {
      var r = e.pos + s;
      u[r] += e.weight;

      for (var n = 0; r > 0;) {
        r % 2 && (n += u[r + 1]), u[r = r - 1 >> 1] += e.weight;
      }

      f += e.weight * n;
    }), f;
  }

  function k(e, r) {
    return r ? r.map(function (r) {
      var n = e.inEdges(r);

      if (n.length) {
        var t = n.reduce(function (r, n) {
          var t = e.edge(n),
              o = e.node(n.v);
          return {
            sum: r.sum + t.weight * o.order,
            weight: r.weight + t.weight
          };
        }, {
          sum: 0,
          weight: 0
        });
        return {
          v: r,
          barycenter: t.sum / t.weight,
          weight: t.weight
        };
      }

      return {
        v: r
      };
    }) : [];
  }

  function E(e, r) {
    for (var n = {}, t = 0; t < e.length; t++) {
      var o = e[t],
          i = n[o.v] = {
        indegree: 0,
        in: [],
        out: [],
        vs: [o.v],
        i: t
      };
      void 0 !== o.barycenter && (i.barycenter = o.barycenter, i.weight = o.weight);
    }

    var _iterator3 = _createForOfIteratorHelper(r.edges()),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var a = _step3.value;
        var s = n[a.v],
            d = n[a.w];
        void 0 !== s && void 0 !== d && (d.indegree++, s.out.push(n[a.w]));
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return function (e) {
      var r = [];

      function n(e) {
        return function (r) {
          r.merged || (void 0 === r.barycenter || void 0 === e.barycenter || r.barycenter >= e.barycenter) && function (e, r) {
            var n = 0,
                t = 0;
            e.weight && (n += e.barycenter * e.weight, t += e.weight);
            r.weight && (n += r.barycenter * r.weight, t += r.weight);
            e.vs = r.vs.concat(e.vs), e.barycenter = n / t, e.weight = t, e.i = Math.min(r.i, e.i), r.merged = !0;
          }(e, r);
        };
      }

      function t(r) {
        return function (n) {
          n.in.push(r), 0 == --n.indegree && e.push(n);
        };
      }

      for (; e.length;) {
        var o = e.pop();
        r.push(o), o.in.reverse().forEach(n(o)), o.out.forEach(t(o));
      }

      return r.filter(function (e) {
        return !e.merged;
      }).map(function (e) {
        var r = {
          vs: e.vs,
          i: e.i
        };
        return "barycenter" in e && (r.barycenter = e.barycenter), "weight" in e && (r.weight = e.weight), r;
      });
    }(l(n).filter(function (e) {
      return !e.indegree;
    }));
  }

  var N = "\0";

  var x = /*#__PURE__*/function () {
    function x() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, x);

      this._label = void 0, this._nodeCount = 0, this._edgeCount = 0, this._isDirected = !s(e, "directed") || e.directed, this._isMultigraph = !!s(e, "multigraph") && e.multigraph, this._isCompound = !!s(e, "compound") && e.compound, this._defaultNodeLabelFn = function () {}, this._defaultEdgeLabelFn = function () {}, this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children["\0"] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
    }

    _createClass(x, [{
      key: "isDirected",
      value: function isDirected() {
        return this._isDirected;
      }
    }, {
      key: "isMultigraph",
      value: function isMultigraph() {
        return this._isMultigraph;
      }
    }, {
      key: "isCompound",
      value: function isCompound() {
        return this._isCompound;
      }
    }, {
      key: "setGraph",
      value: function setGraph(e) {
        return this._label = e, this;
      }
    }, {
      key: "graph",
      value: function graph() {
        return this._label;
      }
    }, {
      key: "setDefaultNodeLabel",
      value: function setDefaultNodeLabel(e) {
        var r;
        return r = e, this._defaultNodeLabelFn = "function" != typeof r ? function () {
          return e;
        } : e, this;
      }
    }, {
      key: "nodeCount",
      value: function nodeCount() {
        return this._nodeCount;
      }
    }, {
      key: "nodes",
      value: function nodes() {
        return Object.keys(this._nodes);
      }
    }, {
      key: "sources",
      value: function sources() {
        var e = this;
        return this.nodes().filter(function (r) {
          return w(e._in[r]);
        });
      }
    }, {
      key: "sinks",
      value: function sinks() {
        var e = this;
        return this.nodes().filter(function (r) {
          return w(e._out[r]);
        });
      }
    }, {
      key: "setNodes",
      value: function setNodes(e, r) {
        var _iterator4 = _createForOfIteratorHelper(e),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var n = _step4.value;
            void 0 !== r ? this.setNode(n, r) : this.setNode(n);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return this;
      }
    }, {
      key: "setNode",
      value: function setNode(e, r) {
        return s(this._nodes, e) ? (arguments.length > 1 && (this._nodes[e] = r), this) : (this._nodes[e] = arguments.length > 1 ? r : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = N, this._children[e] = {}, this._children["\0"][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);
      }
    }, {
      key: "node",
      value: function node(e) {
        return this._nodes[e];
      }
    }, {
      key: "hasNode",
      value: function hasNode(e) {
        return s(this._nodes, e);
      }
    }, {
      key: "removeNode",
      value: function removeNode(e) {
        var _this = this;

        var r = this;

        if (s(this._nodes, e)) {
          var n = function n(e) {
            r.removeEdge(_this._edgeObjs[e]);
          };

          if (delete this._nodes[e], this._isCompound) {
            var _iterator5 = _createForOfIteratorHelper((this._removeFromParentsChildList(e), delete this._parent[e], this.children(e))),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var t = _step5.value;
                r.setParent(t);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }

            delete this._children[e];
          }

          for (var _i2 = 0, _Object$keys2 = Object.keys(this._in[e]); _i2 < _Object$keys2.length; _i2++) {
            var o = _Object$keys2[_i2];
            n(o);
          }

          for (var _i3 = 0, _arr = (delete this._in[e], delete this._preds[e], Object.keys(this._out[e])); _i3 < _arr.length; _i3++) {
            var o = _arr[_i3];
            n(o);
          }

          delete this._out[e], delete this._sucs[e], --this._nodeCount;
        }

        return this;
      }
    }, {
      key: "setParent",
      value: function setParent(e, r) {
        if (!this._isCompound) throw new Error("Cannot set parent in a non-compound graph");
        if (void 0 === r) r = N;else {
          for (var n = r += ""; !p(n); n = this.parent(n)) {
            if (n === e) throw new Error("Setting ".concat(r, " as parent of ").concat(e, " would create a cycle"));
          }

          this.setNode(r);
        }
        return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = r, this._children[r][e] = !0, this;
      }
    }, {
      key: "_removeFromParentsChildList",
      value: function _removeFromParentsChildList(e) {
        delete this._children[this._parent[e]][e];
      }
    }, {
      key: "parent",
      value: function parent(e) {
        if (this._isCompound) {
          var r = this._parent[e];
          if (r !== N) return r;
        }
      }
    }, {
      key: "children",
      value: function children(e) {
        if (p(e) && (e = N), this._isCompound) {
          var r = this._children[e];
          return r ? Object.keys(r) : void 0;
        }

        return e === N ? this.nodes() : this.hasNode(e) ? [] : void 0;
      }
    }, {
      key: "predecessors",
      value: function predecessors(e) {
        var r = this._preds[e];
        if (r) return Object.keys(r);
      }
    }, {
      key: "successors",
      value: function successors(e) {
        var r = this._sucs[e];
        if (r) return Object.keys(r);
      }
    }, {
      key: "neighbors",
      value: function neighbors(e) {
        var r = this.predecessors(e);
        if (r) return function (e, r) {
          var n = _toConsumableArray(e);

          var _iterator6 = _createForOfIteratorHelper(r),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var t = _step6.value;
              -1 === n.indexOf(t) && n.push(t);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return n;
        }(r, this.successors(e));
      }
    }, {
      key: "isLeaf",
      value: function isLeaf(e) {
        return 0 === (this.isDirected() ? this.successors(e) : this.neighbors(e)).length;
      }
    }, {
      key: "filterNodes",
      value: function filterNodes(e) {
        var r = new x({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        r.setGraph(this.graph());
        var n = this;
        m(this._nodes, function (n, t) {
          e(t) && r.setNode(t, n);
        }), m(this._edgeObjs, function (e) {
          r.hasNode(e.v) && r.hasNode(e.w) && r.setEdge(e, n.edge(e));
        });
        var t = {};

        function o(e) {
          var i = n.parent(e);
          return void 0 === i || r.hasNode(i) ? (t[e] = i, i) : i in t ? t[i] : o(i);
        }

        if (this._isCompound) {
          var _iterator7 = _createForOfIteratorHelper(r.nodes()),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var i = _step7.value;
              r.setParent(i, o(i));
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        }

        return r;
      }
    }, {
      key: "setDefaultEdgeLabel",
      value: function setDefaultEdgeLabel(e) {
        var r;
        return r = e, this._defaultEdgeLabelFn = "function" != typeof r ? function () {
          return e;
        } : e, this;
      }
    }, {
      key: "edgeCount",
      value: function edgeCount() {
        return this._edgeCount;
      }
    }, {
      key: "edges",
      value: function edges() {
        return Object.values(this._edgeObjs);
      }
    }, {
      key: "setPath",
      value: function setPath(e, r) {
        var n = this,
            t = arguments;
        return e.reduce(function (e, o) {
          return t.length > 1 ? n.setEdge(e, o, r) : n.setEdge(e, o), o;
        }), this;
      }
    }, {
      key: "setEdge",
      value: function setEdge(e, r, n, t) {
        var o = !1,
            i = e;
        "object" == _typeof(i) && null !== i && "v" in i ? (e = i.v, r = i.w, t = i.name, 2 === arguments.length && (n = arguments[1], o = !0)) : (e = i, r = arguments[1], t = arguments[3], arguments.length > 2 && (n = arguments[2], o = !0)), e = "" + e, r = "" + r, p(t) || (t = "" + t);
        var a = j(this._isDirected, e, r, t);
        if (s(this._edgeLabels, a)) return o && (this._edgeLabels[a] = n), this;
        if (!p(t) && !this._isMultigraph) throw new Error("Cannot set a named edge when isMultigraph = false");
        this.setNode(e), this.setNode(r), this._edgeLabels[a] = o ? n : this._defaultEdgeLabelFn(e, r, t);

        var d = function (e, r, n, t) {
          var o = "" + r,
              i = "" + n;

          if (!e && o > i) {
            var a = o;
            o = i, i = a;
          }

          var s = {
            v: o,
            w: i
          };
          t && (s.name = t);
          return s;
        }(this._isDirected, e, r, t);

        return e = d.v, r = d.w, Object.freeze(d), this._edgeObjs[a] = d, C(this._preds[r], e), C(this._sucs[e], r), this._in[r][a] = d, this._out[e][a] = d, this._edgeCount++, this;
      }
    }, {
      key: "edge",
      value: function edge(e, r, n) {
        var t = "object" == _typeof(e) ? M(this._isDirected, e) : j(this._isDirected, e, r, n);
        return this._edgeLabels[t];
      }
    }, {
      key: "hasEdge",
      value: function hasEdge(e, r, n) {
        var t = 1 === arguments.length ? M(this._isDirected, arguments[0]) : j(this._isDirected, e, r, n);
        return s(this._edgeLabels, t);
      }
    }, {
      key: "removeEdge",
      value: function removeEdge(e, r, n) {
        var t = "object" == _typeof(e) ? M(this._isDirected, e) : j(this._isDirected, e, r, n),
            o = this._edgeObjs[t];
        return o && (e = o.v, r = o.w, delete this._edgeLabels[t], delete this._edgeObjs[t], O(this._preds[r], e), O(this._sucs[e], r), delete this._in[r][t], delete this._out[e][t], this._edgeCount--), this;
      }
    }, {
      key: "inEdges",
      value: function inEdges(e, r) {
        var n = this._in[e];

        if (n) {
          var t = Object.values(n);
          return r ? t.filter(function (e) {
            return e.v === r;
          }) : t;
        }
      }
    }, {
      key: "outEdges",
      value: function outEdges(e, r) {
        var n = this._out[e];

        if (n) {
          var t = Object.values(n);
          return r ? t.filter(function (e) {
            return e.w === r;
          }) : t;
        }
      }
    }, {
      key: "nodeEdges",
      value: function nodeEdges(e, r) {
        var n = this.inEdges(e, r);
        if (n) return n.concat(this.outEdges(e, r));
      }
    }]);

    return x;
  }();

  var I = /*#__PURE__*/function (_x) {
    _inherits(I, _x);

    var _super = _createSuper(I);

    function I() {
      _classCallCheck(this, I);

      return _super.apply(this, arguments);
    }

    return I;
  }(x);

  function C(e, r) {
    e[r] ? e[r]++ : e[r] = 1;
  }

  function O(e, r) {
    --e[r] || delete e[r];
  }

  function j(e, r, n, t) {
    var o = "" + r,
        i = "" + n;

    if (!e && o > i) {
      var a = o;
      o = i, i = a;
    }

    return o + "" + i + "" + (p(t) ? "\0" : t);
  }

  function M(e, r) {
    return j(e, r.v, r.w, r.name);
  }

  function L(e, r, n, t) {
    var o;

    do {
      o = v(t);
    } while (e.hasNode(o));

    return n.dummy = r, e.setNode(o, n), o;
  }

  function T(e) {
    var r = new x().setGraph(e.graph());

    var _iterator8 = _createForOfIteratorHelper(e.nodes()),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var n = _step8.value;
        r.setNode(n, e.node(n));
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    var _iterator9 = _createForOfIteratorHelper(e.edges()),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var t = _step9.value;
        var o = r.edge(t.v, t.w) || {
          weight: 0,
          minlen: 1
        },
            i = e.edge(t);
        r.setEdge(t.v, t.w, {
          weight: o.weight + i.weight,
          minlen: Math.max(o.minlen, i.minlen)
        });
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }

    return r;
  }

  function S(e) {
    var r = new x({
      multigraph: e.isMultigraph()
    }).setGraph(e.graph());

    var _iterator10 = _createForOfIteratorHelper(e.nodes()),
        _step10;

    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var n = _step10.value;
        e.children(n).length || r.setNode(n, e.node(n));
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }

    var _iterator11 = _createForOfIteratorHelper(e.edges()),
        _step11;

    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var t = _step11.value;
        r.setEdge(t, e.edge(t));
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }

    return r;
  }

  function P(e, r) {
    var n,
        t,
        o = e.x,
        i = e.y,
        a = r.x - o,
        s = r.y - i,
        d = e.width / 2,
        u = e.height / 2;
    if (!a && !s) throw new Error("Not possible to find intersection inside of the rectangle");
    return Math.abs(s) * d > Math.abs(a) * u ? (s < 0 && (u = -u), n = u * a / s, t = u) : (a < 0 && (d = -d), n = d, t = d * s / a), {
      x: o + n,
      y: i + t
    };
  }

  function R(e) {
    var r = g(G(e) + 1, function () {
      return [];
    });

    var _iterator12 = _createForOfIteratorHelper(e.nodes()),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var n = _step12.value;
        var t = e.node(n),
            o = t.rank;
        void 0 !== o && (r[o][t.order] = n);
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    return r;
  }

  function F(e) {
    var r = Math.min.apply(Math, _toConsumableArray(e.nodes().map(function (r) {
      return e.node(r).rank;
    }).filter(function (e) {
      return void 0 !== e;
    })));

    var _iterator13 = _createForOfIteratorHelper(e.nodes()),
        _step13;

    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var n = _step13.value;
        var t = e.node(n);
        s(t, "rank") && (t.rank -= r);
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }
  }

  function D(e) {
    var r = Math.min.apply(Math, _toConsumableArray(e.nodes().map(function (r) {
      return e.node(r).rank;
    }).filter(function (e) {
      return void 0 !== e;
    }))),
        n = [];

    var _iterator14 = _createForOfIteratorHelper(e.nodes()),
        _step14;

    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var t = _step14.value;
        var o = e.node(t).rank - r;
        n[o] || (n[o] = []), n[o].push(t);
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }

    for (var i = 0, a = e.graph().nodeRankFactor, s = 0; s < n.length; s++) {
      var d = n[s];
      if (void 0 === d && s % a != 0) --i;else if (i && null != d) {
        var _iterator15 = _createForOfIteratorHelper(d),
            _step15;

        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var t = _step15.value;
            e.node(t).rank += i;
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
      }
    }
  }

  function z(e, r, n, t) {
    var o = {
      width: 0,
      height: 0
    };
    return arguments.length >= 4 && (o.rank = n, o.order = t), L(e, "border", o, r);
  }

  function G(e) {
    var r = e.nodes().map(function (r) {
      return e.node(r).rank;
    }).filter(function (e) {
      return void 0 !== e;
    });
    return Math.max.apply(Math, _toConsumableArray(r));
  }

  function V(e, r) {
    var n = [],
        t = [];

    var _iterator16 = _createForOfIteratorHelper(e),
        _step16;

    try {
      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
        var o = _step16.value;
        r(o) ? n.push(o) : t.push(o);
      }
    } catch (err) {
      _iterator16.e(err);
    } finally {
      _iterator16.f();
    }

    return {
      lhs: n,
      rhs: t
    };
  }

  function Y(e, r) {
    var n = Date.now();

    try {
      return r();
    } finally {
      console.log(e + " time: " + (Date.now() - n) + "ms");
    }
  }

  function B(e, r) {
    return r();
  }

  var A = Object.freeze({
    __proto__: null,
    addDummyNode: L,
    simplify: T,
    asNonCompoundGraph: S,
    successorWeights: function successorWeights(e) {
      var r = {};

      var _iterator17 = _createForOfIteratorHelper(e.nodes()),
          _step17;

      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var n = _step17.value;
          var t = {};

          var _iterator18 = _createForOfIteratorHelper(e.outEdges(n)),
              _step18;

          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
              var o = _step18.value;
              t[o.w] = (t[o.w] || 0) + e.edge(o).weight;
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }

          r[n] = t;
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }

      return r;
    },
    predecessorWeights: function predecessorWeights(e) {
      var r = {};

      var _iterator19 = _createForOfIteratorHelper(e.nodes()),
          _step19;

      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var n = _step19.value;
          var t = {};

          var _iterator20 = _createForOfIteratorHelper(e.inEdges(n)),
              _step20;

          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var o = _step20.value;
              t[o.v] = (t[o.v] || 0) + e.edge(o).weight;
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }

          r[n] = t;
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }

      return r;
    },
    intersectRect: P,
    buildLayerMatrix: R,
    normalizeRanks: F,
    removeEmptyRanks: D,
    addBorderNode: z,
    maxRank: G,
    partition: V,
    time: Y,
    notime: B
  });

  function q(e, r) {
    var n,
        t = V(e, function (e) {
      return s(e, "barycenter");
    }),
        o = t.lhs,
        i = c(t.rhs, function (e) {
      return -e.i;
    }),
        d = [],
        u = 0,
        f = 0,
        h = 0;

    var _iterator21 = _createForOfIteratorHelper((o.sort((n = !!r, function (e, r) {
      return e.barycenter < r.barycenter ? -1 : e.barycenter > r.barycenter ? 1 : n ? r.i - e.i : e.i - r.i;
    })), h = W(d, i, h), o)),
        _step21;

    try {
      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
        var v = _step21.value;
        h += v.vs.length, d.push(v.vs), u += v.barycenter * v.weight, f += v.weight, h = W(d, i, h);
      }
    } catch (err) {
      _iterator21.e(err);
    } finally {
      _iterator21.f();
    }

    var l = {
      vs: a(d)
    };
    return f && (l.barycenter = u / f, l.weight = f), l;
  }

  function W(e, r, n) {
    for (var t; r.length && (t = d(r)).i <= n;) {
      r.pop(), e.push(t.vs), n++;
    }

    return n;
  }

  function $(e, r, n, t) {
    var o = e.children(r),
        i = e.node(r),
        d = i ? i.borderLeft : void 0,
        u = i ? i.borderRight : void 0,
        f = {};
    d && (o = o.filter(function (e) {
      return e !== d && e !== u;
    }));
    var h = k(e, o);

    var _iterator22 = _createForOfIteratorHelper(h),
        _step22;

    try {
      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
        var c = _step22.value;

        if (e.children(c.v).length) {
          var v = $(e, c.v, n, t);
          f[c.v] = v, s(v, "barycenter") && J(c, v);
        }
      }
    } catch (err) {
      _iterator22.e(err);
    } finally {
      _iterator22.f();
    }

    var l = E(h, n);
    !function (e, r) {
      var _iterator23 = _createForOfIteratorHelper(e),
          _step23;

      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var n = _step23.value;
          n.vs = a(n.vs.map(function (e) {
            return r[e] ? r[e].vs : [e];
          }));
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    }(l, f);
    var g = q(l, t);

    if (d && (g.vs = [d].concat(_toConsumableArray(g.vs), [u]), e.predecessors(d).length)) {
      var p = e.node(e.predecessors(d)[0]),
          m = e.node(e.predecessors(u)[0]);
      s(g, "barycenter") || (g.barycenter = 0, g.weight = 0), g.barycenter = (g.barycenter * g.weight + p.order + m.order) / (g.weight + 2), g.weight += 2;
    }

    return g;
  }

  function J(e, r) {
    void 0 !== e.barycenter ? (e.barycenter = (e.barycenter * e.weight + r.barycenter * r.weight) / (e.weight + r.weight), e.weight += r.weight) : (e.barycenter = r.barycenter, e.weight = r.weight);
  }

  function Q(e, r, n) {
    var t = function (e) {
      var r;

      for (; e.hasNode(r = v("_root"));) {
        ;
      }

      return r;
    }(e),
        o = new x({
      compound: !0
    }).setGraph({
      root: t
    }).setDefaultNodeLabel(function (r) {
      return e.node(r);
    });

    var _iterator24 = _createForOfIteratorHelper(e.nodes()),
        _step24;

    try {
      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
        var i = _step24.value;
        var a = e.node(i),
            d = e.parent(i);

        if (a.rank === r || a.minRank <= r && r <= a.maxRank) {
          var _iterator25 = _createForOfIteratorHelper((o.setNode(i), o.setParent(i, d || t), e[n](i))),
              _step25;

          try {
            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
              var u = _step25.value;
              var f = u.v === i ? u.w : u.v,
                  h = o.edge(f, i),
                  c = void 0 !== h ? h.weight : 0;
              o.setEdge(f, i, {
                weight: e.edge(u).weight + c
              });
            }
          } catch (err) {
            _iterator25.e(err);
          } finally {
            _iterator25.f();
          }

          s(a, "minRank") && o.setNode(i, {
            borderLeft: a.borderLeft[r],
            borderRight: a.borderRight[r]
          });
        }
      }
    } catch (err) {
      _iterator24.e(err);
    } finally {
      _iterator24.f();
    }

    return o;
  }

  function K(e, r, n) {
    var t,
        o = {};

    var _iterator26 = _createForOfIteratorHelper(n),
        _step26;

    try {
      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
        var i = _step26.value;
        !function () {
          for (var n, a = e.parent(i); a;) {
            var s = e.parent(a);
            if (s ? (n = o[s], o[s] = a) : (n = t, t = a), n && n !== a) return void r.setEdge(n, a);
            a = s;
          }
        }();
      }
    } catch (err) {
      _iterator26.e(err);
    } finally {
      _iterator26.f();
    }
  }

  function X(e) {
    var r = G(e),
        n = H(e, h(1, r + 1), "inEdges"),
        t = H(e, h(r - 1, -1), "outEdges"),
        o = _(e);

    Z(e, o);

    for (var i, a = Number.POSITIVE_INFINITY, s = 0, d = 0; d < 4; ++s, ++d) {
      U(s % 2 ? n : t, s % 4 >= 2);
      var u = b(e, o = R(e));
      u < a && (d = 0, i = o.map(function (e) {
        return e.slice(0);
      }), a = u);
    }

    Z(e, i);
  }

  function H(e, r, n) {
    return r.map(function (r) {
      return Q(e, r, n);
    });
  }

  function U(e, r) {
    var n = new x();

    var _iterator27 = _createForOfIteratorHelper(e),
        _step27;

    try {
      for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
        var t = _step27.value;
        var o = t.graph().root,
            i = $(t, o, n, r);
        i.vs.map(function (e, r) {
          t.node(e).order = r;
        }), K(t, n, i.vs);
      }
    } catch (err) {
      _iterator27.e(err);
    } finally {
      _iterator27.f();
    }
  }

  function Z(e, r) {
    var _iterator28 = _createForOfIteratorHelper(r),
        _step28;

    try {
      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
        var n = _step28.value;
        n.map(function (r, n) {
          e.node(r).order = n;
        });
      }
    } catch (err) {
      _iterator28.e(err);
    } finally {
      _iterator28.f();
    }
  }

  var ee = Object.freeze({
    __proto__: null,
    order: X,
    addSubgraphConstraints: K,
    barycenter: k,
    buildLayerGraph: Q,
    crossCount: b,
    initOrder: _,
    resolveConflicts: E,
    sortSubgraph: $,
    sort: q
  });

  function re(e, r) {
    var n = {};
    return r.reduce(function (r, t) {
      for (var o = 0, i = 0, a = r.length, s = d(t), u = 0; u < t.length; u++) {
        var f = t[u],
            h = te(e, f),
            c = h ? e.node(h).order : a;

        if (h || f === s) {
          var _iterator29 = _createForOfIteratorHelper(t.slice(i, u + 1)),
              _step29;

          try {
            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
              var v = _step29.value;

              var _iterator30 = _createForOfIteratorHelper(e.predecessors(v)),
                  _step30;

              try {
                for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                  var l = _step30.value;
                  var g = e.node(l),
                      p = g.order;
                  !(p < o || c < p) || g.dummy && e.node(v).dummy || oe(n, l, v);
                }
              } catch (err) {
                _iterator30.e(err);
              } finally {
                _iterator30.f();
              }
            }
          } catch (err) {
            _iterator29.e(err);
          } finally {
            _iterator29.f();
          }

          i = u + 1, o = c;
        }
      }

      return t;
    }), n;
  }

  function ne(e, r) {
    var n = {};

    function t(r, t, o, i, a) {
      var s;

      var _iterator31 = _createForOfIteratorHelper(h(t, o)),
          _step31;

      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
          var d = _step31.value;

          if (s = r[d], e.node(s).dummy) {
            var _iterator32 = _createForOfIteratorHelper(e.predecessors(s)),
                _step32;

            try {
              for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
                var u = _step32.value;
                var f = e.node(u);
                f.dummy && (f.order < i || f.order > a) && oe(n, u, s);
              }
            } catch (err) {
              _iterator32.e(err);
            } finally {
              _iterator32.f();
            }
          }
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }
    }

    return r.reduce(function (r, n) {
      for (var o, i = -1, a = 0, s = 0; s < n.length; s++) {
        var d = s,
            u = n[s];

        if (void 0 !== u) {
          if ("border" === e.node(u).dummy) {
            var f = e.predecessors(u);
            f.length && (t(n, a, d, i, o = e.node(f[0]).order), a = d, i = o);
          }

          t(n, a, n.length, o, r.length);
        }
      }

      return n;
    }), n;
  }

  function te(e, r) {
    if (e.node(r).dummy) {
      var _iterator33 = _createForOfIteratorHelper(e.predecessors(r)),
          _step33;

      try {
        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
          var n = _step33.value;
          if (e.node(n).dummy) return n;
        }
      } catch (err) {
        _iterator33.e(err);
      } finally {
        _iterator33.f();
      }
    }
  }

  function oe(e, r, n) {
    if (r > n) {
      var t = r;
      r = n, n = t;
    }

    var o = e[r];
    o || (e[r] = o = {}), o[n] = !0;
  }

  function ie(e, r, n) {
    if (r > n) {
      var t = r;
      r = n, n = t;
    }

    return s(e[r], n);
  }

  function ae(e, r, n, t) {
    var o = {},
        i = {},
        a = {};

    var _iterator34 = _createForOfIteratorHelper(r),
        _step34;

    try {
      for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
        var s = _step34.value;

        for (var d = 0; d < s.length; d++) {
          o[f = s[d]] = f, i[f] = f, a[f] = d;
        }
      }
    } catch (err) {
      _iterator34.e(err);
    } finally {
      _iterator34.f();
    }

    var _iterator35 = _createForOfIteratorHelper(r),
        _step35;

    try {
      for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
        var s = _step35.value;
        var u = -1;

        var _iterator36 = _createForOfIteratorHelper(s),
            _step36;

        try {
          for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
            var f = _step36.value;
            var h = t(f);
            if (h.length) for (var v = ((h = c(h, function (e) {
              return a[e];
            })).length - 1) / 2, l = Math.floor(v), g = Math.ceil(v); l <= g; ++l) {
              var p = h[l];
              i[f] === f && u < a[p] && !ie(n, f, p) && (i[p] = f, i[f] = o[f] = o[p], u = a[p]);
            }
          }
        } catch (err) {
          _iterator36.e(err);
        } finally {
          _iterator36.f();
        }
      }
    } catch (err) {
      _iterator35.e(err);
    } finally {
      _iterator35.f();
    }

    return {
      root: o,
      align: i
    };
  }

  function se(e, r, n, t, o) {
    var i = {},
        a = function (e, r, n, t) {
      var o = new x(),
          i = e.graph(),
          a = ce(i.nodesep, i.edgesep, t);

      var _iterator37 = _createForOfIteratorHelper(r),
          _step37;

      try {
        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
          var s = _step37.value;
          var d = null;

          var _iterator38 = _createForOfIteratorHelper(s),
              _step38;

          try {
            for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
              var u = _step38.value;
              var f = n[u];

              if (o.setNode(f), d) {
                var h = n[d],
                    c = o.edge(h, f);
                o.setEdge(h, f, Math.max(a(e, u, d), c || 0));
              }

              d = u;
            }
          } catch (err) {
            _iterator38.e(err);
          } finally {
            _iterator38.f();
          }
        }
      } catch (err) {
        _iterator37.e(err);
      } finally {
        _iterator37.f();
      }

      return o;
    }(e, r, n, o),
        s = o ? "borderLeft" : "borderRight";

    function d(e, r) {
      for (var n = a.nodes(), t = n.pop(), o = {}; t;) {
        o[t] ? e(t) : (o[t] = !0, n.push(t), n = n.concat(r(t))), t = n.pop();
      }
    }

    for (var _i4 = 0, _arr2 = (d(function (e) {
      i[e] = a.inEdges(e).reduce(function (e, r) {
        return Math.max(e, i[r.v] + a.edge(r));
      }, 0);
    }, function (e) {
      return a.predecessors(e);
    }), d(function (r) {
      var n = a.outEdges(r).reduce(function (e, r) {
        return Math.min(e, i[r.w] - a.edge(r));
      }, Number.POSITIVE_INFINITY),
          t = e.node(r);
      n !== Number.POSITIVE_INFINITY && t.borderType !== s && (i[r] = Math.max(i[r], n));
    }, function (e) {
      return a.successors(e);
    }), Object.keys(t)); _i4 < _arr2.length; _i4++) {
      var u = _arr2[_i4];
      var f = t[u];
      i[f] = i[n[f]];
    }

    return i;
  }

  function de(e, r) {
    return f(l(r), function (r) {
      var n = Number.NEGATIVE_INFINITY,
          t = Number.POSITIVE_INFINITY;

      for (var o in r) {
        var i = r[o],
            a = ve(e, o) / 2;
        n = Math.max(i + a, n), t = Math.min(i - a, t);
      }

      return n - t;
    });
  }

  function ue(e, r) {
    var n = l(r),
        t = Math.min.apply(Math, _toConsumableArray(n)),
        o = Math.max.apply(Math, _toConsumableArray(n));

    for (var _i5 = 0, _arr3 = ["ul", "ur", "dl", "dr"]; _i5 < _arr3.length; _i5++) {
      var i = _arr3[_i5];
      var a = i[1],
          s = e[i];

      if (s !== r) {
        var d = l(s),
            f = "l" === a ? t - Math.min.apply(Math, _toConsumableArray(d)) : o - Math.max.apply(Math, _toConsumableArray(d));
        f && (e[i] = u(s, function (e) {
          return e + f;
        }));
      }
    }
  }

  function fe(e, r) {
    return u(e.ul, function (n, t) {
      if (r) return e[r.toLowerCase()][t];
      var o = c([e.ul[t], e.ur[t], e.dl[t], e.dr[t]], function (e) {
        return e;
      });
      return (o[1] + o[2]) / 2;
    });
  }

  function he(e) {
    var r,
        n = R(e),
        t = Object.assign(Object.assign({}, re(e, n)), ne(e, n)),
        o = {
      ul: {},
      ur: {},
      dl: {},
      dr: {}
    };

    for (var _i6 = 0, _arr4 = ["u", "d"]; _i6 < _arr4.length; _i6++) {
      var i = _arr4[_i6];

      for (var _i7 = 0, _arr5 = (r = "u" === i ? n : n.map(function (e) {
        return e;
      }).reverse(), ["l", "r"]); _i7 < _arr5.length; _i7++) {
        var a = _arr5[_i7];
        "r" === a && (r = r.map(function (e) {
          return e.map(function (e) {
            return e;
          }).reverse();
        }));
        var s = ae(0, r, t, ("u" === i ? e.predecessors : e.successors).bind(e)),
            d = se(e, r, s.root, s.align, "r" === a);
        "r" === a && (d = u(d, function (e) {
          return -e;
        })), o[i + a] = d;
      }
    }

    return ue(o, de(e, o)), fe(o, e.graph().align);
  }

  function ce(e, r, n) {
    return function (t, o, i) {
      var a,
          d = t.node(o),
          u = t.node(i),
          f = 0;
      if (f += d.width / 2, s(d, "labelpos")) switch (d.labelpos.toLowerCase()) {
        case "l":
          a = -d.width / 2;
          break;

        case "r":
          a = d.width / 2;
      }
      if (a && (f += n ? a : -a), a = 0, f += (d.dummy ? r : e) / 2, f += (u.dummy ? r : e) / 2, f += u.width / 2, s(u, "labelpos")) switch (u.labelpos.toLowerCase()) {
        case "l":
          a = u.width / 2;
          break;

        case "r":
          a = -u.width / 2;
      }
      return a && (f += n ? a : -a), a = 0, f;
    };
  }

  function ve(e, r) {
    return e.node(r).width;
  }

  var le = Object.freeze({
    __proto__: null,
    findType1Conflicts: re,
    findType2Conflicts: ne,
    findOtherInnerSegmentNode: te,
    addConflict: oe,
    hasConflict: ie,
    verticalAlignment: ae,
    horizontalCompaction: se,
    findSmallestWidthAlignment: de,
    alignCoordinates: ue,
    balance: fe,
    positionX: he,
    sep: ce,
    width: ve
  });

  function ge(e) {
    !function (e) {
      var r = R(e),
          n = e.graph().ranksep,
          t = 0;

      var _iterator39 = _createForOfIteratorHelper(r),
          _step39;

      try {
        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
          var o = _step39.value;
          var i = Math.max.apply(Math, _toConsumableArray(o.map(function (r) {
            return e.node(r).height;
          })));

          var _iterator40 = _createForOfIteratorHelper(o),
              _step40;

          try {
            for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
              var a = _step40.value;
              e.node(a).y = t + i / 2;
            }
          } catch (err) {
            _iterator40.e(err);
          } finally {
            _iterator40.f();
          }

          t += i + n;
        }
      } catch (err) {
        _iterator39.e(err);
      } finally {
        _iterator39.f();
      }
    }(e = S(e));
    var r = he(e);

    for (var n in r) {
      e.node(n).x = r[n];
    }
  }

  var pe = Object.freeze({
    __proto__: null,
    bk: le,
    position: ge
  });

  function me(e) {
    var r = {};
    e.sources().forEach(function n(t) {
      var o = e.node(t);
      if (s(r, t)) return o.rank;
      r[t] = !0;
      var i = Math.min.apply(Math, _toConsumableArray(e.outEdges(t).map(function (r) {
        return n(r.w) - e.edge(r).minlen;
      })));
      return i !== Number.POSITIVE_INFINITY && null != i || (i = 0), o.rank = i;
    });
  }

  function we(e, r) {
    return e.node(r.w).rank - e.node(r.v).rank - e.edge(r).minlen;
  }

  function _e(e) {
    var r,
        n = new x({
      directed: !1
    }),
        t = e.nodes()[0],
        o = e.nodeCount();

    for (n.setNode(t, {}); i(e) < o;) {
      r = a(e), s(e, n.hasNode(r.v) ? we(e, r) : -we(e, r));
    }

    return n;

    function i(e) {
      return n.nodes().forEach(function r(t) {
        var _iterator41 = _createForOfIteratorHelper(e.nodeEdges(t)),
            _step41;

        try {
          for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
            var o = _step41.value;
            var i = o.v,
                a = t === i ? o.w : i;
            n.hasNode(a) || we(e, o) || (n.setNode(a, {}), n.setEdge(t, a, {}), r(a));
          }
        } catch (err) {
          _iterator41.e(err);
        } finally {
          _iterator41.f();
        }
      }), n.nodeCount();
    }

    function a(e) {
      return f(e.edges(), function (r) {
        if (n.hasNode(r.v) !== n.hasNode(r.w)) return we(e, r);
      });
    }

    function s(e, r) {
      var _iterator42 = _createForOfIteratorHelper(n.nodes()),
          _step42;

      try {
        for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
          var t = _step42.value;
          e.node(t).rank += r;
        }
      } catch (err) {
        _iterator42.e(err);
      } finally {
        _iterator42.f();
      }
    }
  }

  var be = /*#__PURE__*/function () {
    function be() {
      _classCallCheck(this, be);

      this._arr = [], this._keyIndices = {};
    }

    _createClass(be, [{
      key: "size",
      value: function size() {
        return this._arr.length;
      }
    }, {
      key: "keys",
      value: function keys() {
        return this._arr.map(function (e) {
          return e.key;
        });
      }
    }, {
      key: "has",
      value: function has(e) {
        return e in this._keyIndices;
      }
    }, {
      key: "priority",
      value: function priority(e) {
        var r = this._keyIndices[e];
        if (void 0 !== r) return this._arr[r].priority;
      }
    }, {
      key: "min",
      value: function min() {
        if (0 === this.size()) throw new Error("Queue underflow");
        return this._arr[0].key;
      }
    }, {
      key: "add",
      value: function add(e, r) {
        var n = this._keyIndices;

        if (!((e = String(e)) in n)) {
          var t = this._arr,
              o = t.length;
          return n[e] = o, t.push({
            key: e,
            priority: r
          }), this._decrease(o), !0;
        }

        return !1;
      }
    }, {
      key: "removeMin",
      value: function removeMin() {
        this._swap(0, this._arr.length - 1);

        var e = this._arr.pop();

        return delete this._keyIndices[e.key], this._heapify(0), e.key;
      }
    }, {
      key: "decrease",
      value: function decrease(e, r) {
        var n = this._keyIndices[e];
        if (r > this._arr[n].priority) throw new Error("New priority is greater than current priority. Key: " + e + " Old: " + this._arr[n].priority + " New: " + r);
        this._arr[n].priority = r, this._decrease(n);
      }
    }, {
      key: "_heapify",
      value: function _heapify(e) {
        var r = this._arr,
            n = 2 * e,
            t = n + 1,
            o = e;
        n < r.length && (o = r[n].priority < r[o].priority ? n : o, t < r.length && (o = r[t].priority < r[o].priority ? t : o), o !== e && (this._swap(e, o), this._heapify(o)));
      }
    }, {
      key: "_decrease",
      value: function _decrease(e) {
        for (var r, n = this._arr, t = n[e].priority; 0 !== e && !(n[r = e >> 1].priority < t);) {
          this._swap(e, r), e = r;
        }
      }
    }, {
      key: "_swap",
      value: function _swap(e, r) {
        var n = this._arr,
            t = this._keyIndices,
            o = n[e],
            i = n[r];
        n[e] = i, n[r] = o, t[i.key] = e, t[o.key] = r;
      }
    }]);

    return be;
  }();

  var ye = function ye() {
    return 1;
  };

  function ke(e, r, n, t) {
    return function (e, r, n, t) {
      var o,
          i,
          a = {},
          s = new be(),
          d = function d(e) {
        var r = e.v !== o ? e.v : e.w,
            t = a[r],
            d = n(e),
            u = i.distance + d;
        if (d < 0) throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e + " Weight: " + d);
        u < t.distance && (t.distance = u, t.predecessor = o, s.decrease(r, u));
      };

      e.nodes().forEach(function (e) {
        var n = e === r ? 0 : Number.POSITIVE_INFINITY;
        a[e] = {
          distance: n
        }, s.add(e, n);
      });

      for (; s.size() > 0 && (o = s.removeMin(), (i = a[o]).distance !== Number.POSITIVE_INFINITY);) {
        t(o).forEach(d);
      }

      return a;
    }(e, String(r), n || ye, t || function (r) {
      return e.outEdges(r);
    });
  }

  function Ee(e) {
    var r = 0,
        n = [],
        t = {},
        o = [];

    function i(a) {
      var s = t[a] = {
        onStack: !0,
        lowlink: r,
        index: r++
      };

      if (n.push(a), e.successors(a).forEach(function (e) {
        e in t ? t[e].onStack && (s.lowlink = Math.min(s.lowlink, t[e].index)) : (i(e), s.lowlink = Math.min(s.lowlink, t[e].lowlink));
      }), s.lowlink === s.index) {
        var d,
            u = [];

        do {
          d = n.pop(), t[d].onStack = !1, u.push(d);
        } while (a !== d);

        o.push(u);
      }
    }

    return e.nodes().forEach(function (e) {
      e in t || i(e);
    }), o;
  }

  var Ne = function Ne() {
    return 1;
  };

  var xe = /*#__PURE__*/function (_Error) {
    _inherits(xe, _Error);

    var _super2 = _createSuper(xe);

    function xe() {
      _classCallCheck(this, xe);

      return _super2.apply(this, arguments);
    }

    return xe;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function Ie(e) {
    var r = {},
        n = {},
        t = [];

    function o(i) {
      if (i in n) throw new xe();

      if (!(i in r)) {
        var _iterator43 = _createForOfIteratorHelper((n[i] = !0, r[i] = !0, e.predecessors(i))),
            _step43;

        try {
          for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
            var a = _step43.value;
            o(a);
          }
        } catch (err) {
          _iterator43.e(err);
        } finally {
          _iterator43.f();
        }

        delete n[i], t.push(i);
      }
    }

    var _iterator44 = _createForOfIteratorHelper(e.sinks()),
        _step44;

    try {
      for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
        var i = _step44.value;
        o(i);
      }
    } catch (err) {
      _iterator44.e(err);
    } finally {
      _iterator44.f();
    }

    if (Object.keys(r).length !== e.nodeCount()) throw new xe();
    return t;
  }

  function Ce(e, r, n) {
    var t = Array.isArray(r) ? r : [r],
        o = (e.isDirected() ? e.successors : e.neighbors).bind(e),
        i = [],
        a = {};

    var _iterator45 = _createForOfIteratorHelper(t),
        _step45;

    try {
      for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
        var s = _step45.value;
        if (!e.hasNode(s)) throw new Error("Graph does not have node: " + s);
        Oe(e, s, "post" === n, a, o, i);
      }
    } catch (err) {
      _iterator45.e(err);
    } finally {
      _iterator45.f();
    }

    return i;
  }

  function Oe(e, r, n, t, o, i) {
    if (!(r in t)) {
      var _iterator46 = _createForOfIteratorHelper((t[r] = !0, n || i.push(r), o(r))),
          _step46;

      try {
        for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
          var a = _step46.value;
          Oe(e, a, n, t, o, i);
        }
      } catch (err) {
        _iterator46.e(err);
      } finally {
        _iterator46.f();
      }

      n && i.push(r);
    }
  }

  function je(e, r) {
    return Ce(e, r, "post");
  }

  function Me(e, r) {
    return Ce(e, r, "pre");
  }

  var Le = Object.freeze({
    __proto__: null,
    components: function components(e) {
      var r,
          n = {},
          t = [];

      function o(t) {
        if (!(t in n)) {
          var _iterator47 = _createForOfIteratorHelper((n[t] = !0, r.push(t), e.successors(t))),
              _step47;

          try {
            for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
              var i = _step47.value;
              o(i);
            }
          } catch (err) {
            _iterator47.e(err);
          } finally {
            _iterator47.f();
          }

          var _iterator48 = _createForOfIteratorHelper(e.predecessors(t)),
              _step48;

          try {
            for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
              var a = _step48.value;
              o(a);
            }
          } catch (err) {
            _iterator48.e(err);
          } finally {
            _iterator48.f();
          }
        }
      }

      var _iterator49 = _createForOfIteratorHelper(e.nodes()),
          _step49;

      try {
        for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
          var i = _step49.value;
          r = [], o(i), r.length && t.push(r);
        }
      } catch (err) {
        _iterator49.e(err);
      } finally {
        _iterator49.f();
      }

      return t;
    },
    dijkstra: ke,
    dijkstraAll: function dijkstraAll(e, r, n) {
      var t = {};

      var _iterator50 = _createForOfIteratorHelper(e.nodes()),
          _step50;

      try {
        for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
          var o = _step50.value;
          t[o] = ke(e, o, r, n);
        }
      } catch (err) {
        _iterator50.e(err);
      } finally {
        _iterator50.f();
      }

      return t;
    },
    findCycles: function findCycles(e) {
      return Ee(e).filter(function (r) {
        return r.length > 1 || 1 === r.length && e.hasEdge(r[0], r[0]);
      });
    },
    floydWarshall: function floydWarshall(e, r, n) {
      return function (e, r, n) {
        var t = {},
            o = e.nodes();
        return o.forEach(function (e) {
          t[e] = {}, t[e][e] = {
            distance: 0
          }, o.forEach(function (r) {
            e !== r && (t[e][r] = {
              distance: Number.POSITIVE_INFINITY
            });
          }), n(e).forEach(function (n) {
            var o = n.v === e ? n.w : n.v,
                i = r(n);
            t[e][o] = {
              distance: i,
              predecessor: e
            };
          });
        }), o.forEach(function (e) {
          var r = t[e];
          o.forEach(function (n) {
            var i = t[n];
            o.forEach(function (n) {
              var t = i[e],
                  o = r[n],
                  a = i[n],
                  s = t.distance + o.distance;
              s < a.distance && (a.distance = s, a.predecessor = o.predecessor);
            });
          });
        }), t;
      }(e, r || Ne, n || function (r) {
        return e.outEdges(r);
      });
    },
    isAcyclic: function isAcyclic(e) {
      try {
        Ie(e);
      } catch (e) {
        if (_instanceof(e, xe)) return !1;
        throw e;
      }

      return !0;
    },
    postorder: je,
    preorder: Me,
    prim: function prim(e, r) {
      var n,
          t = new I({}),
          o = {},
          i = new be();

      function a(e) {
        var t = e.v === n ? e.w : e.v,
            a = i.priority(t);

        if (void 0 !== a) {
          var s = r(e);
          s < a && (o[t] = n, i.decrease(t, s));
        }
      }

      if (0 === e.nodeCount()) return t;

      var _iterator51 = _createForOfIteratorHelper(e.nodes()),
          _step51;

      try {
        for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
          n = _step51.value;
          i.add(n, Number.POSITIVE_INFINITY), t.setNode(n);
        }
      } catch (err) {
        _iterator51.e(err);
      } finally {
        _iterator51.f();
      }

      i.decrease(e.nodes()[0], 0);

      for (var s = !1; i.size() > 0;) {
        if ((n = i.removeMin()) in o) t.setEdge(n, o[n]);else {
          if (s) throw new Error("Input graph is not connected: " + e);
          s = !0;
        }
        e.nodeEdges(n).forEach(a);
      }

      return t;
    },
    tarjan: Ee,
    topsort: Ie
  });

  function Te(e) {
    me(e = T(e));

    var r,
        n = _e(e);

    for (Fe(n), Se(n, e); r = ze(n);) {
      Ve(n, e, r, Ge(n, e, r));
    }
  }

  function Se(e, r) {
    var n = je(e, e.nodes());

    var _iterator52 = _createForOfIteratorHelper(n = n.slice(0, n.length - 1)),
        _step52;

    try {
      for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
        var t = _step52.value;
        Pe(e, r, t);
      }
    } catch (err) {
      _iterator52.e(err);
    } finally {
      _iterator52.f();
    }
  }

  function Pe(e, r, n) {
    var t = e.node(n).parent;
    e.edge(n, t).cutvalue = Re(e, r, n);
  }

  function Re(e, r, n) {
    var t,
        o,
        i = e.node(n).parent,
        a = !0,
        s = r.edge(n, i),
        d = 0;

    var _iterator53 = _createForOfIteratorHelper((s || (a = !1, s = r.edge(i, n)), d = s.weight, r.nodeEdges(n))),
        _step53;

    try {
      for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
        var u = _step53.value;
        var f = u.v === n,
            h = f ? u.w : u.v;

        if (h !== i) {
          var c = f === a,
              v = r.edge(u).weight;

          if (d += c ? v : -v, t = n, o = h, e.hasEdge(t, o)) {
            var l = e.edge(n, h).cutvalue;
            d += c ? -l : l;
          }
        }
      }
    } catch (err) {
      _iterator53.e(err);
    } finally {
      _iterator53.f();
    }

    return d;
  }

  function Fe(e, r) {
    arguments.length < 2 && (r = e.nodes()[0]), De(e, {}, 1, r);
  }

  function De(e, r, n, t, o) {
    var i = n,
        a = e.node(t);

    var _iterator54 = _createForOfIteratorHelper((r[t] = !0, e.neighbors(t))),
        _step54;

    try {
      for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
        var d = _step54.value;
        s(r, d) || (n = De(e, r, n, d, t));
      }
    } catch (err) {
      _iterator54.e(err);
    } finally {
      _iterator54.f();
    }

    return a.low = i, a.lim = n++, o ? a.parent = o : delete a.parent, n;
  }

  function ze(e) {
    var _iterator55 = _createForOfIteratorHelper(e.edges()),
        _step55;

    try {
      for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
        var r = _step55.value;
        if (e.edge(r).cutvalue < 0) return r;
      }
    } catch (err) {
      _iterator55.e(err);
    } finally {
      _iterator55.f();
    }
  }

  function Ge(e, r, n) {
    var t = n.v,
        o = n.w;
    r.hasEdge(t, o) || (t = n.w, o = n.v);
    var i = e.node(t),
        a = e.node(o),
        s = i,
        d = !1;
    return i.lim > a.lim && (s = a, d = !0), f(r.edges().filter(function (r) {
      return d === Ye(e, e.node(r.v), s) && d !== Ye(e, e.node(r.w), s);
    }), function (e) {
      return we(r, e);
    });
  }

  function Ve(e, r, n, t) {
    var o = n.v,
        i = n.w;
    e.removeEdge(o, i), e.setEdge(t.v, t.w, {}), Fe(e), Se(e, r), function (e, r) {
      var n = function (e, r) {
        var _iterator56 = _createForOfIteratorHelper(e.nodes()),
            _step56;

        try {
          for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
            var n = _step56.value;
            if (!r.node(n).parent) return n;
          }
        } catch (err) {
          _iterator56.e(err);
        } finally {
          _iterator56.f();
        }

        return;
      }(e, r),
          t = Me(e, n);

      var _iterator57 = _createForOfIteratorHelper(t = t.slice(1)),
          _step57;

      try {
        for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
          var o = _step57.value;
          var i = e.node(o).parent,
              a = r.edge(o, i),
              s = !1;
          a || (a = r.edge(i, o), s = !0), r.node(o).rank = r.node(i).rank + (s ? a.minlen : -a.minlen);
        }
      } catch (err) {
        _iterator57.e(err);
      } finally {
        _iterator57.f();
      }
    }(e, r);
  }

  function Ye(e, r, n) {
    return n.low <= r.lim && r.lim <= n.lim;
  }

  function Be(e) {
    switch (e.graph().ranker) {
      case "network-simplex":
        We(e);
        break;

      case "tight-tree":
        qe(e);
        break;

      case "longest-path":
        Ae(e);
        break;

      default:
        We(e);
    }
  }

  Te.initLowLimValues = Fe, Te.initCutValues = Se, Te.calcCutValue = Re, Te.leaveEdge = ze, Te.enterEdge = Ge, Te.exchangeEdges = Ve;
  var Ae = me;

  function qe(e) {
    me(e), _e(e);
  }

  function We(e) {
    Te(e);
  }

  var $e = Object.freeze({
    __proto__: null,
    rank: Be,
    tightTreeRanker: qe,
    networkSimplexRanker: We,
    networkSimplex: Te,
    feasibleTree: _e,
    longestPath: me
  }),
      Je = function Je(e) {
    return 1;
  };

  function Qe(e, n) {
    if (e.nodeCount() <= 1) return [];

    var t = function (e, n) {
      var t = new x(),
          o = 0,
          i = 0;

      var _iterator58 = _createForOfIteratorHelper(e.nodes()),
          _step58;

      try {
        for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
          var a = _step58.value;
          t.setNode(a, {
            v: a,
            in: 0,
            out: 0
          });
        }
      } catch (err) {
        _iterator58.e(err);
      } finally {
        _iterator58.f();
      }

      var _iterator59 = _createForOfIteratorHelper(e.edges()),
          _step59;

      try {
        for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
          var s = _step59.value;
          var d = t.edge(s.v, s.w) || 0,
              u = n(s),
              f = d + u;
          t.setEdge(s.v, s.w, f), i = Math.max(i, t.node(s.v).out += u), o = Math.max(o, t.node(s.w).in += u);
        }
      } catch (err) {
        _iterator59.e(err);
      } finally {
        _iterator59.f();
      }

      var h = g(i + o + 3, function () {
        return new r();
      }),
          c = o + 1;

      var _iterator60 = _createForOfIteratorHelper(t.nodes()),
          _step60;

      try {
        for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
          var a = _step60.value;
          Xe(h, c, t.node(a));
        }
      } catch (err) {
        _iterator60.e(err);
      } finally {
        _iterator60.f();
      }

      return {
        graph: t,
        buckets: h,
        zeroIdx: c
      };
    }(e, n || Je);

    return a(function (e, r, n) {
      var t,
          o = [],
          i = r[r.length - 1],
          a = r[0];

      for (; e.nodeCount();) {
        for (; t = a.dequeue();) {
          Ke(e, r, n, t);
        }

        for (; t = i.dequeue();) {
          Ke(e, r, n, t);
        }

        if (e.nodeCount()) for (var s = r.length - 2; s > 0; --s) {
          if (t = r[s].dequeue()) {
            o = o.concat(Ke(e, r, n, t, !0));
            break;
          }
        }
      }

      return o;
    }(t.graph, t.buckets, t.zeroIdx).map(function (r) {
      return e.outEdges(r.v, r.w);
    }));
  }

  function Ke(e, r, n, t, o) {
    var i = o ? [] : void 0;

    var _iterator61 = _createForOfIteratorHelper(e.inEdges(t.v)),
        _step61;

    try {
      for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {
        var a = _step61.value;
        var s = e.edge(a),
            d = e.node(a.v);
        o && i.push({
          v: a.v,
          w: a.w
        }), d.out -= s, Xe(r, n, d);
      }
    } catch (err) {
      _iterator61.e(err);
    } finally {
      _iterator61.f();
    }

    var _iterator62 = _createForOfIteratorHelper(e.outEdges(t.v)),
        _step62;

    try {
      for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
        var a = _step62.value;
        s = e.edge(a);
        var u = a.w,
            f = e.node(u);
        f.in -= s, Xe(r, n, f);
      }
    } catch (err) {
      _iterator62.e(err);
    } finally {
      _iterator62.f();
    }

    return e.removeNode(t.v), i;
  }

  function Xe(e, r, n) {
    n.out ? n.in ? e[n.out - n.in + r].enqueue(n) : e[e.length - 1].enqueue(n) : e[0].enqueue(n);
  }

  var He = {
    run: function run(e) {
      var r = "greedy" === e.graph().acyclicer ? Qe(e, function (e) {
        return function (r) {
          return e.edge(r).weight;
        };
      }(e)) : function (e) {
        var r = [],
            n = {},
            t = {};

        function o(i) {
          if (!s(t, i)) {
            var _iterator63 = _createForOfIteratorHelper((t[i] = !0, n[i] = !0, e.outEdges(i))),
                _step63;

            try {
              for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
                var a = _step63.value;
                s(n, a.w) ? r.push(a) : o(a.w);
              }
            } catch (err) {
              _iterator63.e(err);
            } finally {
              _iterator63.f();
            }

            delete n[i];
          }
        }

        return e.nodes().forEach(o), r;
      }(e);

      var _iterator64 = _createForOfIteratorHelper(r),
          _step64;

      try {
        for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {
          var n = _step64.value;
          var t = e.edge(n);
          e.removeEdge(n), t.forwardName = n.name, t.reversed = !0, e.setEdge(n.w, n.v, t, v("rev"));
        }
      } catch (err) {
        _iterator64.e(err);
      } finally {
        _iterator64.f();
      }
    },
    undo: function undo(e) {
      var _iterator65 = _createForOfIteratorHelper(e.edges()),
          _step65;

      try {
        for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
          var r = _step65.value;
          var n = e.edge(r);

          if (n.reversed) {
            e.removeEdge(r);
            var t = n.forwardName;
            delete n.reversed, delete n.forwardName, e.setEdge(r.w, r.v, n, t);
          }
        }
      } catch (err) {
        _iterator65.e(err);
      } finally {
        _iterator65.f();
      }
    }
  };

  function Ue(e) {
    e.children().forEach(function r(n) {
      var t = e.children(n),
          o = e.node(n);

      if (t.length && t.forEach(r), s(o, "minRank")) {
        o.borderLeft = [], o.borderRight = [];

        for (var i = o.minRank, a = o.maxRank + 1; i < a; ++i) {
          Ze(e, "borderLeft", "_bl", n, o, i), Ze(e, "borderRight", "_br", n, o, i);
        }
      }
    });
  }

  function Ze(e, r, n, t, o, i) {
    var a = {
      width: 0,
      height: 0,
      rank: i,
      borderType: r
    },
        s = o[r][i - 1],
        d = L(e, "border", a, n);
    o[r][i] = d, e.setParent(d, t), s && e.setEdge(s, d, {
      weight: 1
    });
  }

  var er = {
    adjust: function adjust(e) {
      var r = e.graph().rankdir.toLowerCase();
      "lr" !== r && "rl" !== r || rr(e);
    },
    undo: function undo(e) {
      var r = e.graph().rankdir.toLowerCase();
      "bt" !== r && "rl" !== r || function (e) {
        var _iterator66 = _createForOfIteratorHelper(e.nodes()),
            _step66;

        try {
          for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
            var r = _step66.value;
            tr(e.node(r));
          }
        } catch (err) {
          _iterator66.e(err);
        } finally {
          _iterator66.f();
        }

        var _iterator67 = _createForOfIteratorHelper(e.edges()),
            _step67;

        try {
          for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {
            var n = _step67.value;
            var t = e.edge(n);
            t.points.forEach(tr), s(t, "y") && tr(t);
          }
        } catch (err) {
          _iterator67.e(err);
        } finally {
          _iterator67.f();
        }
      }(e);
      "lr" !== r && "rl" !== r || (!function (e) {
        var _iterator68 = _createForOfIteratorHelper(e.nodes()),
            _step68;

        try {
          for (_iterator68.s(); !(_step68 = _iterator68.n()).done;) {
            var r = _step68.value;
            or(e.node(r));
          }
        } catch (err) {
          _iterator68.e(err);
        } finally {
          _iterator68.f();
        }

        var _iterator69 = _createForOfIteratorHelper(e.edges()),
            _step69;

        try {
          for (_iterator69.s(); !(_step69 = _iterator69.n()).done;) {
            var n = _step69.value;
            var t = e.edge(n);
            t.points.forEach(or), s(t, "x") && or(t);
          }
        } catch (err) {
          _iterator69.e(err);
        } finally {
          _iterator69.f();
        }
      }(e), rr(e));
    }
  };

  function rr(e) {
    var _iterator70 = _createForOfIteratorHelper(e.nodes()),
        _step70;

    try {
      for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {
        var r = _step70.value;
        nr(e.node(r));
      }
    } catch (err) {
      _iterator70.e(err);
    } finally {
      _iterator70.f();
    }

    var _iterator71 = _createForOfIteratorHelper(e.edges()),
        _step71;

    try {
      for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {
        var n = _step71.value;
        nr(e.edge(n));
      }
    } catch (err) {
      _iterator71.e(err);
    } finally {
      _iterator71.f();
    }
  }

  function nr(e) {
    var r = e.width;
    e.width = e.height, e.height = r;
  }

  function tr(e) {
    e.y = -e.y;
  }

  function or(e) {
    var r = e.x;
    e.x = e.y, e.y = r;
  }

  var ir = Object.freeze({
    __proto__: null,
    debugOrdering: function debugOrdering(e) {
      var r = R(e),
          n = new x({
        compound: !0,
        multigraph: !0
      }).setGraph({});

      var _iterator72 = _createForOfIteratorHelper(e.nodes()),
          _step72;

      try {
        for (_iterator72.s(); !(_step72 = _iterator72.n()).done;) {
          var t = _step72.value;
          n.setNode(t, {
            label: t
          }), n.setParent(t, "layer" + e.node(t).rank);
        }
      } catch (err) {
        _iterator72.e(err);
      } finally {
        _iterator72.f();
      }

      var _iterator73 = _createForOfIteratorHelper(e.edges()),
          _step73;

      try {
        for (_iterator73.s(); !(_step73 = _iterator73.n()).done;) {
          var o = _step73.value;
          n.setEdge(o.v, o.w, {}, o.name);
        }
      } catch (err) {
        _iterator73.e(err);
      } finally {
        _iterator73.f();
      }

      var i = 0;

      var _iterator74 = _createForOfIteratorHelper(r),
          _step74;

      try {
        for (_iterator74.s(); !(_step74 = _iterator74.n()).done;) {
          var a = _step74.value;
          var s = "layer" + i;
          i++, n.setNode(s, {
            rank: "same"
          }), a.reduce(function (e, r) {
            return n.setEdge(e.toString(), r, {
              style: "invis"
            }), r;
          });
        }
      } catch (err) {
        _iterator74.e(err);
      } finally {
        _iterator74.f();
      }

      return n;
    }
  }),
      ar = {
    run: function run(e) {
      var _iterator75 = _createForOfIteratorHelper((e.graph().dummyChains = [], e.edges())),
          _step75;

      try {
        for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {
          var r = _step75.value;
          sr(e, r);
        }
      } catch (err) {
        _iterator75.e(err);
      } finally {
        _iterator75.f();
      }
    },
    undo: function undo(e) {
      var _iterator76 = _createForOfIteratorHelper(e.graph().dummyChains),
          _step76;

      try {
        for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {
          var r = _step76.value;
          var n,
              t = e.node(r),
              o = t.edgeLabel;

          for (e.setEdge(t.edgeObj, o); t.dummy;) {
            n = e.successors(r)[0], e.removeNode(r), o.points.push({
              x: t.x,
              y: t.y
            }), "edge-label" === t.dummy && (o.x = t.x, o.y = t.y, o.width = t.width, o.height = t.height), r = n, t = e.node(r);
          }
        }
      } catch (err) {
        _iterator76.e(err);
      } finally {
        _iterator76.f();
      }
    }
  };

  function sr(e, r) {
    var n = r.v,
        t = e.node(n).rank,
        o = r.w,
        i = e.node(o).rank,
        a = r.name,
        s = e.edge(r),
        d = s.labelRank;

    if (i !== t + 1) {
      var u, f, h;

      for (e.removeEdge(r), h = 0, ++t; t < i; ++h, ++t) {
        s.points = [], u = L(e, "edge", f = {
          width: 0,
          height: 0,
          edgeLabel: s,
          edgeObj: r,
          rank: t
        }, "_d"), t === d && (f.width = s.width, f.height = s.height, f.dummy = "edge-label", f.labelpos = s.labelpos), e.setEdge(n, u, {
          weight: s.weight
        }, a), 0 === h && e.graph().dummyChains.push(u), n = u;
      }

      e.setEdge(n, o, {
        weight: s.weight
      }, a);
    }
  }

  function dr(e) {
    var r = function (e) {
      var r = {},
          n = 0;

      function t(o) {
        var i = n;
        e.children(o).forEach(t), r[o] = {
          low: i,
          lim: n++
        };
      }

      return e.children().forEach(t), r;
    }(e);

    var _iterator77 = _createForOfIteratorHelper(e.graph().dummyChains),
        _step77;

    try {
      for (_iterator77.s(); !(_step77 = _iterator77.n()).done;) {
        var n = _step77.value;

        for (var t = e.node(n), o = t.edgeObj, i = ur(e, r, o.v, o.w), a = i.path, s = i.lca, d = 0, u = a[d], f = !0; n !== o.w;) {
          if (t = e.node(n), f) {
            for (; (u = a[d]) !== s && e.node(u).maxRank < t.rank;) {
              d++;
            }

            u === s && (f = !1);
          }

          if (!f) {
            for (; d < a.length - 1 && e.node(u = a[d + 1]).minRank <= t.rank;) {
              d++;
            }

            u = a[d];
          }

          e.setParent(n, u), n = e.successors(n)[0];
        }
      }
    } catch (err) {
      _iterator77.e(err);
    } finally {
      _iterator77.f();
    }
  }

  function ur(e, r, n, t) {
    var o,
        i,
        a = [],
        s = [],
        d = Math.min(r[n].low, r[t].low),
        u = Math.max(r[n].lim, r[t].lim);
    o = n;

    do {
      o = e.parent(o), a.push(o);
    } while (o && (r[o].low > d || u > r[o].lim));

    for (i = o, o = t; (o = e.parent(o)) !== i;) {
      s.push(o);
    }

    return {
      path: a.concat(s.reverse()),
      lca: i
    };
  }

  var fr = {
    run: function run(e) {
      var r = L(e, "root", {}, "_root"),
          n = function (e) {
        var r = {};

        function n(t, o) {
          var i = e.children(t);

          if (i && i.length) {
            var _iterator78 = _createForOfIteratorHelper(i),
                _step78;

            try {
              for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {
                var a = _step78.value;
                n(a, o + 1);
              }
            } catch (err) {
              _iterator78.e(err);
            } finally {
              _iterator78.f();
            }
          }

          r[t] = o;
        }

        var _iterator79 = _createForOfIteratorHelper(e.children()),
            _step79;

        try {
          for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {
            var t = _step79.value;
            n(t, 1);
          }
        } catch (err) {
          _iterator79.e(err);
        } finally {
          _iterator79.f();
        }

        return r;
      }(e),
          t = Math.max.apply(Math, _toConsumableArray(l(n))) - 1,
          o = 2 * t + 1;

      var _iterator80 = _createForOfIteratorHelper((e.graph().nestingRoot = r, e.edges())),
          _step80;

      try {
        for (_iterator80.s(); !(_step80 = _iterator80.n()).done;) {
          var i = _step80.value;
          e.edge(i).minlen *= o;
        }
      } catch (err) {
        _iterator80.e(err);
      } finally {
        _iterator80.f();
      }

      var a = function (e) {
        return e.edges().reduce(function (r, n) {
          return r + e.edge(n).weight;
        }, 0);
      }(e) + 1;

      var _iterator81 = _createForOfIteratorHelper(e.children()),
          _step81;

      try {
        for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {
          var s = _step81.value;
          hr(e, r, o, a, t, n, s);
        }
      } catch (err) {
        _iterator81.e(err);
      } finally {
        _iterator81.f();
      }

      e.graph().nodeRankFactor = o;
    },
    cleanup: function cleanup(e) {
      var r = e.graph();

      var _iterator82 = _createForOfIteratorHelper((e.removeNode(r.nestingRoot), delete r.nestingRoot, e.edges())),
          _step82;

      try {
        for (_iterator82.s(); !(_step82 = _iterator82.n()).done;) {
          var n = _step82.value;
          e.edge(n).nestingEdge && e.removeEdge(n);
        }
      } catch (err) {
        _iterator82.e(err);
      } finally {
        _iterator82.f();
      }
    }
  };

  function hr(e, r, n, t, o, i, a) {
    var s = e.children(a);

    if (s.length) {
      var d = z(e, "_bt"),
          u = z(e, "_bb"),
          f = e.node(a);

      var _iterator83 = _createForOfIteratorHelper((e.setParent(d, a), f.borderTop = d, e.setParent(u, a), f.borderBottom = u, s)),
          _step83;

      try {
        for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {
          var h = _step83.value;
          hr(e, r, n, t, o, i, h);
          var c = e.node(h),
              v = c.borderTop ? c.borderTop : h,
              l = c.borderBottom ? c.borderBottom : h,
              g = c.borderTop ? t : 2 * t,
              p = v !== l ? 1 : o - i[a] + 1;
          e.setEdge(d, v, {
            weight: g,
            minlen: p,
            nestingEdge: !0
          }), e.setEdge(l, u, {
            weight: g,
            minlen: p,
            nestingEdge: !0
          });
        }
      } catch (err) {
        _iterator83.e(err);
      } finally {
        _iterator83.f();
      }

      e.parent(a) || e.setEdge(r, d, {
        weight: 0,
        minlen: o + i[a]
      });
    } else a !== r && e.setEdge(r, a, {
      weight: 0,
      minlen: n
    });
  }

  function cr(e) {
    return "edge-proxy" == e.dummy;
  }

  function vr(e) {
    return "selfedge" == e.dummy;
  }

  var lr = 50,
      gr = 20,
      pr = 50,
      mr = "tb",
      wr = 1,
      _r = 1,
      br = 0,
      yr = 0,
      kr = 10,
      Er = "r";

  function Nr() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var r = {};

    for (var _i8 = 0, _Object$keys3 = Object.keys(e); _i8 < _Object$keys3.length; _i8++) {
      var n = _Object$keys3[_i8];
      r[n.toLowerCase()] = e[n];
    }

    return r;
  }

  function xr(e) {
    return e.nodes().map(function (r) {
      var n = e.node(r),
          t = e.parent(r),
          o = {
        v: r
      };
      return void 0 !== n && (o.value = n), void 0 !== t && (o.parent = t), o;
    });
  }

  function Ir(e) {
    return e.edges().map(function (r) {
      var n = e.edge(r),
          t = {
        v: r.v,
        w: r.w
      };
      return void 0 !== r.name && (t.name = r.name), void 0 !== n && (t.value = n), t;
    });
  }

  var Cr = Object.freeze({
    __proto__: null,
    write: function write(e) {
      var r = {
        options: {
          directed: e.isDirected(),
          multigraph: e.isMultigraph(),
          compound: e.isCompound()
        },
        nodes: xr(e),
        edges: Ir(e)
      };
      return void 0 !== e.graph() && (r.value = JSON.parse(JSON.stringify(e.graph()))), r;
    },
    read: function read(e) {
      var r = new x(e.options).setGraph(e.value);

      var _iterator84 = _createForOfIteratorHelper(e.nodes),
          _step84;

      try {
        for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {
          var n = _step84.value;
          r.setNode(n.v, n.value), n.parent && r.setParent(n.v, n.parent);
        }
      } catch (err) {
        _iterator84.e(err);
      } finally {
        _iterator84.f();
      }

      var _iterator85 = _createForOfIteratorHelper(e.edges),
          _step85;

      try {
        for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {
          var n = _step85.value;
          r.setEdge({
            v: n.v,
            w: n.w,
            name: n.name
          }, n.value);
        }
      } catch (err) {
        _iterator85.e(err);
      } finally {
        _iterator85.f();
      }

      return r;
    }
  }),
      Or = {
    Graph: x,
    GraphLike: I,
    alg: Le,
    json: Cr,
    PriorityQueue: be
  };
  e.Graph = x, e.GraphLike = I, e.PriorityQueue = be, e.acyclic = He, e.addBorderSegments = Ue, e.alg = Le, e.coordinateSystem = er, e.data = o, e.debug = ir, e.graphlib = Or, e.greedyFAS = Qe, e.json = Cr, e.layout = function (e, r) {
    var n = r && r.debugTiming ? Y : B;
    n("layout", function () {
      var r = n("  buildLayoutGraph", function () {
        return function (e) {
          var r,
              n,
              t,
              o,
              i,
              a,
              s,
              d,
              u,
              f,
              h,
              c,
              v,
              l,
              g,
              p = new x({
            multigraph: !0,
            compound: !0
          }),
              m = Nr(e.graph()),
              w = {
            nodesep: null !== (r = m.nodesep) && void 0 !== r ? r : pr,
            edgesep: null !== (n = m.edgesep) && void 0 !== n ? n : gr,
            ranksep: null !== (t = m.ranksep) && void 0 !== t ? t : lr,
            marginx: +(null !== (o = m.marginx) && void 0 !== o ? o : 0),
            marginy: +(null !== (i = m.marginy) && void 0 !== i ? i : 0),
            acyclicer: m.acyclicer,
            ranker: null !== (a = m.ranker) && void 0 !== a ? a : "network-simplex",
            rankdir: null !== (s = m.rankdir) && void 0 !== s ? s : mr,
            align: m.align
          };

          var _iterator86 = _createForOfIteratorHelper((p.setGraph(w), e.nodes())),
              _step86;

          try {
            for (_iterator86.s(); !(_step86 = _iterator86.n()).done;) {
              var _ = _step86.value;
              var b = Nr(e.node(_)),
                  y = {
                width: +(null !== (d = b && b.width) && void 0 !== d ? d : 0),
                height: +(null !== (u = b && b.height) && void 0 !== u ? u : 0)
              };
              p.setNode(_, y), p.setParent(_, e.parent(_));
            }
          } catch (err) {
            _iterator86.e(err);
          } finally {
            _iterator86.f();
          }

          var _iterator87 = _createForOfIteratorHelper(e.edges()),
              _step87;

          try {
            for (_iterator87.s(); !(_step87 = _iterator87.n()).done;) {
              var k = _step87.value;
              var E = Nr(e.edge(k)),
                  N = {
                minlen: null !== (f = E.minlen) && void 0 !== f ? f : wr,
                weight: null !== (h = E.weight) && void 0 !== h ? h : _r,
                width: null !== (c = E.width) && void 0 !== c ? c : br,
                height: null !== (v = E.height) && void 0 !== v ? v : yr,
                labeloffset: null !== (l = E.labeloffset) && void 0 !== l ? l : kr,
                labelpos: null !== (g = E.labelpos) && void 0 !== g ? g : Er
              };
              p.setEdge(k, N);
            }
          } catch (err) {
            _iterator87.e(err);
          } finally {
            _iterator87.f();
          }

          return p;
        }(e);
      });
      n("  runLayout", function () {
        !function (e, r) {
          r("    makeSpaceForEdgeLabels", function () {
            !function (e) {
              var r = e.graph();

              var _iterator88 = _createForOfIteratorHelper((r.ranksep /= 2, e.edges())),
                  _step88;

              try {
                for (_iterator88.s(); !(_step88 = _iterator88.n()).done;) {
                  var n = _step88.value;
                  var t = e.edge(n);
                  t.minlen *= 2, "c" !== t.labelpos.toLowerCase() && ("TB" === r.rankdir || "BT" === r.rankdir ? t.width += t.labeloffset : t.height += t.labeloffset);
                }
              } catch (err) {
                _iterator88.e(err);
              } finally {
                _iterator88.f();
              }
            }(e);
          }), r("    removeSelfEdges", function () {
            !function (e) {
              var _iterator89 = _createForOfIteratorHelper(e.edges()),
                  _step89;

              try {
                for (_iterator89.s(); !(_step89 = _iterator89.n()).done;) {
                  var r = _step89.value;

                  if (r.v === r.w) {
                    var n = e.node(r.v);
                    n.selfEdges || (n.selfEdges = []), n.selfEdges.push({
                      e: r,
                      label: e.edge(r)
                    }), e.removeEdge(r);
                  }
                }
              } catch (err) {
                _iterator89.e(err);
              } finally {
                _iterator89.f();
              }
            }(e);
          }), r("    acyclic", function () {
            He.run(e);
          }), r("    nestingGraph.run", function () {
            fr.run(e);
          }), r("    rank", function () {
            Be(S(e));
          }), r("    injectEdgeLabelProxies", function () {
            !function (e) {
              var _iterator90 = _createForOfIteratorHelper(e.edges()),
                  _step90;

              try {
                for (_iterator90.s(); !(_step90 = _iterator90.n()).done;) {
                  var r = _step90.value;
                  var n = e.edge(r);

                  if (n.width && n.height) {
                    var t = e.node(r.v),
                        o = e.node(r.w);
                    L(e, "edge-proxy", {
                      rank: (o.rank - t.rank) / 2 + t.rank,
                      e: r
                    }, "_ep");
                  }
                }
              } catch (err) {
                _iterator90.e(err);
              } finally {
                _iterator90.f();
              }
            }(e);
          }), r("    removeEmptyRanks", function () {
            D(e);
          }), r("    nestingGraph.cleanup", function () {
            fr.cleanup(e);
          }), r("    normalizeRanks", function () {
            F(e);
          }), r("    assignRankMinMax", function () {
            !function (e) {
              var r = 0;

              var _iterator91 = _createForOfIteratorHelper(e.nodes()),
                  _step91;

              try {
                for (_iterator91.s(); !(_step91 = _iterator91.n()).done;) {
                  var n = _step91.value;
                  var t = e.node(n);
                  t.borderTop && (t.minRank = e.node(t.borderTop).rank, t.maxRank = e.node(t.borderBottom).rank, r = Math.max(r, t.maxRank));
                }
              } catch (err) {
                _iterator91.e(err);
              } finally {
                _iterator91.f();
              }

              e.graph().maxRank = r;
            }(e);
          }), r("    removeEdgeLabelProxies", function () {
            !function (e) {
              var _iterator92 = _createForOfIteratorHelper(e.nodes()),
                  _step92;

              try {
                for (_iterator92.s(); !(_step92 = _iterator92.n()).done;) {
                  var r = _step92.value;
                  var n = e.node(r);
                  cr(n) && (e.edge(n.e).labelRank = n.rank, e.removeNode(r));
                }
              } catch (err) {
                _iterator92.e(err);
              } finally {
                _iterator92.f();
              }
            }(e);
          }), r("    normalize.run", function () {
            ar.run(e);
          }), r("    parentDummyChains", function () {
            dr(e);
          }), r("    addBorderSegments", function () {
            Ue(e);
          }), r("    order", function () {
            X(e);
          }), r("    insertSelfEdges", function () {
            !function (e) {
              var r,
                  n = R(e);

              var _iterator93 = _createForOfIteratorHelper(n),
                  _step93;

              try {
                for (_iterator93.s(); !(_step93 = _iterator93.n()).done;) {
                  var t = _step93.value;

                  for (var o = 0, i = 0; i < t.length; i++) {
                    var a = t[i],
                        s = e.node(a);

                    var _iterator94 = _createForOfIteratorHelper((s.order = i + o, null !== (r = s.selfEdges) && void 0 !== r ? r : [])),
                        _step94;

                    try {
                      for (_iterator94.s(); !(_step94 = _iterator94.n()).done;) {
                        var d = _step94.value;
                        L(e, "selfedge", {
                          width: d.label.width,
                          height: d.label.height,
                          rank: s.rank,
                          order: i + ++o,
                          e: d.e,
                          label: d.label
                        }, "_se");
                      }
                    } catch (err) {
                      _iterator94.e(err);
                    } finally {
                      _iterator94.f();
                    }

                    delete s.selfEdges;
                  }
                }
              } catch (err) {
                _iterator93.e(err);
              } finally {
                _iterator93.f();
              }
            }(e);
          }), r("    adjustCoordinateSystem", function () {
            er.adjust(e);
          }), r("    position", function () {
            ge(e);
          }), r("    positionSelfEdges", function () {
            !function (e) {
              var _iterator95 = _createForOfIteratorHelper(e.nodes()),
                  _step95;

              try {
                for (_iterator95.s(); !(_step95 = _iterator95.n()).done;) {
                  var r = _step95.value;
                  var n = e.node(r);

                  if (vr(n)) {
                    var t = e.node(n.e.v),
                        o = t.x + t.width / 2,
                        i = t.y,
                        a = n.x - o,
                        s = t.height / 2;
                    e.setEdge(n.e, n.label), e.removeNode(r), n.label.points = [{
                      x: o + 2 * a / 3,
                      y: i - s
                    }, {
                      x: o + 5 * a / 6,
                      y: i - s
                    }, {
                      x: o + a,
                      y: i
                    }, {
                      x: o + 5 * a / 6,
                      y: i + s
                    }, {
                      x: o + 2 * a / 3,
                      y: i + s
                    }], n.label.x = n.x, n.label.y = n.y;
                  }
                }
              } catch (err) {
                _iterator95.e(err);
              } finally {
                _iterator95.f();
              }
            }(e);
          }), r("    removeBorderNodes", function () {
            !function (e) {
              var _iterator96 = _createForOfIteratorHelper(e.nodes()),
                  _step96;

              try {
                for (_iterator96.s(); !(_step96 = _iterator96.n()).done;) {
                  var r = _step96.value;

                  if (e.children(r).length) {
                    var n = e.node(r),
                        t = e.node(n.borderTop),
                        o = e.node(n.borderBottom),
                        i = e.node(d(n.borderLeft)),
                        a = e.node(d(n.borderRight));
                    n.width = Math.abs(a.x - i.x), n.height = Math.abs(o.y - t.y), n.x = i.x + n.width / 2, n.y = t.y + n.height / 2;
                  }
                }
              } catch (err) {
                _iterator96.e(err);
              } finally {
                _iterator96.f();
              }

              var _iterator97 = _createForOfIteratorHelper(e.nodes()),
                  _step97;

              try {
                for (_iterator97.s(); !(_step97 = _iterator97.n()).done;) {
                  var r = _step97.value;
                  "border" === e.node(r).dummy && e.removeNode(r);
                }
              } catch (err) {
                _iterator97.e(err);
              } finally {
                _iterator97.f();
              }
            }(e);
          }), r("    normalize.undo", function () {
            ar.undo(e);
          }), r("    fixupEdgeLabelCoords", function () {
            !function (e) {
              var _iterator98 = _createForOfIteratorHelper(e.edges()),
                  _step98;

              try {
                for (_iterator98.s(); !(_step98 = _iterator98.n()).done;) {
                  var r = _step98.value;
                  var n = e.edge(r);
                  if (s(n, "x")) switch ("l" !== n.labelpos && "r" !== n.labelpos || (n.width -= n.labeloffset), n.labelpos) {
                    case "l":
                      n.x -= n.width / 2 + n.labeloffset;
                      break;

                    case "r":
                      n.x += n.width / 2 + n.labeloffset;
                  }
                }
              } catch (err) {
                _iterator98.e(err);
              } finally {
                _iterator98.f();
              }
            }(e);
          }), r("    undoCoordinateSystem", function () {
            er.undo(e);
          }), r("    translateGraph", function () {
            !function (e) {
              var r,
                  n,
                  t,
                  o = Number.POSITIVE_INFINITY,
                  i = 0,
                  a = Number.POSITIVE_INFINITY,
                  d = 0,
                  u = e.graph(),
                  f = null !== (r = u.marginx) && void 0 !== r ? r : 0,
                  h = null !== (n = u.marginy) && void 0 !== n ? n : 0;

              function c(e) {
                var r = e.x,
                    n = e.y,
                    t = e.width,
                    s = e.height;
                o = Math.min(o, r - t / 2), i = Math.max(i, r + t / 2), a = Math.min(a, n - s / 2), d = Math.max(d, n + s / 2);
              }

              var _iterator99 = _createForOfIteratorHelper(e.nodes()),
                  _step99;

              try {
                for (_iterator99.s(); !(_step99 = _iterator99.n()).done;) {
                  var v = _step99.value;
                  c(e.node(v));
                }
              } catch (err) {
                _iterator99.e(err);
              } finally {
                _iterator99.f();
              }

              var _iterator100 = _createForOfIteratorHelper(e.edges()),
                  _step100;

              try {
                for (_iterator100.s(); !(_step100 = _iterator100.n()).done;) {
                  var l = _step100.value;
                  s(p = e.edge(l), "x") && c(p);
                }
              } catch (err) {
                _iterator100.e(err);
              } finally {
                _iterator100.f();
              }

              var _iterator101 = _createForOfIteratorHelper((o -= f, a -= h, e.nodes())),
                  _step101;

              try {
                for (_iterator101.s(); !(_step101 = _iterator101.n()).done;) {
                  var v = _step101.value;
                  var g = e.node(v);
                  g.x -= o, g.y -= a;
                }
              } catch (err) {
                _iterator101.e(err);
              } finally {
                _iterator101.f();
              }

              var _iterator102 = _createForOfIteratorHelper(e.edges()),
                  _step102;

              try {
                for (_iterator102.s(); !(_step102 = _iterator102.n()).done;) {
                  var l = _step102.value;
                  var p = e.edge(l);

                  var _iterator103 = _createForOfIteratorHelper(null !== (t = p.points) && void 0 !== t ? t : []),
                      _step103;

                  try {
                    for (_iterator103.s(); !(_step103 = _iterator103.n()).done;) {
                      var m = _step103.value;
                      m.x -= o, m.y -= a;
                    }
                  } catch (err) {
                    _iterator103.e(err);
                  } finally {
                    _iterator103.f();
                  }

                  p.hasOwnProperty("x") && (p.x -= o), p.hasOwnProperty("y") && (p.y -= a);
                }
              } catch (err) {
                _iterator102.e(err);
              } finally {
                _iterator102.f();
              }

              u.width = i - o + f, u.height = d - a + h;
            }(e);
          }), r("    assignNodeIntersects", function () {
            !function (e) {
              var _iterator104 = _createForOfIteratorHelper(e.edges()),
                  _step104;

              try {
                for (_iterator104.s(); !(_step104 = _iterator104.n()).done;) {
                  var r = _step104.value;
                  var n,
                      t,
                      o = e.edge(r),
                      i = e.node(r.v),
                      a = e.node(r.w);
                  o.points ? (n = o.points[0], t = o.points[o.points.length - 1]) : (o.points = [], n = a, t = i), o.points.unshift(P(i, n)), o.points.push(P(a, t));
                }
              } catch (err) {
                _iterator104.e(err);
              } finally {
                _iterator104.f();
              }
            }(e);
          }), r("    reversePoints", function () {
            !function (e) {
              var _iterator105 = _createForOfIteratorHelper(e.edges()),
                  _step105;

              try {
                for (_iterator105.s(); !(_step105 = _iterator105.n()).done;) {
                  var r = _step105.value;
                  var n = e.edge(r);
                  n.reversed && n.points.reverse();
                }
              } catch (err) {
                _iterator105.e(err);
              } finally {
                _iterator105.f();
              }
            }(e);
          }), r("    acyclic.undo", function () {
            He.undo(e);
          });
        }(r, n);
      }), n("  updateInputGraph", function () {
        !function (e, r) {
          var _iterator106 = _createForOfIteratorHelper(e.nodes()),
              _step106;

          try {
            for (_iterator106.s(); !(_step106 = _iterator106.n()).done;) {
              var n = _step106.value;
              var t = e.node(n),
                  o = r.node(n);
              t && (t.x = o.x, t.y = o.y, r.children(n).length && (t.width = o.width, t.height = o.height));
            }
          } catch (err) {
            _iterator106.e(err);
          } finally {
            _iterator106.f();
          }

          var _iterator107 = _createForOfIteratorHelper(e.edges()),
              _step107;

          try {
            for (_iterator107.s(); !(_step107 = _iterator107.n()).done;) {
              var i = _step107.value;
              var a = e.edge(i),
                  d = r.edge(i);
              a.points = d.points, s(d, "x") && (a.x = d.x, a.y = d.y);
            }
          } catch (err) {
            _iterator107.e(err);
          } finally {
            _iterator107.f();
          }

          e.graph().width = r.graph().width, e.graph().height = r.graph().height;
        }(e, r);
      });
    });
  }, e.nestingGraph = fr, e.normalize = ar, e.order = ee, e.parentDummyChains = dr, e.position = pe, e.rank = $e, e.util = A, e.version = "0.1.3", Object.defineProperty(e, "__esModule", {
    value: !0
  });
});</script>
  <script>"use strict";

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('graphre')) : typeof define === 'function' && define.amd ? define(['exports', 'graphre'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.nomnoml = {}, global.graphre));
})(void 0, function (exports, graphre) {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
   Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return _instanceof(value, P) ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  function range(_ref, count) {
    var _ref2 = _slicedToArray(_ref, 2),
        min = _ref2[0],
        max = _ref2[1];

    var output = [];

    for (var i = 0; i < count; i++) {
      output.push(min + (max - min) * i / (count - 1));
    }

    return output;
  }

  function sum(list, transform) {
    for (var i = 0, summation = 0, len = list.length; i < len; i++) {
      summation += transform(list[i]);
    }

    return summation;
  }

  function find(list, predicate) {
    for (var i = 0; i < list.length; i++) {
      if (predicate(list[i])) return list[i];
    }

    return undefined;
  }

  function last(list) {
    return list[list.length - 1];
  }

  function hasSubstring(haystack, needle) {
    if (needle === '') return true;
    if (!haystack) return false;
    return haystack.indexOf(needle) !== -1;
  }

  function merged(a, b) {
    function assign(target, data) {
      for (var key in data) {
        target[key] = data[key];
      }
    }

    var obj = {};
    assign(obj, a);
    assign(obj, b);
    return obj;
  }

  function indexBy(list, key) {
    var obj = {};

    for (var i = 0; i < list.length; i++) {
      obj[list[i][key]] = list[i];
    }

    return obj;
  }

  function uniqueBy(list, property) {
    var seen = {};
    var out = [];

    for (var i = 0; i < list.length; i++) {
      var key = list[i][property];

      if (!seen[key]) {
        seen[key] = true;
        out.push(list[i]);
      }
    }

    return out;
  }

  var util = /*#__PURE__*/Object.freeze({
    __proto__: null,
    range: range,
    sum: sum,
    find: find,
    last: last,
    hasSubstring: hasSubstring,
    merged: merged,
    indexBy: indexBy,
    uniqueBy: uniqueBy
  });

  function buildStyle(conf, title) {
    var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return {
      title: {
        bold: title.bold || false,
        underline: title.underline || false,
        italic: title.italic || false,
        center: title.center || false
      },
      body: {
        bold: body.bold || false,
        underline: body.underline || false,
        italic: body.italic || false,
        center: body.center || false
      },
      dashed: conf.dashed || false,
      fill: conf.fill || undefined,
      stroke: conf.stroke || undefined,
      visual: conf.visual || 'class',
      direction: conf.direction || undefined
    };
  }

  var styles = {
    ABSTRACT: buildStyle({
      visual: 'class'
    }, {
      center: true,
      italic: true
    }),
    ACTOR: buildStyle({
      visual: 'actor'
    }, {
      center: true
    }, {
      center: true
    }),
    CHOICE: buildStyle({
      visual: 'rhomb'
    }, {
      center: true
    }, {
      center: true
    }),
    CLASS: buildStyle({
      visual: 'class'
    }, {
      center: true,
      bold: true
    }),
    DATABASE: buildStyle({
      visual: 'database'
    }, {
      center: true,
      bold: true
    }, {
      center: true
    }),
    END: buildStyle({
      visual: 'end'
    }, {}),
    FRAME: buildStyle({
      visual: 'frame'
    }, {}),
    HIDDEN: buildStyle({
      visual: 'hidden'
    }, {}),
    INPUT: buildStyle({
      visual: 'input'
    }, {
      center: true
    }),
    INSTANCE: buildStyle({
      visual: 'class'
    }, {
      center: true,
      underline: true
    }),
    LABEL: buildStyle({
      visual: 'none'
    }, {
      center: true
    }),
    NOTE: buildStyle({
      visual: 'note'
    }, {}),
    PACKAGE: buildStyle({
      visual: 'package'
    }, {}),
    RECEIVER: buildStyle({
      visual: 'receiver'
    }, {}),
    REFERENCE: buildStyle({
      visual: 'class',
      dashed: true
    }, {
      center: true
    }),
    SENDER: buildStyle({
      visual: 'sender'
    }, {}),
    START: buildStyle({
      visual: 'start'
    }, {}),
    STATE: buildStyle({
      visual: 'roundrect'
    }, {
      center: true
    }),
    SYNC: buildStyle({
      visual: 'sync'
    }, {
      center: true
    }),
    TABLE: buildStyle({
      visual: 'table'
    }, {
      center: true,
      bold: true
    }),
    TRANSCEIVER: buildStyle({
      visual: 'transceiver'
    }, {}),
    USECASE: buildStyle({
      visual: 'ellipse'
    }, {
      center: true
    }, {
      center: true
    })
  };

  function box(config, clas) {
    clas.width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
      return e.width;
    })));
    clas.height = sum(clas.compartments, function (e) {
      return e.height;
    });
    clas.dividers = [];
    var y = 0;

    var _iterator = _createForOfIteratorHelper(clas.compartments),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var comp = _step.value;
        comp.x = 0;
        comp.y = y;
        comp.width = clas.width;
        y += comp.height;
        if (comp != last(clas.compartments)) clas.dividers.push([{
          x: 0,
          y: y
        }, {
          x: clas.width,
          y: y
        }]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  function icon(config, clas) {
    clas.dividers = [];
    clas.compartments = [];
    clas.width = config.fontSize * 2.5;
    clas.height = config.fontSize * 2.5;
  }

  var layouters = {
    actor: function actor(config, clas) {
      clas.width = Math.max.apply(Math, [config.padding * 2].concat(_toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      }))));
      clas.height = config.padding * 3 + sum(clas.compartments, function (e) {
        return e.height;
      });
      clas.dividers = [];
      var y = config.padding * 3;

      var _iterator2 = _createForOfIteratorHelper(clas.compartments),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var comp = _step2.value;
          comp.x = 0;
          comp.y = y;
          comp.width = clas.width;
          y += comp.height;
          if (comp != last(clas.compartments)) clas.dividers.push([{
            x: config.padding,
            y: y
          }, {
            x: clas.width - config.padding,
            y: y
          }]);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    class: box,
    database: function database(config, clas) {
      clas.width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      })));
      clas.height = sum(clas.compartments, function (e) {
        return e.height;
      }) + config.padding * 2;
      clas.dividers = [];
      var y = config.padding * 1.5;

      var _iterator3 = _createForOfIteratorHelper(clas.compartments),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var comp = _step3.value;
          comp.x = 0;
          comp.y = y;
          comp.width = clas.width;
          y += comp.height;

          if (comp != last(clas.compartments)) {
            var path = range([0, Math.PI], 16).map(function (a) {
              return {
                x: clas.width * 0.5 * (1 - Math.cos(a)),
                y: y + config.padding * (0.75 * Math.sin(a) - 0.5)
              };
            });
            clas.dividers.push(path);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    },
    ellipse: function ellipse(config, clas) {
      var width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      })));
      var height = sum(clas.compartments, function (e) {
        return e.height;
      });
      clas.width = width * 1.25;
      clas.height = height * 1.25;
      clas.dividers = [];
      var y = height * 0.125;

      var sq = function sq(x) {
        return x * x;
      };

      var rimPos = function rimPos(y) {
        return Math.sqrt(sq(0.5) - sq(y / clas.height - 0.5)) * clas.width;
      };

      var _iterator4 = _createForOfIteratorHelper(clas.compartments),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var comp = _step4.value;
          comp.x = width * 0.125;
          comp.y = y;
          comp.width = width;
          y += comp.height;
          if (comp != last(clas.compartments)) clas.dividers.push([{
            x: clas.width / 2 + rimPos(y) - 1,
            y: y
          }, {
            x: clas.width / 2 - rimPos(y) + 1,
            y: y
          }]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    },
    end: icon,
    frame: function frame(config, clas) {
      var w = clas.compartments[0].width;
      var h = clas.compartments[0].height;
      clas.compartments[0].width += h / 2;
      box(config, clas);
      if (clas.dividers.length) clas.dividers.shift();
      clas.dividers.unshift([{
        x: 0,
        y: h
      }, {
        x: w - h / 4,
        y: h
      }, {
        x: w + h / 4,
        y: h / 2
      }, {
        x: w + h / 4,
        y: 0
      }]);
    },
    hidden: function hidden(config, clas) {
      clas.dividers = [];
      clas.compartments = [];
      clas.width = 1;
      clas.height = 1;
    },
    input: box,
    none: box,
    note: box,
    package: box,
    receiver: box,
    rhomb: function rhomb(config, clas) {
      var width = Math.max.apply(Math, _toConsumableArray(clas.compartments.map(function (e) {
        return e.width;
      })));
      var height = sum(clas.compartments, function (e) {
        return e.height;
      });
      clas.width = width * 1.5;
      clas.height = height * 1.5;
      clas.dividers = [];
      var y = height * 0.25;

      var _iterator5 = _createForOfIteratorHelper(clas.compartments),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var comp = _step5.value;
          comp.x = width * 0.25;
          comp.y = y;
          comp.width = width;
          y += comp.height;
          var slope = clas.width / clas.height;
          if (comp != last(clas.compartments)) clas.dividers.push([{
            x: clas.width / 2 + (y < clas.height / 2 ? y * slope : (clas.height - y) * slope),
            y: y
          }, {
            x: clas.width / 2 - (y < clas.height / 2 ? y * slope : (clas.height - y) * slope),
            y: y
          }]);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    },
    roundrect: box,
    sender: box,
    start: icon,
    sync: function sync(config, clas) {
      clas.dividers = [];
      clas.compartments = [];

      if (config.direction == 'LR') {
        clas.width = config.lineWidth * 3;
        clas.height = config.fontSize * 5;
      } else {
        clas.width = config.fontSize * 5;
        clas.height = config.lineWidth * 3;
      }
    },
    table: function table(config, clas) {
      if (clas.compartments.length == 1) {
        box(config, clas);
        return;
      }

      var gridcells = clas.compartments.slice(1);
      var rows = [[]];

      function isRowBreak(e) {
        return !e.lines.length && !e.nodes.length && !e.relations.length;
      }

      function isRowFull(e) {
        var current = last(rows);
        return rows[0] != current && rows[0].length == current.length;
      }

      function isEnd(e) {
        return comp == last(gridcells);
      }

      var _iterator6 = _createForOfIteratorHelper(gridcells),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var comp = _step6.value;

          if (!isEnd() && isRowBreak(comp) && last(rows).length) {
            rows.push([]);
          } else if (isRowFull()) {
            rows.push([comp]);
          } else {
            last(rows).push(comp);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      var header = clas.compartments[0];
      var cellW = Math.max.apply(Math, [header.width / rows[0].length].concat(_toConsumableArray(gridcells.map(function (e) {
        return e.width;
      }))));
      var cellH = Math.max.apply(Math, _toConsumableArray(gridcells.map(function (e) {
        return e.height;
      })));
      clas.width = cellW * rows[0].length;
      clas.height = header.height + cellH * rows.length;
      var hh = header.height;
      clas.dividers = [[{
        x: 0,
        y: header.height
      }, {
        x: 0,
        y: header.height
      }]].concat(_toConsumableArray(rows.map(function (e, i) {
        return [{
          x: 0,
          y: hh + i * cellH
        }, {
          x: clas.width,
          y: hh + i * cellH
        }];
      })), _toConsumableArray(rows[0].map(function (e, i) {
        return [{
          x: (i + 1) * cellW,
          y: hh
        }, {
          x: (i + 1) * cellW,
          y: clas.height
        }];
      })));
      header.x = 0;
      header.y = 0;
      header.width = clas.width;

      for (var i = 0; i < rows.length; i++) {
        for (var j = 0; j < rows[i].length; j++) {
          var cell = rows[i][j];
          cell.x = j * cellW;
          cell.y = hh + i * cellH;
          cell.width = cellW;
        }
      }
    },
    transceiver: box
  };
  var visualizers = {
    actor: function actor(node, x, y, config, g) {
      var a = config.padding / 2;
      var yp = y + a * 4;
      var faceCenter = {
        x: node.x,
        y: yp - a
      };
      g.circle(faceCenter, a).fillAndStroke();
      g.path([{
        x: node.x,
        y: yp
      }, {
        x: node.x,
        y: yp + 2 * a
      }]).stroke();
      g.path([{
        x: node.x - a,
        y: yp + a
      }, {
        x: node.x + a,
        y: yp + a
      }]).stroke();
      g.path([{
        x: node.x - a,
        y: yp + a + config.padding
      }, {
        x: node.x,
        y: yp + config.padding
      }, {
        x: node.x + a,
        y: yp + a + config.padding
      }]).stroke();
    },
    class: function _class(node, x, y, config, g) {
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    database: function database(node, x, y, config, g) {
      var pad = config.padding;
      var cy = y - pad / 2;
      var pi = 3.1416;
      g.rect(x, y + pad, node.width, node.height - pad * 1.5).fill();
      g.path([{
        x: x,
        y: cy + pad * 1.5
      }, {
        x: x,
        y: cy - pad * 0.5 + node.height
      }]).stroke();
      g.path([{
        x: x + node.width,
        y: cy + pad * 1.5
      }, {
        x: x + node.width,
        y: cy - pad * 0.5 + node.height
      }]).stroke();
      g.ellipse({
        x: node.x,
        y: cy + pad * 1.5
      }, node.width, pad * 1.5).fillAndStroke();
      g.ellipse({
        x: node.x,
        y: cy - pad * 0.5 + node.height
      }, node.width, pad * 1.5, 0, pi).fillAndStroke();
    },
    ellipse: function ellipse(node, x, y, config, g) {
      g.ellipse({
        x: node.x,
        y: node.y
      }, node.width, node.height).fillAndStroke();
    },
    end: function end(node, x, y, config, g) {
      g.circle({
        x: node.x,
        y: y + node.height / 2
      }, node.height / 3).fillAndStroke();
      g.fillStyle(config.stroke);
      g.circle({
        x: node.x,
        y: y + node.height / 2
      }, node.height / 3 - config.padding / 2).fill();
    },
    frame: function frame(node, x, y, config, g) {
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    hidden: function hidden(node, x, y, config, g) {},
    input: function input(node, x, y, config, g) {
      g.circuit([{
        x: x + config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height
      }]).fillAndStroke();
    },
    none: function none(node, x, y, config, g) {},
    note: function note(node, x, y, config, g) {
      g.circuit([{
        x: x,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y + config.padding
      }, {
        x: x + node.width,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height
      }, {
        x: x,
        y: y
      }]).fillAndStroke();
      g.path([{
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y + config.padding
      }, {
        x: x + node.width,
        y: y + config.padding
      }]).stroke();
    },
    package: function _package(node, x, y, config, g) {
      var headHeight = node.compartments[0].height;
      g.rect(x, y + headHeight, node.width, node.height - headHeight).fillAndStroke();
      var w = g.measureText(node.name).width + 2 * config.padding;
      g.circuit([{
        x: x,
        y: y + headHeight
      }, {
        x: x,
        y: y
      }, {
        x: x + w,
        y: y
      }, {
        x: x + w,
        y: y + headHeight
      }]).fillAndStroke();
    },
    receiver: function receiver(node, x, y, config, g) {
      g.circuit([{
        x: x - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y
      }, {
        x: x + node.width,
        y: y + node.height
      }, {
        x: x - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height / 2
      }]).fillAndStroke();
    },
    rhomb: function rhomb(node, x, y, config, g) {
      g.circuit([{
        x: node.x,
        y: y
      }, {
        x: x + node.width,
        y: node.y
      }, {
        x: node.x,
        y: y + node.height
      }, {
        x: x,
        y: node.y
      }]).fillAndStroke();
    },
    roundrect: function roundrect(node, x, y, config, g) {
      var r = Math.min(config.padding * 2 * config.leading, node.height / 2);
      g.roundRect(x, y, node.width, node.height, r).fillAndStroke();
    },
    sender: function sender(node, x, y, config, g) {
      g.circuit([{
        x: x,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y + node.height / 2
      }, {
        x: x + node.width - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height
      }]).fillAndStroke();
    },
    start: function start(node, x, y, config, g) {
      g.fillStyle(config.stroke);
      g.circle({
        x: node.x,
        y: y + node.height / 2
      }, node.height / 2.5).fill();
    },
    sync: function sync(node, x, y, config, g) {
      g.fillStyle(config.stroke);
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    table: function table(node, x, y, config, g) {
      g.rect(x, y, node.width, node.height).fillAndStroke();
    },
    transceiver: function transceiver(node, x, y, config, g) {
      g.circuit([{
        x: x - config.padding,
        y: y
      }, {
        x: x + node.width - config.padding,
        y: y
      }, {
        x: x + node.width,
        y: y + node.height / 2
      }, {
        x: x + node.width - config.padding,
        y: y + node.height
      }, {
        x: x - config.padding,
        y: y + node.height
      }, {
        x: x,
        y: y + node.height / 2
      }]).fillAndStroke();
    }
  };

  function layout(measurer, config, ast) {
    function measureLines(lines, fontWeight) {
      if (!lines.length) return {
        width: 0,
        height: config.padding
      };
      measurer.setFont(config, fontWeight, null);
      return {
        width: Math.round(Math.max.apply(Math, _toConsumableArray(lines.map(measurer.textWidth))) + 2 * config.padding),
        height: Math.round(measurer.textHeight() * lines.length + 2 * config.padding)
      };
    }

    function layoutCompartment(c, compartmentIndex, style) {
      var _a, _b;

      var textSize = measureLines(c.lines, compartmentIndex ? 'normal' : 'bold');

      if (!c.nodes.length && !c.relations.length) {
        c.width = textSize.width;
        c.height = textSize.height;
        c.offset = {
          x: config.padding,
          y: config.padding
        };
        return;
      }

      var styledConfig = Object.assign(Object.assign({}, config), {
        direction: (_a = style.direction) !== null && _a !== void 0 ? _a : config.direction
      });
      c.nodes.forEach(function (e) {
        return layoutClassifier(e, styledConfig);
      });
      var g = new graphre.graphlib.Graph();
      g.setGraph({
        rankdir: style.direction || config.direction,
        nodesep: config.spacing,
        edgesep: config.spacing,
        ranksep: config.spacing,
        acyclicer: config.acyclicer,
        ranker: config.ranker
      });

      var _iterator7 = _createForOfIteratorHelper(c.nodes),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var e = _step7.value;
          g.setNode(e.name, {
            width: e.layoutWidth,
            height: e.layoutHeight
          });
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      var _iterator8 = _createForOfIteratorHelper(c.relations),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var r = _step8.value;

          if (r.assoc.indexOf('_') > -1) {
            g.setEdge(r.start, r.end, {
              id: r.id,
              minlen: 0
            });
          } else if (((_b = config.gravity) !== null && _b !== void 0 ? _b : 1) != 1) {
            g.setEdge(r.start, r.end, {
              id: r.id,
              minlen: config.gravity
            });
          } else {
            g.setEdge(r.start, r.end, {
              id: r.id
            });
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      graphre.layout(g);
      var rels = indexBy(c.relations, 'id');
      var nodes = indexBy(c.nodes, 'name');
      g.nodes().forEach(function (name) {
        var node = g.node(name);
        nodes[name].x = node.x;
        nodes[name].y = node.y;
      });
      var left = 0;
      var right = 0;
      var top = 0;
      var bottom = 0;
      g.edges().forEach(function (edgeObj) {
        var edge = g.edge(edgeObj);
        var start = nodes[edgeObj.v];
        var end = nodes[edgeObj.w];
        var rel = rels[edge.id];
        rel.path = [start].concat(_toConsumableArray(edge.points), [end]).map(toPoint);
        var startP = rel.path[1];
        var endP = rel.path[rel.path.length - 2];
        layoutLabel(rel.startLabel, startP, adjustQuadrant(quadrant(startP, start, 4), start, end));
        layoutLabel(rel.endLabel, endP, adjustQuadrant(quadrant(endP, end, 2), end, start));
        left = Math.min.apply(Math, [left, rel.startLabel.x, rel.endLabel.x].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.x;
        })), _toConsumableArray(edge.points.map(function (e) {
          return e.x;
        }))));
        right = Math.max.apply(Math, [right, rel.startLabel.x + rel.startLabel.width, rel.endLabel.x + rel.endLabel.width].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.x;
        }))));
        top = Math.min.apply(Math, [top, rel.startLabel.y, rel.endLabel.y].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.y;
        }))));
        bottom = Math.max.apply(Math, [bottom, rel.startLabel.y + rel.startLabel.height, rel.endLabel.y + rel.endLabel.height].concat(_toConsumableArray(edge.points.map(function (e) {
          return e.y;
        }))));
      });
      var graph = g.graph();
      var width = Math.max(graph.width, right - left);
      var height = Math.max(graph.height, bottom - top);
      var graphHeight = height ? height + 2 * config.gutter : 0;
      var graphWidth = width ? width + 2 * config.gutter : 0;
      c.width = Math.max(textSize.width, graphWidth) + 2 * config.padding;
      c.height = textSize.height + graphHeight + config.padding;
      c.offset = {
        x: config.padding - left,
        y: config.padding - top
      };
    }

    function toPoint(o) {
      return {
        x: o.x,
        y: o.y
      };
    }

    function layoutLabel(label, point, quadrant) {
      if (!label.text) {
        label.width = 0;
        label.height = 0;
        label.x = point.x;
        label.y = point.y;
      } else {
        var fontSize = config.fontSize;
        var lines = label.text.split('`');
        label.width = Math.max.apply(Math, _toConsumableArray(lines.map(function (l) {
          return measurer.textWidth(l);
        }))), label.height = fontSize * lines.length;
        label.x = point.x + (quadrant == 1 || quadrant == 4 ? config.padding : -label.width - config.padding), label.y = point.y + (quadrant == 3 || quadrant == 4 ? config.padding : -label.height - config.padding);
      }
    }

    function quadrant(point, node, fallback) {
      if (point.x < node.x && point.y < node.y) return 1;
      if (point.x > node.x && point.y < node.y) return 2;
      if (point.x > node.x && point.y > node.y) return 3;
      if (point.x < node.x && point.y > node.y) return 4;
      return fallback;
    }

    function adjustQuadrant(quadrant, point, opposite) {
      if (opposite.x == point.x || opposite.y == point.y) return quadrant;
      var flipHorizontally = [4, 3, 2, 1];
      var flipVertically = [2, 1, 4, 3];
      var oppositeQuadrant = opposite.y < point.y ? opposite.x < point.x ? 2 : 1 : opposite.x < point.x ? 3 : 4;

      if (oppositeQuadrant === quadrant) {
        if (config.direction === 'LR') return flipHorizontally[quadrant - 1];
        if (config.direction === 'TB') return flipVertically[quadrant - 1];
      }

      return quadrant;
    }

    function layoutClassifier(clas, config) {
      var style = config.styles[clas.type] || styles.CLASS;
      clas.compartments.forEach(function (co, i) {
        layoutCompartment(co, i, style);
      });
      layouters[style.visual](config, clas);
      clas.layoutWidth = clas.width + 2 * config.edgeMargin;
      clas.layoutHeight = clas.height + 2 * config.edgeMargin;
    }

    layoutCompartment(ast, 0, styles.CLASS);
    return ast;
  }

  var Compartment = function Compartment(lines, nodes, relations) {
    _classCallCheck(this, Compartment);

    this.lines = lines;
    this.nodes = nodes;
    this.relations = relations;
  };

  var Relation = function Relation() {
    _classCallCheck(this, Relation);
  };

  var Classifier = function Classifier(type, name, compartments) {
    _classCallCheck(this, Classifier);

    this.type = type;
    this.name = name;
    this.compartments = compartments;
    this.dividers = [];
  };
  /* parser generated by jison 0.4.18 */

  /*
    Returns a Parser object of the following structure:
     Parser: {
      yy: {}
    }
     Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),
       lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),
           options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },
           performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }
      token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */


  var nomnomlCoreParser = function () {
    var o = function o(k, v, _o, l) {
      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
        ;
      }

      return _o;
    },
        $V0 = [1, 5],
        $V1 = [1, 8],
        $V2 = [5, 6, 12, 14],
        $V3 = [12, 14],
        $V4 = [1, 22];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "root": 3,
        "compartment": 4,
        "EOF": 5,
        "SEP": 6,
        "slot": 7,
        "IDENT": 8,
        "class": 9,
        "association": 10,
        "parts": 11,
        "|": 12,
        "[": 13,
        "]": 14,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        5: "EOF",
        6: "SEP",
        8: "IDENT",
        12: "|",
        13: "[",
        14: "]"
      },
      productions_: [0, [3, 2], [3, 3], [3, 4], [3, 3], [7, 1], [7, 1], [7, 1], [4, 1], [4, 3], [11, 1], [11, 3], [11, 2], [10, 3], [9, 3]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
      /* action[1] */
      , $$
      /* vstack */
      , _$
      /* lstack */
      ) {
        /* this == yyval */
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
          case 2:
            return $$[$0 - 1];

          case 3:
          case 4:
            return $$[$0 - 2];

          case 5:
            this.$ = $$[$0].trim().replace(/\\(\[|\]|\|)/g, '$' + '1');
            break;

          case 6:
          case 7:
            this.$ = $$[$0];
            break;

          case 8:
          case 10:
            this.$ = [$$[$0]];
            break;

          case 9:
            this.$ = $$[$0 - 2].concat($$[$0]);
            break;

          case 11:
            this.$ = $$[$0 - 2].concat([$$[$0]]);
            break;

          case 12:
            this.$ = $$[$0 - 1].concat([[]]);
            break;

          case 13:
            var t = $$[$0 - 1].trim().replace(/\\(\[|\]|\|)/g, '$' + '1').match('^(.*?)([<:o+]*[-_]/?[-_]*[:o+>]*)(.*)$');

            if (!t) {
              throw new Error('line ' + _$[$0].first_line + ': Classifiers must be separated by a relation or a line break');
            }

            this.$ = {
              assoc: t[2],
              start: $$[$0 - 2],
              end: $$[$0],
              startLabel: t[1].trim(),
              endLabel: t[3].trim()
            };
            break;

          case 14:
            var type = 'CLASS';
            var id = $$[$0 - 1][0][0];
            var typeMatch = $$[$0 - 1][0][0].match('<([a-z]*)>(.*)');

            if (typeMatch) {
              type = typeMatch[1].toUpperCase();
              id = typeMatch[2].trim();
            }

            $$[$0 - 1][0][0] = id;
            this.$ = {
              type: type,
              id: id,
              parts: $$[$0 - 1]
            };
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        6: [1, 3],
        7: 4,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, {
        1: [3]
      }, {
        5: [1, 9],
        6: [1, 10]
      }, {
        4: 11,
        7: 4,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, o($V2, [2, 8]), o($V2, [2, 5]), o($V2, [2, 6], {
        8: [1, 12]
      }), o($V2, [2, 7]), {
        4: 14,
        7: 4,
        8: $V0,
        9: 6,
        10: 7,
        11: 13,
        13: $V1
      }, {
        1: [2, 1]
      }, {
        5: [1, 15],
        7: 16,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, {
        5: [1, 17],
        6: [1, 18]
      }, {
        9: 19,
        13: $V1
      }, {
        12: [1, 21],
        14: [1, 20]
      }, o($V3, [2, 10], {
        6: $V4
      }), {
        1: [2, 4]
      }, o($V2, [2, 9]), {
        1: [2, 2]
      }, {
        5: [1, 23],
        7: 16,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, o($V2, [2, 13]), o([5, 6, 8, 12, 14], [2, 14]), o($V3, [2, 12], {
        7: 4,
        9: 6,
        10: 7,
        4: 24,
        8: $V0,
        13: $V1
      }), {
        7: 16,
        8: $V0,
        9: 6,
        10: 7,
        13: $V1
      }, {
        1: [2, 3]
      }, o($V3, [2, 11], {
        6: $V4
      })],
      defaultActions: {
        9: [2, 1],
        15: [2, 4],
        17: [2, 2],
        23: [2, 3]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        var lex = function lex() {
          var token;
          token = lexer.lex() || EOF;

          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }

          return token;
        };

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push('\'' + this.terminals_[p] + '\'');
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (_instanceof(action[0], Array) && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }
              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* generated by jison-lex 0.3.4 */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        // resets the lexer, sets new input
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        // consumes and returns one char from the input
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        // unshifts one char (or a string) into the input
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function more() {
          this._more = true;
          return this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        // retain first n characters of the match
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false; // rule action called reject() implying the next rule should be tested instead.
          }

          return false;
        },
        // return next match in input
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


            return false;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        // return next match that has a token
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              return 12;

            case 1:
              return 8;

            case 2:
              return 13;

            case 3:
              return 14;

            case 4:
              return 6;

            case 5:
              return 5;

            case 6:
              return 'INVALID';
          }
        },
        rules: [/^(?:\s*\|\s*)/, /^(?:(\\(\[|\]|\|)|[^\]\[|;\n])+)/, /^(?:\[)/, /^(?:\s*\])/, /^(?:[ ]*(;|\n)+[ ]*)/, /^(?:$)/, /^(?:.)/],
        conditions: {
          "INITIAL": {
            "rules": [0, 1, 2, 3, 4, 5, 6],
            "inclusive": true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  function parse(source) {
    function onlyCompilables(line) {
      var ok = line[0] !== '#' && line.trim().substring(0, 2) !== '//';
      return ok ? line.trim() : '';
    }

    function isDirective(line) {
      return line.text[0] === '#';
    }

    var lines = source.split('\n').map(function (s, i) {
      return {
        text: s,
        index: i
      };
    });
    var pureDirectives = lines.filter(isDirective);
    var directives = {};
    pureDirectives.forEach(function (line) {
      try {
        var tokens = line.text.substring(1).split(':');
        directives[tokens[0].trim()] = tokens[1].trim();
      } catch (e) {
        throw new Error('line ' + (line.index + 1) + ': Malformed directive');
      }
    });
    var pureDiagramCode = lines.map(function (e) {
      return onlyCompilables(e.text);
    }).join('\n');

    if (pureDiagramCode == '') {
      return {
        root: new Compartment([], [], []),
        config: getConfig(directives)
      };
    }

    var parseTree = intermediateParse(pureDiagramCode);
    return {
      root: transformParseIntoSyntaxTree(parseTree),
      config: getConfig(directives)
    };

    function directionToDagre(word) {
      if (word == 'down') return 'TB';
      if (word == 'right') return 'LR';else return 'TB';
    }

    function parseRanker(word) {
      if (word == 'network-simplex' || word == 'tight-tree' || word == 'longest-path') {
        return word;
      }

      return 'network-simplex';
    }

    function parseCustomStyle(styleDef) {
      var contains = hasSubstring;
      var floatingKeywords = styleDef.replace(/[a-z]*=[^ ]+/g, '');
      var titleDef = last(styleDef.match('title=([^ ]*)') || ['']);
      var bodyDef = last(styleDef.match('body=([^ ]*)') || ['']);
      return {
        title: {
          bold: contains(titleDef, 'bold') || contains(floatingKeywords, 'bold'),
          underline: contains(titleDef, 'underline') || contains(floatingKeywords, 'underline'),
          italic: contains(titleDef, 'italic') || contains(floatingKeywords, 'italic'),
          center: !(contains(titleDef, 'left') || contains(styleDef, 'align=left'))
        },
        body: {
          bold: contains(bodyDef, 'bold'),
          underline: contains(bodyDef, 'underline'),
          italic: contains(bodyDef, 'italic'),
          center: contains(bodyDef, 'center')
        },
        dashed: contains(styleDef, 'dashed'),
        fill: last(styleDef.match('fill=([^ ]*)') || []),
        stroke: last(styleDef.match('stroke=([^ ]*)') || []),
        visual: last(styleDef.match('visual=([^ ]*)') || []) || 'class',
        direction: directionToDagre(last(styleDef.match('direction=([^ ]*)') || []))
      };
    }

    function getConfig(d) {
      var _a;

      var userStyles = {};

      for (var key in d) {
        if (key[0] != '.') continue;
        var styleDef = d[key];
        userStyles[key.substring(1).toUpperCase()] = parseCustomStyle(styleDef);
      }

      return {
        arrowSize: +d.arrowSize || 1,
        bendSize: +d.bendSize || 0.3,
        direction: directionToDagre(d.direction),
        gutter: +d.gutter || 5,
        edgeMargin: +d.edgeMargin || 0,
        gravity: +((_a = d.gravity) !== null && _a !== void 0 ? _a : 1),
        edges: d.edges == 'hard' ? 'hard' : 'rounded',
        fill: (d.fill || '#eee8d5;#fdf6e3;#eee8d5;#fdf6e3').split(';'),
        background: d.background || 'transparent',
        fillArrows: d.fillArrows === 'true',
        font: d.font || 'Helvetica',
        fontSize: +d.fontSize || 12,
        leading: +d.leading || 1.25,
        lineWidth: +d.lineWidth || 3,
        padding: +d.padding || 8,
        spacing: +d.spacing || 40,
        stroke: d.stroke || '#33322E',
        title: d.title || '',
        zoom: +d.zoom || 1,
        acyclicer: d.acyclicer === 'greedy' ? 'greedy' : undefined,
        ranker: parseRanker(d.ranker),
        styles: merged(styles, userStyles)
      };
    }
  }

  function intermediateParse(source) {
    return nomnomlCoreParser.parse(source);
  }

  function transformParseIntoSyntaxTree(entity) {
    function isAstClassifier(obj) {
      return obj.parts !== undefined;
    }

    function isAstRelation(obj) {
      return obj.assoc !== undefined;
    }

    var relationId = 0;

    function transformCompartment(slots) {
      var lines = [];
      var rawClassifiers = [];
      var relations = [];
      slots.forEach(function (p) {
        if (typeof p === 'string') lines.push(p);

        if (isAstRelation(p)) {
          rawClassifiers.push(p.start);
          rawClassifiers.push(p.end);
          relations.push({
            id: relationId++,
            assoc: p.assoc,
            start: p.start.parts[0][0],
            end: p.end.parts[0][0],
            startLabel: {
              text: p.startLabel
            },
            endLabel: {
              text: p.endLabel
            }
          });
        }

        if (isAstClassifier(p)) {
          rawClassifiers.push(p);
        }
      });
      var allClassifiers = rawClassifiers.map(transformClassifier).sort(function (a, b) {
        return b.compartments.length - a.compartments.length;
      });
      var uniqClassifiers = uniqueBy(allClassifiers, 'name');
      var uniqRelations = relations.filter(function (a) {
        var _iterator9 = _createForOfIteratorHelper(relations),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var b = _step9.value;
            if (a === b) return true;
            if (b.start == a.start && b.end == a.end) return false;
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return true;
      });
      return new Compartment(lines, uniqClassifiers, uniqRelations);
    }

    function transformClassifier(entity) {
      var compartments = entity.parts.map(transformCompartment);
      return new Classifier(entity.type, entity.id, compartments);
    }

    return transformCompartment(entity);
  }

  function add(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y
    };
  }

  function diff(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }

  function mult(v, factor) {
    return {
      x: factor * v.x,
      y: factor * v.y
    };
  }

  function mag(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
  }

  function normalize(v) {
    return mult(v, 1 / mag(v));
  }

  function rot(a) {
    return {
      x: a.y,
      y: -a.x
    };
  }

  function render(graphics, config, compartment, setFont) {
    var g = graphics;

    function renderCompartment(compartment, color, style, level) {
      g.save();
      g.translate(compartment.offset.x, compartment.offset.y);
      g.fillStyle(color || config.stroke);
      compartment.lines.forEach(function (text, i) {
        g.textAlign(style.center ? 'center' : 'left');
        var x = style.center ? compartment.width / 2 - config.padding : 0;
        var y = (0.5 + (i + 0.5) * config.leading) * config.fontSize;

        if (text) {
          g.fillText(text, x, y);
        }

        if (style.underline) {
          var w = g.measureText(text).width;
          y += Math.round(config.fontSize * 0.2) + 0.5;

          if (style.center) {
            g.path([{
              x: x - w / 2,
              y: y
            }, {
              x: x + w / 2,
              y: y
            }]).stroke();
          } else {
            g.path([{
              x: x,
              y: y
            }, {
              x: x + w,
              y: y
            }]).stroke();
          }

          g.lineWidth(config.lineWidth);
        }
      });
      g.translate(config.gutter, config.gutter);
      compartment.relations.forEach(function (r) {
        renderRelation(r);
      });
      compartment.nodes.forEach(function (n) {
        renderNode(n, level);
      });
      g.restore();
    }

    function renderNode(node, level) {
      var x = Math.round(node.x - node.width / 2);
      var y = Math.round(node.y - node.height / 2);
      var style = config.styles[node.type] || styles.CLASS;
      g.fillStyle(style.fill || config.fill[level] || last(config.fill));
      g.strokeStyle(style.stroke || config.stroke);

      if (style.dashed) {
        var dash = Math.max(4, 2 * config.lineWidth);
        g.setLineDash([dash, dash]);
      }

      g.setData('name', node.name);
      var drawNode = visualizers[style.visual] || visualizers.class;
      drawNode(node, x, y, config, g);
      g.translate(x, y);

      var _iterator10 = _createForOfIteratorHelper(node.dividers),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var divider = _step10.value;
          g.path(divider).stroke();
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      g.translate(-x, -y);
      g.setLineDash([]);
      g.save();
      g.translate(x, y);
      node.compartments.forEach(function (part, i) {
        var textStyle = i == 0 ? style.title : style.body;
        g.save();
        g.translate(part.x, part.y);
        setFont(config, textStyle.bold ? 'bold' : 'normal', textStyle.italic ? 'italic' : null);
        renderCompartment(part, style.stroke, textStyle, level + 1);
        g.restore();
      });
      g.restore();
    }

    function strokePath(p) {
      if (config.edges === 'rounded') {
        var radius = config.spacing * config.bendSize;
        g.beginPath();
        g.moveTo(p[0].x, p[0].y);

        for (var i = 1; i < p.length - 1; i++) {
          g.arcTo(p[i].x, p[i].y, p[i + 1].x, p[i + 1].y, radius);
        }

        g.lineTo(last(p).x, last(p).y);
        g.stroke();
      } else g.path(p).stroke();
    }

    var empty = false,
        filled = true,
        diamond = true;

    function renderLabel(label) {
      if (!label || !label.text) return;
      var fontSize = config.fontSize;
      var lines = label.text.split('`');
      lines.forEach(function (l, i) {
        return g.fillText(l, label.x, label.y + fontSize * (i + 1));
      });
    }

    function renderRelation(r) {
      var start = r.path[1];
      var end = r.path[r.path.length - 2];
      var path = r.path.slice(1, -1);
      g.fillStyle(config.stroke);
      setFont(config, 'normal', null);
      renderLabel(r.startLabel);
      renderLabel(r.endLabel);

      if (r.assoc !== '-/-' && r.assoc !== '_/_') {
        if (hasSubstring(r.assoc, '--') || hasSubstring(r.assoc, '__')) {
          var dash = Math.max(4, 2 * config.lineWidth);
          g.setLineDash([dash, dash]);
          strokePath(path);
          g.setLineDash([]);
        } else strokePath(path);
      }

      function drawArrowEnd(id, path, end) {
        if (id === '>' || id === '<') drawArrow(path, filled, end, false);else if (id === ':>' || id === '<:') drawArrow(path, empty, end, false);else if (id === '+') drawArrow(path, filled, end, diamond);else if (id === 'o') drawArrow(path, empty, end, diamond);
      }

      var tokens = r.assoc.split(/[-_]/);
      drawArrowEnd(last(tokens), path, end);
      drawArrowEnd(tokens[0], path.reverse(), start);
    }

    function drawArrow(path, isOpen, arrowPoint, diamond) {
      var size = config.spacing * config.arrowSize / 30;
      var v = diff(path[path.length - 2], last(path));
      var nv = normalize(v);

      function getArrowBase(s) {
        return add(arrowPoint, mult(nv, s * size));
      }

      var arrowBase = getArrowBase(diamond ? 7 : 10);
      var t = rot(nv);
      var arrowButt = diamond ? getArrowBase(14) : isOpen && !config.fillArrows ? getArrowBase(5) : arrowBase;
      var arrow = [add(arrowBase, mult(t, 4 * size)), arrowButt, add(arrowBase, mult(t, -4 * size)), arrowPoint];
      g.fillStyle(isOpen ? config.stroke : config.fill[0]);
      g.circuit(arrow).fillAndStroke();
    }

    function snapToPixels() {
      if (config.lineWidth % 2 === 1) g.translate(0.5, 0.5);
    }

    function setBackground() {
      g.clear();
      g.save();
      g.strokeStyle('transparent');
      g.fillStyle(config.background);
      g.rect(0, 0, compartment.width, compartment.height).fill();
      g.restore();
    }

    g.save();
    g.scale(config.zoom, config.zoom);
    setBackground();
    setFont(config, 'bold', null);
    g.lineWidth(config.lineWidth);
    g.lineJoin('round');
    g.lineCap('round');
    g.strokeStyle(config.stroke);
    snapToPixels();
    renderCompartment(compartment, undefined, buildStyle({}, {}).title, 0);
    g.restore();
  }

  function GraphicsCanvas(canvas, callbacks) {
    var ctx = canvas.getContext('2d');
    var _mousePos = {
      x: 0,
      y: 0
    };
    var twopi = 2 * 3.1416;

    function mouseEventToPos(event) {
      var e = canvas;
      return {
        x: event.clientX - e.getBoundingClientRect().left - e.clientLeft + e.scrollLeft,
        y: event.clientY - e.getBoundingClientRect().top - e.clientTop + e.scrollTop
      };
    }

    if (callbacks) {
      canvas.addEventListener('mousedown', function (event) {
        if (callbacks.mousedown) callbacks.mousedown(mouseEventToPos(event));
      });
      canvas.addEventListener('mouseup', function (event) {
        if (callbacks.mouseup) callbacks.mouseup(mouseEventToPos(event));
      });
      canvas.addEventListener('mousemove', function (event) {
        _mousePos = mouseEventToPos(event);
        if (callbacks.mousemove) callbacks.mousemove(mouseEventToPos(event));
      });
    }

    var chainable = {
      stroke: function stroke() {
        ctx.stroke();
        return chainable;
      },
      fill: function fill() {
        ctx.fill();
        return chainable;
      },
      fillAndStroke: function fillAndStroke() {
        ctx.fill();
        ctx.stroke();
        return chainable;
      }
    };

    function tracePath(path, offset, s) {
      s = s === undefined ? 1 : s;
      offset = offset || {
        x: 0,
        y: 0
      };
      ctx.beginPath();
      ctx.moveTo(offset.x + s * path[0].x, offset.y + s * path[0].y);

      for (var i = 1, len = path.length; i < len; i++) {
        ctx.lineTo(offset.x + s * path[i].x, offset.y + s * path[i].y);
      }

      return chainable;
    }

    return {
      mousePos: function mousePos() {
        return _mousePos;
      },
      width: function width() {
        return canvas.width;
      },
      height: function height() {
        return canvas.height;
      },
      clear: function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      },
      circle: function circle(p, r) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, twopi);
        return chainable;
      },
      ellipse: function ellipse(center, rx, ry, start, stop) {
        if (start === undefined) start = 0;
        if (stop === undefined) stop = twopi;
        ctx.beginPath();
        ctx.save();
        ctx.translate(center.x, center.y);
        ctx.scale(1, ry / rx);
        ctx.arc(0, 0, rx / 2, start, stop);
        ctx.restore();
        return chainable;
      },
      arc: function arc(x, y, r, start, stop) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.arc(x, y, r, start, stop);
        return chainable;
      },
      roundRect: function roundRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + r, r);
        ctx.lineTo(x + w, y + h - r);
        ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
        ctx.lineTo(x + r, y + h);
        ctx.arcTo(x, y + h, x, y + h - r, r);
        ctx.lineTo(x, y + r);
        ctx.arcTo(x, y, x + r, y, r);
        ctx.closePath();
        return chainable;
      },
      rect: function rect(x, y, w, h) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + w, y);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x, y + h);
        ctx.closePath();
        return chainable;
      },
      path: tracePath,
      circuit: function circuit(path, offset, s) {
        tracePath(path, offset, s);
        ctx.closePath();
        return chainable;
      },
      setFont: function setFont(font, bold, ital, fontSize) {
        ctx.font = "".concat(bold, " ").concat(ital || '', " ").concat(fontSize, "pt ").concat(font, ", Helvetica, sans-serif");
      },
      fillStyle: function fillStyle(s) {
        ctx.fillStyle = s;
      },
      strokeStyle: function strokeStyle(s) {
        ctx.strokeStyle = s;
      },
      textAlign: function textAlign(a) {
        ctx.textAlign = a;
      },
      lineCap: function lineCap(cap) {
        ctx.lineCap = cap;
      },
      lineJoin: function lineJoin(join) {
        ctx.lineJoin = join;
      },
      lineWidth: function lineWidth(w) {
        ctx.lineWidth = w;
      },
      arcTo: function arcTo() {
        return ctx.arcTo.apply(ctx, arguments);
      },
      beginPath: function beginPath() {
        return ctx.beginPath.apply(ctx, arguments);
      },
      fillText: function fillText() {
        return ctx.fillText.apply(ctx, arguments);
      },
      lineTo: function lineTo() {
        return ctx.lineTo.apply(ctx, arguments);
      },
      measureText: function measureText() {
        return ctx.measureText.apply(ctx, arguments);
      },
      moveTo: function moveTo() {
        return ctx.moveTo.apply(ctx, arguments);
      },
      restore: function restore() {
        return ctx.restore.apply(ctx, arguments);
      },
      setData: function setData(name, value) {},
      save: function save() {
        return ctx.save.apply(ctx, arguments);
      },
      scale: function scale() {
        return ctx.scale.apply(ctx, arguments);
      },
      setLineDash: function setLineDash() {
        return ctx.setLineDash.apply(ctx, arguments);
      },
      stroke: function stroke() {
        return ctx.stroke.apply(ctx, arguments);
      },
      translate: function translate() {
        return ctx.translate.apply(ctx, arguments);
      }
    };
  }

  function xmlEncode(str) {
    return (str !== null && str !== void 0 ? str : '').toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
  }

  var charWidths = {
    "0": 10,
    "1": 10,
    "2": 10,
    "3": 10,
    "4": 10,
    "5": 10,
    "6": 10,
    "7": 10,
    "8": 10,
    "9": 10,
    " ": 5,
    "!": 5,
    "\"": 6,
    "#": 10,
    "$": 10,
    "%": 15,
    "&": 11,
    "'": 4,
    "(": 6,
    ")": 6,
    "*": 7,
    "+": 10,
    ",": 5,
    "-": 6,
    ".": 5,
    "/": 5,
    ":": 5,
    ";": 5,
    "<": 10,
    "=": 10,
    ">": 10,
    "?": 10,
    "@": 17,
    "A": 11,
    "B": 11,
    "C": 12,
    "D": 12,
    "E": 11,
    "F": 10,
    "G": 13,
    "H": 12,
    "I": 5,
    "J": 9,
    "K": 11,
    "L": 10,
    "M": 14,
    "N": 12,
    "O": 13,
    "P": 11,
    "Q": 13,
    "R": 12,
    "S": 11,
    "T": 10,
    "U": 12,
    "V": 11,
    "W": 16,
    "X": 11,
    "Y": 11,
    "Z": 10,
    "[": 5,
    "\\": 5,
    "]": 5,
    "^": 8,
    "_": 10,
    "`": 6,
    "a": 10,
    "b": 10,
    "c": 9,
    "d": 10,
    "e": 10,
    "f": 5,
    "g": 10,
    "h": 10,
    "i": 4,
    "j": 4,
    "k": 9,
    "l": 4,
    "m": 14,
    "n": 10,
    "o": 10,
    "p": 10,
    "q": 10,
    "r": 6,
    "s": 9,
    "t": 5,
    "u": 10,
    "v": 9,
    "w": 12,
    "x": 9,
    "y": 9,
    "z": 9,
    "{": 6,
    "|": 5,
    "}": 6,
    "~": 10
  };

  function GraphicsSvg(globalStyle, document) {
    var initialState = {
      x: 0,
      y: 0,
      stroke: 'none',
      strokeWidth: 1,
      dashArray: 'none',
      fill: 'none',
      textAlign: 'left',
      font: 'Helvetica, Arial, sans-serif',
      fontSize: 12,
      attributes: {}
    };
    var states = [initialState];
    var elements = [];
    var measurementCanvas = document ? document.createElement('canvas') : null;
    var ctx = measurementCanvas ? measurementCanvas.getContext('2d') : null;

    var Element = /*#__PURE__*/function () {
      function Element(name, attr, content) {
        _classCallCheck(this, Element);

        this.name = name;
        this.attr = attr;
        this.content = content || undefined;
      }

      _createClass(Element, [{
        key: "stroke",
        value: function stroke() {
          var base = this.attr.style || '';
          this.attr.style = base + 'stroke:' + lastDefined('stroke') + ';fill:none' + ';stroke-dasharray:' + lastDefined('dashArray') + ';stroke-width:' + lastDefined('strokeWidth') + ';';
          return this;
        }
      }, {
        key: "fill",
        value: function fill() {
          var base = this.attr.style || '';
          this.attr.style = base + 'stroke:none; fill:' + lastDefined('fill') + ';';
          return this;
        }
      }, {
        key: "fillAndStroke",
        value: function fillAndStroke() {
          var base = this.attr.style || '';
          this.attr.style = base + 'stroke:' + lastDefined('stroke') + ';fill:' + lastDefined('fill') + ';stroke-dasharray:' + lastDefined('dashArray') + ';stroke-width:' + lastDefined('strokeWidth') + ';';
          return this;
        }
      }]);

      return Element;
    }();

    function State(dx, dy) {
      return {
        x: dx,
        y: dy,
        stroke: null,
        strokeWidth: null,
        fill: null,
        textAlign: null,
        dashArray: 'none',
        font: null,
        fontSize: null,
        attributes: null
      };
    }

    function trans(coord, axis) {
      states.forEach(function (t) {
        coord += t[axis];
      });
      return coord;
    }

    function tX(coord) {
      return Math.round(10 * trans(coord, 'x')) / 10;
    }

    function tY(coord) {
      return Math.round(10 * trans(coord, 'y')) / 10;
    }

    function lastDefined(property) {
      for (var i = states.length - 1; i >= 0; i--) {
        if (states[i][property]) return states[i][property];
      }

      return undefined;
    }

    function last(list) {
      return list[list.length - 1];
    }

    function tracePath(path) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        x: 0,
        y: 0
      };
      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var d = path.map(function (e, i) {
        return (i ? 'L' : 'M') + tX(offset.x + s * e.x) + ' ' + tY(offset.y + s * e.y);
      }).join(' ');
      return newElement('path', {
        d: d
      });
    }

    function newElement(type, attr, content) {
      var element = new Element(type, attr, content);
      var extraData = lastDefined('attributes');

      for (var key in extraData) {
        element.attr['data-' + key] = extraData[key];
      }

      elements.push(element);
      return element;
    }

    return {
      width: function width() {
        return 0;
      },
      height: function height() {
        return 0;
      },
      clear: function clear() {},
      circle: function circle(p, r) {
        return newElement('circle', {
          r: r,
          cx: tX(p.x),
          cy: tY(p.y)
        });
      },
      ellipse: function ellipse(center, w, h, start, stop) {
        if (stop) {
          var y = tY(center.y);
          return newElement('path', {
            d: 'M' + tX(center.x - w / 2) + ' ' + y + 'A' + w / 2 + ' ' + h / 2 + ' 0 1 0 ' + tX(center.x + w / 2) + ' ' + y
          });
        } else {
          return newElement('ellipse', {
            cx: tX(center.x),
            cy: tY(center.y),
            rx: w / 2,
            ry: h / 2
          });
        }
      },
      arc: function arc(x, y, r) {
        return newElement('ellipse', {
          cx: tX(x),
          cy: tY(y),
          rx: r,
          ry: r
        });
      },
      roundRect: function roundRect(x, y, w, h, r) {
        return newElement('rect', {
          x: tX(x),
          y: tY(y),
          rx: r,
          ry: r,
          height: h,
          width: w
        });
      },
      rect: function rect(x, y, w, h) {
        return newElement('rect', {
          x: tX(x),
          y: tY(y),
          height: h,
          width: w
        });
      },
      path: tracePath,
      circuit: function circuit(path, offset, s) {
        var element = tracePath(path, offset, s);
        element.attr.d += ' Z';
        return element;
      },
      setFont: function setFont(font, bold, ital, fontSize) {
        var font = "".concat(bold, " ").concat(ital || '', " ").concat(fontSize, "pt ").concat(font, ", Helvetica, sans-serif");
        last(states).font = font;
        last(states).fontSize = fontSize;
      },
      strokeStyle: function strokeStyle(stroke) {
        last(states).stroke = stroke;
      },
      fillStyle: function fillStyle(fill) {
        last(states).fill = fill;
      },
      arcTo: function arcTo(x1, y1, x2, y2) {
        last(elements).attr.d += 'L' + tX(x1) + ' ' + tY(y1) + ' L' + tX(x2) + ' ' + tY(y2) + ' ';
      },
      beginPath: function beginPath() {
        return newElement('path', {
          d: ''
        });
      },
      fillText: function fillText(text, x, y) {
        var attr = {
          x: tX(x),
          y: tY(y),
          style: 'fill: ' + last(states).fill + ';'
        };
        var font = lastDefined('font');

        if (font) {
          attr.style += 'font:' + font + ';';
        }

        if (lastDefined('textAlign') === 'center') {
          attr.style += 'text-anchor: middle;';
        }

        return newElement('text', attr, text);
      },
      lineCap: function lineCap(cap) {
        globalStyle += ';stroke-linecap:' + cap;
      },
      lineJoin: function lineJoin(join) {
        globalStyle += ';stroke-linejoin:' + join;
      },
      lineTo: function lineTo(x, y) {
        last(elements).attr.d += 'L' + tX(x) + ' ' + tY(y) + ' ';
        return last(elements);
      },
      lineWidth: function lineWidth(w) {
        last(states).strokeWidth = w;
      },
      measureText: function measureText(s) {
        if (ctx) {
          ctx.font = lastDefined('font') || 'normal 12pt Helvetica';
          return ctx.measureText(s);
        } else {
          return {
            width: sum(s, function (c) {
              var scale = lastDefined('fontSize') / 12;

              if (charWidths[c]) {
                return charWidths[c] * scale;
              }

              return 16 * scale;
            })
          };
        }
      },
      moveTo: function moveTo(x, y) {
        last(elements).attr.d += 'M' + tX(x) + ' ' + tY(y) + ' ';
      },
      restore: function restore() {
        states.pop();
      },
      save: function save() {
        states.push(State(0, 0));
      },
      setData: function setData(name, value) {
        lastDefined('attributes')[name] = value;
      },
      scale: function scale() {},
      setLineDash: function setLineDash(d) {
        last(states).dashArray = d.length === 0 ? 'none' : d[0] + ' ' + d[1];
      },
      stroke: function stroke() {
        last(elements).stroke();
      },
      textAlign: function textAlign(a) {
        last(states).textAlign = a;
      },
      translate: function translate(dx, dy) {
        last(states).x += dx;
        last(states).y += dy;
      },
      serialize: function serialize(size, desc, title) {
        function toAttr(obj) {
          return Object.keys(obj).map(function (key) {
            return "".concat(key, "=\"").concat(xmlEncode(obj[key]), "\"");
          }).join(' ');
        }

        function toHtml(e) {
          return "<".concat(e.name, " ").concat(toAttr(e.attr), ">").concat(xmlEncode(e.content), "</").concat(e.name, ">");
        }

        var elementsToSerialize = elements;

        if (desc) {
          elementsToSerialize.unshift(new Element('desc', {}, desc));
        }

        if (title) {
          elementsToSerialize.unshift(new Element('title', {}, title));
        }

        var innerSvg = elementsToSerialize.map(toHtml).join('\n  ');
        var attrs = {
          version: '1.1',
          baseProfile: 'full',
          width: size.width,
          height: size.height,
          viewbox: '0 0 ' + size.width + ' ' + size.height,
          xmlns: 'http://www.w3.org/2000/svg',
          'xmlns:xlink': 'http://www.w3.org/1999/xlink',
          'xmlns:ev': 'http://www.w3.org/2001/xml-events',
          style: 'font:' + lastDefined('font') + ';' + globalStyle
        };
        return '<svg ' + toAttr(attrs) + '>\n  ' + innerSvg + '\n</svg>';
      }
    };
  }

  function fitCanvasSize(canvas, rect, zoom) {
    canvas.width = rect.width * zoom;
    canvas.height = rect.height * zoom;
  }

  function createMeasurer(config, graphics) {
    return {
      setFont: function setFont(conf, bold, ital) {
        graphics.setFont(conf.font, bold, ital !== null && ital !== void 0 ? ital : null, config.fontSize);
      },
      textWidth: function textWidth(s) {
        return graphics.measureText(s).width;
      },
      textHeight: function textHeight() {
        return config.leading * config.fontSize;
      }
    };
  }

  function parseAndRender(code, graphics, canvas, scale) {
    var parsedDiagram = parse(code);
    var config = parsedDiagram.config;
    var measurer = createMeasurer(config, graphics);
    var graphLayout = layout(measurer, config, parsedDiagram.root);

    if (canvas) {
      fitCanvasSize(canvas, graphLayout, config.zoom * scale);
    }

    config.zoom *= scale;
    render(graphics, config, graphLayout, measurer.setFont);
    return {
      config: config,
      layout: graphLayout
    };
  }

  function draw(canvas, code, scale) {
    return parseAndRender(code, GraphicsCanvas(canvas), canvas, scale || 1);
  }

  function renderSvg(code, document) {
    var skCanvas = GraphicsSvg('', document);

    var _parseAndRender = parseAndRender(code, skCanvas, null, 1),
        config = _parseAndRender.config,
        layout = _parseAndRender.layout;

    return skCanvas.serialize({
      width: layout.width,
      height: layout.height
    }, code, config.title);
  }

  var ImportDepthError = /*#__PURE__*/function (_Error) {
    _inherits(ImportDepthError, _Error);

    var _super = _createSuper(ImportDepthError);

    function ImportDepthError() {
      _classCallCheck(this, ImportDepthError);

      return _super.call(this, 'max_import_depth exceeded');
    }

    return ImportDepthError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function processAsyncImports(source, loadFile) {
    var maxImportDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var lenientLoadFile, imports, imported, _i2, _imports, imp;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              lenientLoadFile = function _lenientLoadFile(key) {
                return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return loadFile(key);

                        case 3:
                          _context.t0 = _context.sent;

                          if (_context.t0) {
                            _context.next = 6;
                            break;
                          }

                          _context.t0 = '';

                        case 6:
                          return _context.abrupt("return", _context.t0);

                        case 9:
                          _context.prev = 9;
                          _context.t1 = _context["catch"](0);
                          return _context.abrupt("return", '');

                        case 12:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 9]]);
                }));
              };

              if (!(maxImportDepth == -1)) {
                _context2.next = 3;
                break;
              }

              throw new ImportDepthError();

            case 3:
              imports = [];
              source.replace(/#import: *(.*)/g, function (a, file) {
                var promise = lenientLoadFile(file).then(function (contents) {
                  return processAsyncImports(contents, loadFile, maxImportDepth - 1);
                });
                imports.push({
                  file: file,
                  promise: promise
                });
                return '';
              });
              imported = {};
              _i2 = 0, _imports = imports;

            case 7:
              if (!(_i2 < _imports.length)) {
                _context2.next = 15;
                break;
              }

              imp = _imports[_i2];
              _context2.next = 11;
              return imp.promise;

            case 11:
              imported[imp.file] = _context2.sent;

            case 12:
              _i2++;
              _context2.next = 7;
              break;

            case 15:
              return _context2.abrupt("return", source.replace(/#import: *(.*)/g, function (a, file) {
                return imported[file];
              }));

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  }

  function processImports(source, loadFile) {
    var maxImportDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;

    if (maxImportDepth == -1) {
      throw new ImportDepthError();
    }

    function lenientLoadFile(key) {
      try {
        return loadFile(key) || '';
      } catch (e) {
        return '';
      }
    }

    return source.replace(/#import: *(.*)/g, function (a, file) {
      return processImports(lenientLoadFile(file), loadFile, maxImportDepth - 1);
    });
  }

  function compileFile(filepath, maxImportDepth) {
    var fs = require('fs');

    var path = require('path');

    var directory = path.dirname(filepath);
    var rootFileName = filepath.substr(directory.length);

    function loadFile(filename) {
      return fs.readFileSync(path.join(directory, filename), {
        encoding: 'utf8'
      });
    }

    return processImports(loadFile(rootFileName), loadFile, maxImportDepth);
  }

  var version = '1.3.1';
  exports.Classifier = Classifier;
  exports.Compartment = Compartment;
  exports.ImportDepthError = ImportDepthError;
  exports.Relation = Relation;
  exports.compileFile = compileFile;
  exports.draw = draw;
  exports.intermediateParse = intermediateParse;
  exports.layout = layout;
  exports.parse = parse;
  exports.processAsyncImports = processAsyncImports;
  exports.processImports = processImports;
  exports.renderSvg = renderSvg;
  exports.skanaar = util;
  exports.styles = styles;
  exports.transformParseIntoSyntaxTree = transformParseIntoSyntaxTree;
  exports.version = version;
  exports.visualizers = visualizers;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});</script>
  <script>HTMLWidgets.widget({
  name: 'nomnoml',
  type: 'output',

  factory: function(el, width, height) {
    var g = null;
    var svg = null;
    var png = null;
    var canvas = null;
    var wrapper = null;
    var code = null;
    var initialized_canvas = false;
    var initialized_svg = false;
    
    var resizeSvg = function(width, height) {
      el.style.width = width;
      el.style.height = height;
      
      wrapper.setAttribute('width', width);
      wrapper.setAttribute('height', height);
      
      var scale = Math.min(width / svg.getAttribute("width"), height / svg.getAttribute("height"));
      var innerWidth = svg.getAttribute("width") * scale;
      var innerHeight = svg.getAttribute("height") * scale;
      g.setAttribute(
        "transform",
        "translate(" + (width  / 2 - innerWidth / 2) +
        "," + (height / 2 - innerHeight / 2) + ")" +
        "scale(" + scale + ") "
      );  
    };
    
    var resizeCanvas = function(width, height) {
      
      nomnoml.draw(canvas, code);
      
      var actualWidth = canvas.getAttribute('width');
      var actualHeight = canvas.getAttribute('height');
      
      var scale = Math.min(width / actualWidth, height / actualHeight);
      
      canvas.style = "transform:" +
        "translate(" + (-actualWidth / 2) + "px," + (-actualHeight / 2) + "px) " +
        "scale(" + scale + ") " +
        "translate(" + (width / 2 / scale) + "px," + (height / 2 / scale) + "px); " +
        "position: absolute; ";
    };
    
    return {
      renderValue: function(x) {
        code = x.code;
        png  = x.png;
        
        if (x.svg) {
          if (!initialized_svg) {
            
            wrapper = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            wrapper.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
            el.appendChild(wrapper);
            if (x.className) el.classList.add(x.className);
            
            g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
            wrapper.appendChild(g);
            
            initialized_svg = true;
          }
          
          g.innerHTML = nomnoml.renderSvg(x.code);
          
          svg = g.childNodes[0];
          resizeSvg(width, height);
        }
        else {
          if (!initialized_canvas) {
            
            /* Create a new canvas only on first initalization */
            el.style.textAlign = "left";
            canvas = document.createElement("canvas");
            el.appendChild(canvas);
            initialized_canvas = true;
          }
          
          resizeCanvas(width, height);
          if (png !== null) {
            canvas = document.getElementsByTagName("canvas")[0];
            canvas.toDataURL("image/png");
          }
        }
      },

      resize: function(width, height) {
        if (canvas)
          resizeCanvas(width, height);
        else
          resizeSvg(width, height);
      },
      
      p: "hello world"
    };
  }
});</script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Sales Prediction Model Using Classification Decision
Tree Approach For Small Medium Enterprise Based on Indonesian E-Commerce
Data</h1>
  <h1 class="subtitle">School of Economic and Business, Telkom
University</h1>
  <p class="author">
Raden Johannes, Andry Alamsyah
  </p>
  <p class="date">07 November 2022</p>
</div>
<div id="abstrak" class="slide section level2">
<h1>Abstrak</h1>
<p><strong><em>The growth of internet users in Indonesia gives an impact
on many aspects of daily life, including commerce. Indonesian
smallmedium enterprises took this advantage of new media to derive their
activity by the meaning of online commerce. Until now, there is no known
practical implementation of how to predict their sales and revenue using
their historical transaction. In this paper, we build a sales prediction
model on the Indonesian footwear industry using real-life data crawled
on Tokopedia, one of the biggest e-commerce providers in Indonesia. Data
mining is a discipline that can be used to gather information by
processing the data. By using the method of classification in data
mining, this research will describe patterns of the market and predict
the potential of the region in the national market commodities. Our
approach is based on the classification decision tree. We managed to
determine predicted the number of items sold by the viewers, price, and
type of shoes.</em></strong></p>
<p><em>Keywords: Prediction Model, Data Mining, Classification, Decision
Tree, CHAID.</em></p>
</div>
<div id="output" class="slide section level2">
<h1><em>Output</em></h1>
<h3 id="we-managed-to-determine-predicted-the-number-of-items-sold-by-the-viewers-price-and-type-of-shoes."><em>We
managed to determine predicted the number of items sold by the viewers,
price, and type of shoes</em>.</h3>
</div>
<div id="theoretical-background" class="slide section level2 smaller">
<h1 class="smaller"><em>Theoretical Background</em></h1>
<div class="columns">
<div class="column" style="width:50%;">
<h3 id="social-computing"><em>Social Computing</em></h3>
<p>Social computing is concerned with the study of social behavior, and
social context based on computational systems. Social computing provides
four main facilities to the behavioral modeling.</p>
<ol style="list-style-type: decimal">
<li>Model: Building To create &amp; build up models for behavior.
1.Analysis: Review the creation &amp; already created models with their
design work.</li>
<li>Pattern mining: Minimize the patterns through mining.</li>
<li>Prediction: Follow the rules &amp; regulations to control the error
in the designing.</li>
</ol>
<h3 id="classification">Classification</h3>
<p>Classification models describe data relationships and predict values
for future observations. Classification maps data into predefined groups
of classes. It is often referred to as supervised learning because the
classes are determined before examining the data.</p>
<h3 id="decision-tree">Decision Tree</h3>
<p>The decision tree is a logical model represented as a binary (two-way
split) tree that shows how the value of a target variable (output) can
be predicted by using the values of a set of predictor variables
(input). Decision tree is a predictive model which can be used to
represent both classifiers and regression models.</p>
</div><div class="column" style="width:50%;">
<h3 id="crisp-dp">CRISP-DP</h3>
<p>The Cross-Industry Standard Process for Data Mining (CRISP-DM) is a
popular methodology for increasing the success of DM projects. This
methodology defines a non-rigid sequence of six phases, which allow the
building and implementation of a DM model to be used in a real
environment, helping to support business decisions</p>
<div class="figure" style="text-align: center">
<img src="data:image/png;base64,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" alt="CRISP-DM Process" width="50%" />
<p class="caption">
CRISP-DM Process
</p>
</div>
</div>
</div>
</div>
<div id="methodology" class="slide section level2">
<h1>Methodology</h1>
<p>We investigate data of shoe sales in Indonesia using the web mining
method on online marketplace website (tokopedia.com) until March <span class="math inline">\(3^{rd}\)</span>, 2015. The attribute used in this
research are:</p>
<ol style="list-style-type: decimal">
<li>price,</li>
<li>type of shoes,</li>
<li>insurance,</li>
<li>product viewer,</li>
<li>city of the seller,</li>
<li>rating of speed, service, and accuracy.</li>
</ol>
<p>has an impact on product sales.</p>
<div id="htmlwidget-0d29ac5c20044efc273a" style="width:768px;height:576px;" class="nomnoml html-widget"></div>
<script type="application/json" data-for="htmlwidget-0d29ac5c20044efc273a">{"x":{"code":"\n#fill: #FEFEFF\n#lineWidth: 1\n#zoom: 4\n#direction: right\n\n\n                 [Tokopedia] -> [Scraping]\n                 [Scraping] -> [Pre Processing]\n                 [Pre Processing] -> [Modelling]\n                 [Modelling] -> [Prediction]\n                 ","svg":false,"png":null},"evals":[],"jsHooks":[]}</script>
</div>
<div id="chaid-analysis" class="slide section level2">
<h1>CHAID Analysis</h1>
<div class="columns">
<div class="column" style="width:50%;">
<p>There are several steps to make a decision tree using the CHAID
algorithm which are:</p>
<ol style="list-style-type: decimal">
<li>Merging. Category merging can be done on an independent variable
that has more than two categories that are related.</li>
<li>Splitting. In this part independent variable which used as the best
split node. Splitting was conducted with a p-value on each independent
variable.</li>
<li>Stopping. The decision tree should be terminated by the rules. If
there is no significant independent variable or if a tree reaches a
maximum value limit of the tree defined specifications.</li>
</ol>
</div><div class="column" style="width:50%;">
<div class="figure" style="text-align: center">
<img src="data:image/png;base64,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" alt="CHAID Flowchart" width="50%" />
<p class="caption">
CHAID Flowchart
</p>
</div>
</div>
</div>
</div>
<div id="chaid" class="slide section level2">
<h1>CHAID</h1>
<p>In CHAID analysis, the following are the components of the decision
tree:</p>
<ul>
<li><em>Root Node</em>: The root node contains the dependent variable or
target variable. For example, a bank can predict the credit card risk
based upon information like age, income, number of credit cards, etc. In
this example, credit card risk is the target variable and the remaining
factors are the predictor variables.</li>
<li><em>Parents Node</em>: The algorithm splits the target variable
into two or more categories. These categories are called parent nodes or
initial nodes. For the bank example, high, medium, and low categories
are the parents nodes.</li>
<li><em>Child Node</em>: Independent variable categories which come
below the parents categories in the CHAID analysis tree are called the
child node.</li>
<li><em>Terminal Node</em>: The last categories of the CHAID analysis
tree are called the terminal node. In the CHAID analysis tree, the
category that is a major influence on the dependent variable comes first
and the less important category comes last. Thus, it is called the
terminal node.</li>
</ul>
</div>
<div id="chaid-modelling" class="slide section level2">
<h1>CHAID Modelling</h1>
<p>Menggunakan data yang telah dikategorisasi terlebih dahulu.</p>
<div class="figure" style="text-align: center">
<img src="data:image/png;base64,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jhI+iqsebwkDkTjqTDn/dQin2AENaSSfEQjhKMFQXsSRjrfEhK6cK3Ghft2VxMREXn31VebPn38RT//nMHXqVKKjoym0WunZs6dRp0I6E18jQQgNydnszK7oz71jxw5at25d6Ygsr59lJSkvh09lc/6cD+V9b7jSt29f41htyZIlFzSOQqEoi/LxUVz1ePppjBr965DdAAAgAElEQVQ1yqF3pOParOPf0O2X5+j6y3N0/+UFckvzjByGH7w/FnDPPaP/OXbsGFu2bDnn5jhu3Djj6x9//JHBgwczevRosrOzvc5PH0fTNKOEw+VGt25dHV9IzVGnS54A7RjSfhRpP44UztpdXiLTXEVAmzZtykRknY8QOd/f6zxzCVX02V1s8kJvz+X5fCaTidjY2MvGh0uhuBJQwkehcEEIQVJSktOm40i3l1aSwdH84xzNP8Gx/JPYpSOq6/ffD7Hom0UsW7aMo0ePMnz4cFJTU8nPz+eNN94gOTkZu93O/v37yczMZOHChSQlJZGTk8Pw4cN5/vnnsdvtRqFNPRx7woQJxMbG8vvvv192R1iVJSAgwPGF0yRmL52PvfQTtNIp2G1zADvgKL+RlZVV5n7XcHc9+s0V13UpLS018upIKcnPzyclJeWCc+3o4is1NZXMzEw3MZaXl2fk3LlQMaILtLy8PACsVispKSle8w75+voyZsyYv+33gUJxOaKEj0JRCaTu0OxC48Y30K5dO+677z4GDBjATTfdxH/+8x8KCwupVq0amqbx+++/c+rUKfLz89m6dStZWVlYLBZuuukmFixY4GZhEEJw9913s3fvXo4cOcItt9xS4Zz8/f1p3br1ZRXVpTN37nxAIjQBQgNwHmtJR24kZ7vc3Fx69HCUtPB8Bikl8+bNc0veqGlaGevQnj17mDt3LkI4hNT48eN5+umnmT59+gULhp9++ol//etfDB06lFOnThnzGTNmDM888wyzZs3yOueKcG3722+/MWTIEKxWK1OmTOHpp5/mo48+wmq1un1P2O12tm3bdkHPoFAovKOEj0LhwtkcPmA44UpHhJfE4apipKFxISAggJtvvpnPP//c63GL67UJEybQpk0bI5wdzlowjh07xrZt2xgyZMg551qjRg3eeOONMnO/fJBgAikFYOZscS6ByWlTe/vtt9mwYQNHjx7lnXfeMUTQqlWriI6O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n95AsJcvwd7eBHt7a0K3T5+bGDlyJI8++igvvvgiLVu2ZPXq1VRVVdG1a1datmzJpUuXKC0txWg0cvHiRSorK6moqKBFixacOHHCZaCz2Wy88cYbpKamsmnTJrZv394o04enez2ZWf9raVgv2JUdR8vRwmCwy2cvb4K8fcER0H7//fczYsQIunXrxjvvvIOfnx/79u2jtLSU4cOHU1hYiNls5ty5c9hsNs6cOYOiKFRUVODn56elEVB5r7CwkOXLl7Nz505++eUXdu/eXe+aCyEICwvj6NGjJCUlaauE3t7ehIaG8p///IexY8cSGBjYaPOUEII2bdqwdu1aRowYQdeuXRtcVmNw3dTVDDEoOIi1QwY7CddqvwudTsfJkycZNGgQN998M3/+858BVyEVGhpKfHw82dnZDBs2jNdff52+fftqya9Uj3spJR9++CFSSuLj44mNjXXJK3MlqAwSHh5OXFwcO3fupGfPnlp5AwYMYM+ePeTk5NCxY8dG+4xIKfn555+ZNm0ar7/+OllZWVctXNIZQsAHA/pgt/CrolFBTTyZn59PcXExd955J6NGjaJv374cP37cpS26devGjh07tKSMH3zwAXfccQdnz551PMN+bfv27dm7dy9SSs6fP8/o0aM9Okl6rme1UOvSpQs7d+6ktLSUTp06kZ+fT3l5OTqdjh07dhAQENAkiqqXlxfdu3dnx44d+Pj4/C4RHb8LnEIu/96hHY90aFudxtBhokaA2WzixIkT3HHHHdx6662Eh4cDrhOBsLAwTpw4QXp6OkIIli1bxu23346Pjw9QnXfHYDBouXC+//77Bk0mpJTccMMNHD58mICAALp3747JZCI9PZ3u3buzc+dOzp07xx133NEgXzL1lgXz2AAAIABJREFUevXe/v37s2fPHvLy8pp1KgPpyFXhSF7BG717aWfUEFyd43dBQQH5+fmMHDmS2267jT59+pCQkOBizurXrx9RUVGUlJSg0+mYN28eo0ePJi4uTpPzAG3btuXnn39GCEFhYSF33313veSoKucPHjyobfVz/vx5/P39qaio4OOPP6ZXr16cO3eOHj16NCiXjzuWLFmCzWajTZs2lJWVNTgxYmNwPZy9GcE5nN2eAN9uU3aeXubn52uhwOfOncPb25v27duTk5MD2E0rL7zwAvn5+ZSWltKlSxeKi4spKSnB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eWYjiiKvvPIK165dIzc3Fzc3N2JjY4mMjOSRRx7h+++/Z+7cuSxfvpy0tDQWLVokma2uWrWK1157jT/++AMfHx82b95MWVkZ48aN4/vvv0elUuHs7MwDDzzAhx9+SIsWLfjss88YNWoUOp2ORYsWERISwt69ezlx4gTx8fEsW7aMjz76iPbt2/P000/j7e3NtGnTpAFGn+YrV67Qpk0bfHx8OH36NABnzpzBz8+PCRMmoFQqyc3NBSqEte3btxMaGsro0aMpLCzk+PHjDB06lNatW1NcXIydnR1eXl64urqyYMEC0tPTWblyJR999BE+Pj4UFRURFBTE+++/z44dO8jMzEQURebMmcOxY8fw8vKiuLiYXr164eXlxaeffioN6gBdu3bltddeY9u2bURHR1NeXs5///tfZs2ahY2NDTNmzCAhIYHdu3dL79Xnkr9Mw5KcnMzly5cpLS1lxIgRuLi4sG3bNg4fPszq1atJSkqid+/eN71nZ2fHK6+8QmBgIHl5ebi6uhITE0NWVhadO3fm9OnTjBw5ki+//JLIyEh27txJQUEB2dnZrF+/nokTJ3LmzBkeffRR1q9fj5OTE8OHD+fHH38EoFmzZpSXl/PGG2/QqlUrJkyYwJNPPokgCFy9epWFCxeya9cukpKSsLe355NPPmHSpEkUFRUxZswYPD09eeWVVxg5cmSlicrVq1d5//33ad26NZGRkWi1Wo4fP86cOXOYOnUqBQUF0rMKhYLNmzcTExPD5MmTOXPmDGfPnuXf//43LVu2pEuXLvz+++88/fTTODs78/XXX5OamsqWLVuYMmUK48ePJy4ujqioKCZMmMDy5ctRqVQATJgwgTNnzjBw4ECKi4txdHRk6tSpxMfHs3HjRp544gkAjh07RkFBAY8//jjJycm4urryySef8Pzzz/Paa68REBCAWq2uVDdyf5UxRlZurmeWLVuGSqWivLycjz/+GACNRsO4ceMASE9PR6FQSM/rhZ+8vDw2btxISUkJnp6e/Pzzz7i5uXH+/HlOnTrF1KlTEUURDw8P0tLSKsV5/fp1ysvLiYyMJCIigqCgIJKSkoiJiaFjx4506tSJ9u3b37QlZkpB0pxui7nVJMMw9asqPXv2ZPz48SxYsICSkhISExP56aefSElJIT09nYcffpj27dvzww8/sHDhQrKyssjOziYtLY3M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" alt="Model CHAID" width="50%" />
<p class="caption">
Model CHAID
</p>
</div>
</div>
<div id="prediction" class="slide section level2 bigger">
<h1 class="bigger">Prediction</h1>
<p>With terminal and classification patterns, we can predict sales. For
illustration, if we sell shoes at Rp 62.000 with 80 viewers and
classified as Sneakers, there is a 98,2% probability that the shoes
will be sold 1-143 unit, 1.3% probability that the shoes will be sold
155-287 unit, 0.3% probability that the shoes will be sold 431-573 unit,
and 0.2% probability that the shoes will be sold 860-1002 unit.</p>
</div>
<div id="discussion" class="slide section level2">
<h1>Discussion</h1>
<p>CHAID sudah digunakan pada <em>project</em> Lenny, MB, dan Rendy.</p>
</div>

  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

</body>
</html>
